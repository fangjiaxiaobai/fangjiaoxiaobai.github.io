{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"redis数据库\" category",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bziplist/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bziplist/",
            "title": "Redis数据结构之详解 ziplist",
            "date_published": "2021-08-02T10:18:55.000Z",
            "content_html": "<h2 id=\"解密-ziplist\"><a class=\"markdownIt-Anchor\" href=\"#解密-ziplist\">#</a> 解密 ziplist.</h2>\n<p>为什么叫解密  <code>ziplist</code>  呢？因为从 ziplist 中取到我们预期的值，真的和解密一样！烧脑，但是极其有趣！！</p>\n<h3 id=\"引题\"><a class=\"markdownIt-Anchor\" href=\"#引题\">#</a> 引题</h3>\n<p>在介绍  <code>Redis</code>  的数据类型  <code>list</code>  的时候，是我们第一次接触  <code>ziplist</code>  这一数据结构。</p>\n<p>不知道是否还记得  <code>ziplist</code>  这种数据结构的特性。如果不记得也没有关系，今天我们来详细的看下这个数据结构。</p>\n<h3 id=\"重读-ziplist-数据结构\"><a class=\"markdownIt-Anchor\" href=\"#重读-ziplist-数据结构\">#</a> 重读 ziplist 数据结构</h3>\n<p><code>ziplist</code>  是经过特殊编码的双向链接列表，旨在提高内存效率。 它同时存储字符串和整数值，其中整数被编码为实际整数，而不是一系列字符。它允许在  <code>O(1)</code>  时间在列表的任一侧进行推和弹出操作。</p>\n<p>但是，由于每个操作都需要重新分配 <code>ziplist</code>  使用的内存，因此实际的复杂性与 <code>ziplist</code>  使用的内存量有关。</p>\n<p><code>ziplist</code>  的数据结构总览。如下图</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-01-Ziplist%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>我来依次解释下这  <code>5</code>  个部分.</p>\n<ul>\n<li>\n<p><code>&lt;uint32_t zlbytes&gt;</code>  : 存储的  <code>ziplist</code>  占用的字节数 (包含  <code>zlbytes</code>  字段本身的  <code>4</code>  个字节)。因此：无需遍历就能直接知道这个数据结构的大小。</p>\n</li>\n<li>\n<p><code>&lt;uint32_t zltail&gt;</code>  是列表中最后一个条目的偏移量。 这允许在列表的另一端进行弹出操作，而无需完全遍历。在任意一端进行  <code>pop</code>  和  <code>push</code>  操作的时间复杂度都是  <code>O(1)</code>  .</p>\n</li>\n<li>\n<p><code>&lt;uint16_t zllen&gt;</code>  是条目数。当条目数超过 <code>2 ^ 16-2</code>  时，此值将设置为 <code>2 ^ 16-1</code> ，这时，我们需要遍历整个列表以了解其包含多少项了。</p>\n</li>\n<li>\n<p><code>&lt;uint8_t zlend&gt;</code>  是代表 <code>ziplist</code>  末尾的特殊条目。编码为等于 <code>255</code>  的单个字节。</p>\n</li>\n<li>\n<p><code>&lt;entry&gt;</code>  : 往下看.</p>\n</li>\n</ul>\n<h4 id=\"entry\"><a class=\"markdownIt-Anchor\" href=\"#entry\">#</a>  <code>Entry</code></h4>\n<p><code>ziplist</code>  中的每个条目都以包含两个信息的元数据作为前缀。首先，存储前一个  <code>entry</code>  的长度，以便能够从后到前遍历列表。第二，提供  <code>entry</code>  编码。 它表示条目类型，整数或字符串，对于字符串，还表示字符串有效负载的长度。因此，能够像下面这样存储一个完整的  <code>entry</code> .</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-01-entry%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>有时， <code>encoding</code>  也可以代表 <code>entry</code>  本身，就像后面将要看到的小整数一样。在这种情况下， <code>&lt;entry-data&gt;</code>  部分丢失了，我们的 <code>Entry</code>  结构是这样的：</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-01-entry%E7%9A%84%E7%BB%93%E6%9E%842.png\" alt=\"\"></p>\n<p>我们来具体看下  <code>Entry</code>  的编码方式.</p>\n<h5 id=\"prevlen\"><a class=\"markdownIt-Anchor\" href=\"#prevlen\">#</a>  <code>prevlen</code></h5>\n<p><code>&lt;prevlen&gt;</code>  表示 前一个  <code>entry</code>  的长度。</p>\n<ul>\n<li>\n<p>如果 前一个  <code>entry</code>  的长度小于 254 个字节，那么这个  <code>Entry</code>  只会消耗一个字节来表示该长度。一个无符号的  <code>8</code>  位整数。</p>\n</li>\n<li>\n<p>如果前一个  <code>entry</code>  长度大于或等于 <code>254</code>  字节的时候，它将占用 5 个字节。第一个字节设置为  <code>254</code> ( <code>FE</code> ), 以指示随后的值更大。 其他的四个字节将作为前一个 entry 的长度的值。</p>\n</li>\n</ul>\n<p>所以，我们就能知道了 下面这种编码方式.</p>\n<p><code>&lt;prevlen form 9 to 253&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p>\n<p>或者</p>\n<p><code>&lt;prevlen 4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p>\n<h5 id=\"encoding\"><a class=\"markdownIt-Anchor\" href=\"#encoding\">#</a>  <code>encoding</code></h5>\n<p><code>entry</code>  中的  <code>encoding</code>  字段取决于  <code>entry-data</code>  的内容。</p>\n<ul>\n<li>\n<p>如果  <code>entry-data</code>  是字符串的时候， <code>encoding</code>  第一个字节的前两位用于存储字符串长度的编码类型。然后是字符串的实际长度。</p>\n</li>\n<li>\n<p>如果  <code>entry</code>  是整数时，前 <code>2</code>  位都是 <code>1</code> ,。 接下来的两位用于指定在此标头之后将存储哪种类型.</p>\n</li>\n</ul>\n<p>由上面的两点，就足以确定  <code>entry-data</code>  的类型.</p>\n<p>不同的类型和编码的概述如下:</p>\n<h6 id=\"字符串类型\"><a class=\"markdownIt-Anchor\" href=\"#字符串类型\">#</a> 字符串类型</h6>\n<ul>\n<li>\n<p><code>a</code> .  <code>| 00pppppp |</code>  : 含义是占用 <code>1</code>  个字节来表示长度小于或等于 <code>63</code>  个字节（ <code>6</code>  位）的字符串值。   <code>pppppp</code>  表示无符号的 6 位长度。</p>\n</li>\n<li>\n<p><code>b</code> . <code>|01pppppp|qqqqqqqq|</code>  含义是用 <code>2</code>  个字节来表示小于等于  <code>16383(2^14)</code>  个字节的字符串的长度. (<b>这里使用大端法计数</b>)</p>\n</li>\n<li>\n<p><code>c</code> . <code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</code>  含义是 使用 5 个字节来表示大于等于 16384 个字节长度的字符串，只有 4 个字节表示其最大长度为  <code>2^32-1</code> . 低位的 6 位被设置成  <code>0</code> .(<b>这里使用大端法计数</b>)</p>\n</li>\n</ul>\n<h6 id=\"整数类型\"><a class=\"markdownIt-Anchor\" href=\"#整数类型\">#</a> 整数类型</h6>\n<ul>\n<li><code>d</code> . <code>|11000000|</code> : 含义是用 <code>3</code>  个字节表示一个 <code>16</code>  位的有符号的短整形数 ( <code>short</code> )。</li>\n<li><code>e</code> . <code>|11010000|</code>  : 含义是用 <code>5</code>  个字节 表示一个 <code>32</code>  位的有符合整数型 ( <code>int</code> ).</li>\n<li><code>f</code> . <code>|11100000|</code>  : 含义是用 <code>9</code>  个字节，表示一个 <code>64</code>  位的有符合长整数 ( <code>long</code> )</li>\n<li><code>g</code> . <code>|11110000|</code>  : 含义是用 <code>4</code>  个字节表示 <code>24</code>  位有符号整数 (只占用 3 个字节)。PS: 有什么作用呢？前面说的小整形数。节约空间。即如图</li>\n<li><code>h</code> . <code>|11111110|</code>  :  含义是用 <code>2</code>  个字节表示一个 <code>8</code>  位的有符号小整形数。 <code>1</code>  个字节。</li>\n<li><code>i</code> . <code>|1111xxxx|</code>  :<br>\n 除去上面列举的几类编码标识，还有 <code>|1111xxxx|</code>  的类别。<br>\n( <code>xxxx</code>  在 <code>0000</code>  和 <code>1101</code>  之间) 立即 <code>4</code>  位整数。  <code>0</code>  到 <code>12</code>  之间的无符号整数。编码值实际上是 <code>1</code>  到 <code>13</code> ，因为不能使用 <code>0000</code>  和 <code>1111</code> ，因此应从编码的 <code>4</code>  位值中减去 <code>1</code>  以获得正确的值。</li>\n<li><code>j</code> . <code>|11111111| </code> - 表示  <code>ziplist</code>  的特殊  <code>entry</code></li>\n</ul>\n<p>这样，整个 <code>Entry</code>  的编码方式我们就搞明白了。<br>\n这些都是  <code>Redis</code>  中定义的规定， 所以我们记住就行了。如果让我们自己去设计一套编码方案的时候，我们就可以参考这种思路去设计。</p>\n<h3 id=\"那我们来举两个例子来试试身手吧\"><a class=\"markdownIt-Anchor\" href=\"#那我们来举两个例子来试试身手吧\">#</a> 那我们来举两个例子来试试身手吧。</h3>\n<h4 id=\"例子1-25\"><a class=\"markdownIt-Anchor\" href=\"#例子1-25\">#</a> 例子 1:  <code>25</code></h4>\n<h5 id=\"编码方式\"><a class=\"markdownIt-Anchor\" href=\"#编码方式\">#</a> 编码方式</h5>\n<p><code>[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]</code></p>\n<h5 id=\"解析过程\"><a class=\"markdownIt-Anchor\" href=\"#解析过程\">#</a> 解析过程</h5>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-01-Ziplist%E4%BE%8B%E5%AD%90%E7%9A%84%E7%BB%93%E6%9E%841.png\" alt=\"ziplist-01-Ziplist例子的结构1.png\"></p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE.png\" alt=\"\"></p>\n<h4 id=\"例子2-hello-world\"><a class=\"markdownIt-Anchor\" href=\"#例子2-hello-world\">#</a> 例子 2:  <code>Hello World</code></h4>\n<p>这里我们还是接着上面例子来讲，我们再设置一个 字符串  <code>Hello World</code>  。</p>\n<h5 id=\"编码格式\"><a class=\"markdownIt-Anchor\" href=\"#编码格式\">#</a> 编码格式</h5>\n<p><code>[02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]</code></p>\n<h5 id=\"解析过程-2\"><a class=\"markdownIt-Anchor\" href=\"#解析过程-2\">#</a> 解析过程</h5>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-01-Ziplist%E4%BE%8B%E5%AD%90%E7%9A%84%E7%BB%93%E6%9E%842.png\" alt=\"ziplist-01-Ziplist例子的结构2.png\"></p>\n<h5 id=\"附录-ascii码表可展示字符\"><a class=\"markdownIt-Anchor\" href=\"#附录-ascii码表可展示字符\">#</a> 附录，ASCII 码表 (可展示字符)</h5>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/ziplist-ASCII%E7%A0%81%E5%AD%97%E7%AC%A6%E8%A1%A8.png\" alt=\"\"></p>\n<p>以上内容，就是 <code>Redis</code>  的 <code>ziplist</code>  结构的内容了。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>本篇文章的内容主要是更加详细的分享了 <code>ziplist</code>  的这种数据结构的内部结构以及编码方式.</p>\n<ul>\n<li><code>ziplist</code>  由 <code>5</code>  部分组成。存储了相关信息:  <code>&lt;整个ziplist的长度&gt;&lt;最后一个entry的偏移量&gt;&lt;entry的总数&gt;&lt;entries&gt;&lt;表示结束的特殊entry&gt;</code></li>\n<li>一个 <code>entry</code>  由 <code>3</code>  部分组成， <code>&lt;前一个entry的长度&gt;&lt;编码方式&gt;&lt;entry的内容&gt;</code></li>\n<li>其中 编码方式 是由 entry 的内容 决定的。有 10 条标准 (规定 / 协议)</li>\n<li>引用了两个示例 ( <code>25</code>  和 <code>Hello World</code> )，根据 <code>Redis</code>  的方式来解码.</li>\n</ul>\n<h3 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h3>\n<p>期待您的关注，希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/qrcode.jpg\" alt=\"二维码\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-4-%E8%B7%B3%E8%A1%A8/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-4-%E8%B7%B3%E8%A1%A8/",
            "title": "Redis中的数据结构之跳表及其原理",
            "date_published": "2021-08-01T16:00:00.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>文中附代码实现. <a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">电梯直达</a></p>\n<p>在公众号回复 【跳表】 也可以获取哦。</p>\n<h3 id=\"什么是跳表\"><a class=\"markdownIt-Anchor\" href=\"#什么是跳表\">#</a> 什么是跳表</h3>\n<blockquote>\n<p>跳表是一种数据结构。它允许快速查询一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是 O (log n)，优于普通队列的 O (n)。</p>\n</blockquote>\n <p align=right> from. 维基百科</p>\n<h3 id=\"引题\"><a class=\"markdownIt-Anchor\" href=\"#引题\">#</a> 引题</h3>\n<p>线性表这种数据有两种具体实现，数组和链表。具体的内容之前的文章里也有说过，可以翻翻看哇～。在这里两种数据结构中，数组的优点是查找速度快，而链表的优点是增删的效率高，这也是我们常说的。其实，非也。</p>\n<p>数组是一种内存连续的数据结构，其优点是可以通过 <code>首地址+N*(sizeOf(Node))</code>  来快速获取指定位置上的元素。假如我们不知道指定元素的位置呢？</p>\n<p>链表是一种非内存连续的数据，其优点是通过改变指针地址来快速增减元素。很明显的问题，你首先要知道你要增加 / 删除的目标元素是哪个！所以会浪费  <code>O(n)</code>  的查询时间。</p>\n<p>要论效率，那就要说平衡树 ( <code>AVL</code> ) 了。增删查的效率都是  <code>O(logN)</code> 。 但是这种数据结构，原理比较复杂，实现起来那不是比较复杂了，那是相当复杂。增删操作，都需要其依靠平衡操作引发子树的调整。</p>\n<p>那么，掌声有请我们今天的主角: <b>跳表</b>。</p>\n<h2 id=\"跳表\"><a class=\"markdownIt-Anchor\" href=\"#跳表\">#</a> 跳表</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>跳表 ( <code>skip list</code> ) 全称 跳跃链表。 是一种类链表的数据结构。</p>\n<p>跳表的性能和平衡树的性能是一样的，在插入，删除，搜索的时间复杂度都是  <code>O(n)</code> , 是一种利用空间换时间的数据结构。</p>\n<p>跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它。</p>\n<p>这里，先给大家看一个<b>可能</b>的跳表结构。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-02-%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%841.png\" alt=\"跳表-02-可能的跳表结构1.png\"></p>\n<p>现在我要告诉你，上面的跳表是由下面的跳表经过层层优化得来的。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-01-%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.png\" alt=\"跳表-01-有序的链表\"></p>\n<p>下面我们针对上面的跳表结构来分析一下。</p>\n<p>刚才说过了，链表增删性能罪魁祸首就是查找操作！对于查找操作，效率最高的莫过于二分查找了。但是对于第一个有序链表中是无法使用二分查找的。但是呢，我们可以随机抽选中其中的几个元素，组成一个新的链表。就像下面这样。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-03-%E6%8A%BD%E8%B1%A1%E5%87%BA%E6%96%B0%E7%9A%84%E4%B8%80%E5%B1%82.png\" alt=\"跳表-03-抽象出新的一层.png\"></p>\n<p>假设我们要找 <code>5</code>  这个元素，在单独的有序链表中，我们必须从头结点依次遍历到  <code>5</code>  这个节点。路径为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> , 下图中黄色线路径。, 现在，我们只需要从  <code>1-&gt;2-&gt;4-&gt;5</code> . 下图中紫色线路径。既然我们可以原来的链表抽象出一个新的链表，那我们还可以从新的链表中再抽象出一个新的链表。这样的话，就直接可以  <code>1-&gt;4-&gt;5</code> , 就可以查到一个我们的目标节点了。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-04-%E5%86%8D%E6%8A%BD%E8%B1%A1%E5%87%BA%E6%96%B0%E7%9A%84%E4%B8%80%E5%B1%82.png\" alt=\"跳表-04-再抽象出新的一层.png\"></p>\n<p>如果你看到这里，我要告诉你一个重要的概念了。</p>\n<p><strong>层：就是我们假设的抽象出来的新链表。</strong></p>\n<p>可能你很好奇，层我们应该怎么存储呢？很简单啊！</p>\n<p>以后我们每个链表的元素是怎么定义的？？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> &#123;</span></span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">&#125; node;</span><br></pre></td></tr></table></figure>\n<p>我们只需要将 指向下一个元素的指针改成一个指针数组就可以了！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> &#123;</span></span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    <span class=\"comment\">/// 指向后继元素的指针数组</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">next</span>[<span class=\"title\">i</span>];</span></span><br><span class=\"line\">&#125; node;</span><br></pre></td></tr></table></figure>\n<p>了解了怎么存储之后，那怎样确定某个节点有几层呢？这里我告诉你吧，随机的！怎么随机的呢？就是通过随机数来确定的，也就是我们常说的 抛硬币的形式。 比如下面的这段代码.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成一个随机数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 一个随机数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">random_level</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">rand</span>() % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    level = (level &lt; MAX_LEVEL) ? level : MAX_LEVEL;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那我们就尝试着实现一个跳表。</p>\n<h3 id=\"跳表的实现\"><a class=\"markdownIt-Anchor\" href=\"#跳表的实现\">#</a> 跳表的实现</h3>\n<ul>\n<li>定义跳表的结构</li>\n</ul>\n<p>经过上面的分析，每个节点指向下一个节点的指针是一个数组，所以我们得出下面的结构。(当然也有其他方式的实现，欢迎交流～)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 节点</span></span><br><span class=\"line\">NODE &#123;</span><br><span class=\"line\">    T data,</span><br><span class=\"line\">    <span class=\"comment\">/// 指向下一个节点的数组，从1开始。</span></span><br><span class=\"line\">    <span class=\"comment\">/// 数组中的每个元素对应该层的下一个节点</span></span><br><span class=\"line\">    <span class=\"comment\">/// next[1],是第一层的下一个节点的地址。</span></span><br><span class=\"line\">    <span class=\"comment\">/// next[2] 是第二层的下一个节点的地址。</span></span><br><span class=\"line\">    NODE []next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 跳表</span></span><br><span class=\"line\">SKIP_LIST&#123;</span><br><span class=\"line\">    NODE head;</span><br><span class=\"line\">    <span class=\"comment\">/// 该跳表的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查找指定的元素</li>\n</ul>\n<p>上面说过了 查找过程，我这里就直接给出伪代码了。</p>\n<p>主要逻辑是：从高层开始查找直到找到等于指定元素的节点 E 或者第一个大于指定元素的节点 G。如果是节点 E，那么直接返回就好了。如果是 G 节点，那么就以 G 节点的前一个节点 L, 在下一层进行查找，重复上面的逻辑，直到找到节点 E，或者到达跳表的结尾。</p>\n<p>比如下图中查找  <code>5</code>  的过程为:</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-08-%E6%9F%A5%E6%89%BE.png\" alt=\"跳表-08-查找\"></p>\n<ul>\n<li><code>head-&gt;8</code> ,  <code>8&gt;5</code> , 从 <code>head</code>  开始，去下一层查找。</li>\n<li><code>head-&gt;4-&gt;8</code> ,  <code>8&gt;5</code> , 从  <code>4</code>  元素开始查找。去下一层查找</li>\n<li><code>head-&gt;4-&gt;8</code> ,  <code>8&gt;5</code> , 从  <code>4</code>  元素开始查找。去下一层查找.</li>\n<li><code>head-&gt;4-&gt;6</code> ,  <code>6&gt;5</code> , 从  <code>4</code>  元素开始查找。去下一层查找.</li>\n<li><code>head-&gt;4-&gt;5</code> ,  <code>5==5</code> , 返回节点 <code>5</code> .</li>\n</ul>\n<p>如下面的伪代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">search</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// i 表示层数，从最高层开始查找 。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((q = p-&gt;next[i]) &amp;&amp; q-&gt;k &lt; k) &#123;</span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &amp;&amp; k == q-&gt;data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &amp;(q-&gt;data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构建一个跳表。</li>\n</ul>\n<p>上面分析可以得出来，跳表是一个多层的有序链表。所以我们对于每一层都像操作普通链表一样就可以了。就像下面的这样:</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-06-%E6%8F%92%E5%85%A5.png\" alt=\"跳表-06-插入\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">insert</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找到要插入的节点位置。</span></span><br><span class=\"line\">    <span class=\"comment\">// level是本跳表的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = level<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">///遍历该层小于指定值的前一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((q = p-&gt;next[i]) &amp;&amp; q-&gt;k &lt; k) &#123;</span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/// 新节点的前一个节点的层指针。</span></span><br><span class=\"line\">        update[i] = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 随机生成该节点的层数,如果生成的层数大于当前层，需要更新跳表中记录的level值。</span></span><br><span class=\"line\">    new_level = <span class=\"built_in\">rand_level</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(new_level &gt; level) &#123;</span><br><span class=\"line\">        level = new_level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 生成新的节点，并针对每一层执行普通链表的插入操作。</span></span><br><span class=\"line\">    new_node = <span class=\"built_in\">create_new_node</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 下面两行代码就是普通连接的增加方法。</span></span><br><span class=\"line\">        <span class=\"comment\">/// 新节点的前一个节点的第i层的节点。</span></span><br><span class=\"line\">        new_node-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class=\"line\">        update[i]-&gt;next[i] = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除跳表的元素</li>\n</ul>\n<p>主要逻辑是该节点的每一层都要删除.</p>\n<p>即对每一层，都要 要删除节点的上一个节点指向要删除节点的下一个节点。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-07-%E5%88%A0%E9%99%A4.png\" alt=\"跳表-07-删除.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">del</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 找到要删除的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((q = p-&gt;next[i]) &amp;&amp; q-&gt;k &lt; k) &#123;</span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update[i] = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h3>\n<p>👉 <a href=\"https://github.com/fangjiaxiaobai/data_structures_and_algorithms/tree/master/01_data_structures/skiplist/c/01_fangjiaxiaobai\">跳表 <code>C</code>  语言版本</a><br>\n👉 <a href=\"https://github.com/fangjiaxiaobai/data_structures_and_algorithms/tree/master/01_data_structures/skiplist/java/fangjiaxiaobai\">跳表 <code>JAVA</code>  版本</a></p>\n<p>其他语言，比如  <code>python</code> ,  <code>golang</code> ,  <code>c++</code> ,  <code>js</code> ,  <code>php</code> ,  <code>kotlin</code>  版本的代码，你有没有兴趣搞一波呢？👉 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2RhdGFfc3RydWN0dXJlc19hbmRfYWxnb3JpdGhtcw==\">赐教地址</span></p>\n<p>各位看官可以选择自己熟悉的语言查看。实现代码仅供参考。如有高见，欢迎交流哇～，还请不吝赐教！</p>\n<p>也欢迎大侠提交自己擅长语言的代码到仓库～，集思广益，一起交流！期待～～</p>\n<p>(仓库中的数据结构与算法持续更新哦，欢迎 <code>star</code> )</p>\n<h3 id=\"时间复杂度的分析\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度的分析\">#</a> 时间复杂度的分析</h3>\n<p>因为跳表的时间复杂度和跳表的层数以及该层上的节点数和节点分布的位置有关，而这些因素都是随机的。 此中涉及了很多复杂的概率统计学知识。所以我就摘自维基百科中的说明，如下:</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/%E8%B7%B3%E8%A1%A8-05-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png\" alt=\"跳表-05-的时间复杂度png\"></p>\n<p>如果看的不是很清晰，也可以这么想：</p>\n<p>如果每两个节点抽出一个节点作为上一级索引的节点，那第一级索引的节点个数大约就是  <code>n/2</code>  , 第二级索引是  <code>n/4</code> , 第三级就是  <code>n/8</code> 。 也就是说 第  <code>k</code>  级索引节点个数是  <code>n/(2^k)</code> ;</p>\n<p>假设，我们有  <code>h</code>  层，最高层索引有 <code>2</code>  个节点，那么， 就是  <code>n/(2^k)=2</code> , 那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">k=log_2N-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，这个链表的高度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">log_2N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. 如果每一层要遍历  <code>m</code>  个节点，那么在跳表中查询一个数据的时间复杂度就是 <code>O(m*logN)</code> .</p>\n<p>由于随机分布的存在，我们可以把 m 当做一个常数，所以，时间复杂度大致可以认为是  <code>O(logN)</code></p>\n<h3 id=\"空间复杂度的分析\"><a class=\"markdownIt-Anchor\" href=\"#空间复杂度的分析\">#</a> 空间复杂度的分析</h3>\n<p>根据整体代码实现来看，我们使用了链表的形式来实现。其中， <code>next</code>  改成了数组用来存储下一节点的指针，并没有真正的存储对象，. 也就是说，其实我们并没有使用很多的内存，当然，比一般的链表还是要多一些的。对于我们存储的对象来讲，用于存储指针的内存直接就可以忽略了。时间复杂度为  <code>O(N+m)</code> , 其中  <code>N&gt;&gt;m</code> ( <code>N</code>  远远大于 <code>m</code> ).</p>\n<h3 id=\"比较\"><a class=\"markdownIt-Anchor\" href=\"#比较\">#</a> 比较</h3>\n<h4 id=\"跳表-与平衡树-哈希表的比较\"><a class=\"markdownIt-Anchor\" href=\"#跳表-与平衡树-哈希表的比较\">#</a> 跳表 与平衡树、哈希表的比较</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">跳表</th>\n<th style=\"text-align:center\">平衡树</th>\n<th style=\"text-align:center\">哈希表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">有序性</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">有序</td>\n<td style=\"text-align:center\">无序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">查找性能</td>\n<td style=\"text-align:center\">O(logN)</td>\n<td style=\"text-align:center\">O(logN)</td>\n<td style=\"text-align:center\">O(N)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">实现逻辑</td>\n<td style=\"text-align:center\">简单</td>\n<td style=\"text-align:center\">复杂</td>\n<td style=\"text-align:center\">简单</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">是否支持范围查找</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">不支持 (无序)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">时间复杂度</td>\n<td style=\"text-align:center\">较少，取决 p 参数</td>\n<td style=\"text-align:center\">较大 (和跳表比，占用左右子树的两个指针)</td>\n<td style=\"text-align:center\">一般</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"解释如下\"><a class=\"markdownIt-Anchor\" href=\"#解释如下\">#</a> 解释如下:</h4>\n<ul>\n<li>在做范围查找的时候，平衡树比跳表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 <code>1</code>  层链表进行若干步的遍历就可以实现。</li>\n<li>平衡树的增删操作可能引发子树的平衡调整，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>\n<li>从内存占用上来说，跳表比平衡树更灵活一些。一般来说，平衡树每个节点包含 <code>2</code>  个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 <code>1/(1-p)</code> ，具体取决于参数 <code>p</code>  的大小。如果像 <code>Redis</code>  里的实现一样，取 <code>p=1/4</code> ，那么平均每个节点包含 <code>1.33</code>  个指针，比平衡树更有优势。</li>\n<li>查找单个 <code>key</code> ，跳表和平衡树的时间复杂度都为 <code>O(log n)</code> ，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 <code>O(1)</code> ，性能更高一些。</li>\n</ul>\n<p>我还从网上看到了 <code>Redis</code>  的作者选择 跳表做为 <code>zset</code>  底层数据结构的原因，贴在下面。</p>\n<h4 id=\"redis中作者选择skiplist的原因\"><a class=\"markdownIt-Anchor\" href=\"#redis中作者选择skiplist的原因\">#</a>  <code>Redis</code>  中作者选择 SkipList 的原因:</h4>\n<blockquote>\n<p>There are a few reasons:</p>\n<ol>\n<li>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</li>\n<li>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</li>\n<li>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</li>\n</ol>\n</blockquote>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>简单的从性能角度分析了数组和链表在性能方面的障碍，引出了我们今天的主角： 跳表。</li>\n<li>画了一个可能出现的跳表结构。这是与跳表的初次见面。并介绍了二分查找的变相应用。当前，这都是基于有序链表为前提的。</li>\n<li>介绍了链表的层的概念，这是跳表相对于链表最重要且唯一的概念，有了它才有了时间复杂度为 <code>O(logN)</code>  的查询效率，从而实现了增删操作的时间复杂度也是 <code>O(logN)</code> 。</li>\n<li>接下来，我们一起完成了跳表的实现逻辑。并且提供了多种语言的跳表实现版本。希望你也提交代码到仓库中，大家一起交流，期待。</li>\n<li>跳表在发展的过程中也出现几个变种，我们的这个只是一个最简答的实现。甚至我们都没有考虑过元素个数与层数的最优解等等问题。后面会有一篇文章分享的是 <code>Redis</code>  中 <code>skiplist</code>  的实现。敬请期待吧～</li>\n</ul>\n<h2 id=\"推荐\"><a class=\"markdownIt-Anchor\" href=\"#推荐\">#</a> 推荐</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0yZzlPU1JLSnV6TQ==\">某高校跳表公开课 (需科学上网)</span></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "数据结构",
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-7-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BHyperLogLogs/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-7-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BHyperLogLogs/",
            "title": "Redis数据结构之 `HyperLogLogs`",
            "date_published": "2021-08-01T10:58:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>上一篇我们学习的  <code>bitmap</code>  这一 <code>“数据类型”</code> 。其内部是由 <code>sds</code>  这种种数据结构编码的。<br>\n如果不记得了，那就来坐穿梭机回去看看吧。 <a href=\"./010-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BD%8D%E5%9B%BEbitmap.md\">开始穿梭</a></p>\n<p>接下来，我们继续学习一个新的 <code>&quot;数据类型&quot;</code> , 位图， <code>HyperLogLogs</code> .（注意啦，数据类型，我又加了引号！！）</p>\n<h2 id=\"hyperloglogs简介\"><a class=\"markdownIt-Anchor\" href=\"#hyperloglogs简介\">#</a>  <code>HyperLogLogs</code>  简介</h2>\n<p><code>HyperLogLog</code>  是一种<b>概率数据结构</b>，用于对唯一事物进行计数（从技术上讲，这是指估计集合的基数）。</p>\n<p>注意哦，  <code>HyperlogLog</code>  其实是一种基数计数算法，并非 <code>Redis</code>  独有的。</p>\n<p>通常，对唯一项目进行计数需要使用与要计数的项目数量成比例的内存量，因为您需要记住过去已经看到的元素，以避免多次对其进行计数。但是，有一组算法会以内存换取精度：以 <code>Redis</code>  实施为例，您得出的带有标准误差的估计度量最终会小于 <code>1％</code> 。</p>\n<p>该算法的神奇之处在于，您不再需要使用与所计数项目数量成比例的内存量，而可以使用恒定数量的内存！在最坏的情况下为 <code>12k</code>  字节，如果您的 <code>HyperLogLogs</code>  看到的元素很少，而且少得多。</p>\n<p><code>Redis</code>  中的 <code>HyperLogLog</code>  尽管在技术上是不同的数据结构，但被编码为 <code>Redis字符串</code>  ( <code>sds</code> )，因此您可以调用 <code>GET</code>  来序列化 <code>HyperLogLogs</code> ，然后调用 <code>SET</code>  来将其反序列化回服务器。这里我们在文末会大体翻一下源码。</p>\n<p>接下来我们先看一下 HyperLogLog 有什么应用场景。</p>\n<h3 id=\"hyperloglog-的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#hyperloglog-的应用场景\">#</a>  <code>HyperLogLog</code>  的应用场景</h3>\n<p>根据 <code>HyperLogLog</code>  的特性来看，使用了一种概率性计数的功能，这样的功能有一个特点就是当数据特别大的时候，其统计的值是不准确的。什么意思呢？</p>\n<p>就是比如统计一个网站的 <code>PV</code> ， <code>PV</code>  数值是  <code>123456789</code>  或者  <code>123456000</code>  这两者的值对于管理者来讲是一样的。对于一些<b>对精度要求不准确而且数据量很大</b>的场景是非常适合的。</p>\n<p>比如以下场景：计算网站的 PV，UV，统计日活，月活，统计用户每天搜索的词条数等等。</p>\n<h3 id=\"hyperloglog-的常用命令\"><a class=\"markdownIt-Anchor\" href=\"#hyperloglog-的常用命令\">#</a>  <code>HyperLogLog</code>  的常用命令</h3>\n<p><code>HyperLogLog</code>  应该是 <code>Redis</code>  所有结构中命令最少的了，只有三个命令。</p>\n<ul>\n<li><code>PFADD key element [element ...]</code></li>\n</ul>\n<p>添加元素。<br>\n如果一个 <code>HyperLogLog</code>  的估计的近似基数在执行命令过程中发了变化，  <code>PFADD</code>  返回 <code>1</code> ，否则返回 <code>0</code> ，如果指定的 <code>key</code>  不存在，这个命令会自动创建一个空的 <code>HyperLogLog</code>  结构（指定长度和编码的字符串）.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; pfadd k96 v1 v2 v3</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfadd k96 v4</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfadd k96 v1</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfadd k96 v2 v3 v4</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; </span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>PFCOUNT key [key ...]</code></li>\n</ul>\n<p>当参数为一个 <code>key</code>  时，返回存储在 <code>HyperLogLog</code>  结构体的该变量的近似基数，如果该变量不存在，则返回 <code>0</code> .</p>\n<p>当参数为多个 <code>key</code>  时，返回这些 <code>HyperLogLog</code>  并集的近似基数，这个值是将所给定的所有 <code>key</code>  的 <code>HyperLoglog</code>  结构合并到一个临时的 <code>HyperLogLog</code>  结构中计算而得到的.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; pfadd k97 v1 v2 v3 v4</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; PFCOUNT k97</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"comment\"># 测试多个key</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; PFCOUNT k97 k96</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; PFADD k97 v5 v6</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; PFCOUNT k97 k96</span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>刚才说了， <code>HyperLogLog</code>  只是存储总数的一种结构，而且其值也会和实际值有偏差。我们一起来验证一下这个结果</p>\n<p>我们往 <code>Redis</code>  中插入 <code>10000</code>  条数据，查看其  <code>pfcount</code>  的值是多少。</p>\n<p>使用下面这个脚本去插入 ( <code>java</code>  实现)。公众号回复  <code>RedisClient</code>  可以获取完整源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String host = <span class=\"string\">&quot;10.1.14.159&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> port = <span class=\"number\">6379</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">SocketRedisClient client = <span class=\"keyword\">new</span> SocketRedisClient(host, port);</span><br><span class=\"line\">String authCmd = client.exec(<span class=\"string\">&quot;auth moyang&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;登录验证结果:&quot;</span> + authCmd);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;删除已经存在的key :&quot;</span> + client.exec(<span class=\"string\">&quot;del k97&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">    String cmd = <span class=\"string\">&quot;pfadd k97 &quot;</span> + i;</span><br><span class=\"line\">    client.exec(cmd);</span><br><span class=\"line\"></span><br><span class=\"line\">    String cmd2 = <span class=\"string\">&quot;pfcount k97 &quot;</span>;</span><br><span class=\"line\">    String exec = client.exec(cmd2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行命令:&quot;</span> + cmd + <span class=\"string\">&quot; 返回结果:&quot;</span> + exec); <span class=\"comment\">// 返回的结果是未解析Redis协议的。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">client.releases();</span><br></pre></td></tr></table></figure>\n<p>插入完成之后，如下图，我们可以看到  <code>pfCount</code>  的结果是  <code>9988</code> .</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/pf-%E6%89%A7%E8%A1%8C10000%E6%AC%A1%E6%8F%92%E5%85%A5%E7%BB%93%E6%9E%9C.png\" alt=\"\"></p>\n<p>如果不相信我们可以 在 <code>shell</code>  里看看。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; pfcount k97</span><br><span class=\"line\">(integer) <span class=\"number\">9988</span></span><br></pre></td></tr></table></figure>\n<p>我这次测试正好相等，其实由于脚本的问题呢，从程序里获取的值和 <code>shell</code>  里获取的值，可能不一样，这种怎么解决呢？ 使用脚本单独再执行一次，就会一样了。具体原因，不赘述了。</p>\n<p>好了，我们插入了 <code>10000</code>  次，但是得出的值却是  <code>9988</code> ， 这也就验证了其不精确性。</p>\n<ul>\n<li><code>PFMERGE destkey sourcekey [sourcekey ...]</code></li>\n</ul>\n<p>将多个  <code>HyperLogLog</code>  合并（ <code>merge</code> ）为一个  <code>HyperLogLog</code>  ， 合并后的  <code>HyperLogLog</code>  的基数接近于所有输入  <code>HyperLogLog</code>  的可见集合（ <code>observed set</code> ）的并集.</p>\n<p>合并得出的  <code>HyperLogLog</code>  会被储存在目标变量（第一个参数）里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的  <code>HyperLogLog</code> .</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; pfadd k98 v1 v2 v3</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfadd k98_1 v2 v3 v4</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfadd k98_2 v3 v4 v5</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfmerge k98 k98_1 k98_2</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfcount k98</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfcount k98_1</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; pfcount k98_2</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>以上就是  <code>HyperLogLog</code>  的命令，老规矩我们下一步来看看  <code>HyperLogLog</code>  在 Redis 中是怎么实现的。</p>\n<h3 id=\"hyperloglog的结构\"><a class=\"markdownIt-Anchor\" href=\"#hyperloglog的结构\">#</a>  <code>HyperLogLog</code>  的结构</h3>\n<p>在  <code>Clion</code>  中直接查找 <code>hyperloglog</code>  ，就是  <code>hyperloglog</code>  的实现了。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/hyperloglog-%E6%9F%A5%E6%89%BE%E7%9B%AE%E5%BD%95.png\" alt=\"hyperloglog-查找目录.png\"></p>\n<p>我们可以看到有一个  <code>struct</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hllhdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> magic[<span class=\"number\">4</span>];      <span class=\"comment\">/* 魔数: &quot;HYLL&quot; */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> encoding;   <span class=\"comment\">/* HLL_DENSE或HLL_SPARSE */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> notused[<span class=\"number\">3</span>]; <span class=\"comment\">/* 保留以供将来使用，必须为零。 */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> card[<span class=\"number\">8</span>];    <span class=\"comment\">/* 缓存基数，小端。 */</span></span><br><span class=\"line\">    <span class=\"keyword\">uint8_t</span> registers[]; <span class=\"comment\">/* 数据字节。 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个就是  <code>HyperLogLog</code>  的存储结构了。这里大家大体有个印象就可以了。HyperLogLog 是一种基数估算算法的实现。后面我们会介绍这种<b>基数估算法</b>。</p>\n<h2 id=\"预告\"><a class=\"markdownIt-Anchor\" href=\"#预告\">#</a> 预告</h2>\n<p>最后一个 数据类型  <code>geohash</code>  (多维空间点索引算法)！！！</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/qrcode.jpg\" alt=\"微信二维码\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-6-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E4%BD%8D%E5%9B%BEbitmap/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-6-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E4%BD%8D%E5%9B%BEbitmap/",
            "title": "Redis数据结构之位图 BitMap",
            "date_published": "2021-08-01T10:48:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>上一篇我们学习的  <code>zset</code>  集合这一数据类型。其内部是由 <code>skiplist</code>  和 <code>hashtable</code>  这种两种数据结构编码的。<br>\n如果不记得了，那就来坐穿梭机回去看看吧。 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-5-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset/\">开始穿梭</a></p>\n<p>接下来，我们继续学习一个新的 <code>&quot;数据类型&quot;</code> , 位图， <code>bitmap</code> .（注意啦，数据类型，我加了引号！！）</p>\n<h2 id=\"bitmap简介\"><a class=\"markdownIt-Anchor\" href=\"#bitmap简介\">#</a>  <code>bitmap</code>  简介</h2>\n<p>那么什么是 <code>bitmap</code> , 我们先从名字上来说， <code>bit</code> ，计算机中最小的单位，一个 <code>bit</code>  表示一个二进制位。 <code>map</code> ，映射，图。所以， <code>bitmap</code>  就是表示对二进制位的映射。那具体是怎么回事呢？ <code>bitmap</code>  其实就是以字符串的形式对二进制位进行操作，从而达到节约空间占用的作用。</p>\n<p>而且， <code>bitmap</code> ，中文的意思就是位图。 不知道你用没用过 <code>C</code>  语言的位图结构，他们的目的都是一样。</p>\n<p>可能你还是不理解，别急，往下看。</p>\n<p><code>bitmap</code>  怎么用呢？</p>\n<p>恰巧，前几天小编在面试中被问到过这个问题。</p>\n<p>面试官说： <b>有个业务场景：我们这边有 10000 家线下门店，我们要对部分门店进行广告投放，怎么记录某条广告投放给哪家门店里了呢？我们的门店 <code>id</code>  是递增的。</b></p>\n<p>首先我们可以有三张表，广告表 ( <code>G</code>  表)，门店表（ <code>M</code>  表），广告门店关联表（ <code>GM</code>  表）。</p>\n<p>如果我们投放广告的时候，把每条广告和每个门店的关联作为一条数据插入到 <code>GM</code>  表中，那么这个表中的数据量增长还是非常快的。如果有 <code>10</code>  万家门店呢？广告的投放和撤销比较频繁。也就是说数据的修改也是比较频繁的。那怎么搞呢？</p>\n<p>门店的 <code>id</code>  是递增的，那么我们可以这么搞，用 <code>10001</code>  个二进制位表示 <code>10000</code>  家门店的 id，如果该门店投放了该广告，就把该位置上的数字置为 <code>1</code> 。并且每四个字节转换成一个整数型数，将（ <code>10000/8/4</code> ） <code>313</code>  个整形数按照一定的规则转换成字符串存储到 <code>GM</code>  表中。表示一条广告已经投放的门店。这样我们就使用了 <code>0.1kb</code>  左右的空间记录了某条广告投放门店的情况。</p>\n<p>其实呢，这就是使用 <code>bitmap</code>  进行存储的。</p>\n<p>接下来，我们看下如何使用 位图。</p>\n<h2 id=\"bitmap的基本命令\"><a class=\"markdownIt-Anchor\" href=\"#bitmap的基本命令\">#</a>  <code>bitmap</code>  的基本命令</h2>\n<ul>\n<li><code>SETBIT</code></li>\n</ul>\n<p><code>setbit key offset value</code></p>\n<p>对  <code>key</code>  所储存的字符串值，设置或清除指定偏移量上的位 ( <code>bit</code> )。<br>\n位的设置或清除取决于  <code>value</code>  参数，可以是  <code>0</code>  也可以是  <code>1</code>  。<br>\n当  <code>key</code>  不存在时，自动生成一个新的字符串值。<br>\n字符串会进行伸展 ( <code>grown</code> ) 以确保它可以将  <code>value</code>  保存在指定的偏移量上。当字符串值进行伸展时，空白位置以  <code>0</code>  填充。<br>\n <code>offset</code>  参数必须大于或等于  <code>0</code>  ，小于  <code>2^32</code>  ( <code>bit</code>  映射被限制在  <code>512 MB</code>  之内)。</p>\n<p>假设我们使用 位图来存储 <code>Redis</code>  这个字符串。</p>\n<p>在演示这个命令之前，我们首先来看下 如何使用二进制来表示字符串。</p>\n<p><code>Redis</code>  中的  <code>R</code>  对应  <code>ASCII</code>  码是:  <code>82</code> . 转化成二进制就是:  <code>0b01010010</code> , 其他字符依次如下所示：<br>\n <code>Redis</code>  中的  <code>e</code>  对应  <code>ASCII</code>  码是:  <code>101</code> . 转化成二进制就是:  <code>0b01100101</code> ，<br>\n <code>Redis</code>  中的  <code>d</code>  对应  <code>ASCII</code>  码是:  <code>100</code> . 转化成二进制就是:  <code>0b01100100</code> ，<br>\n <code>Redis</code>  中的  <code>i</code>  对应  <code>ASCII</code>  码是:  <code>105</code> . 转化成二进制就是:  <code>0b01101001</code> ，<br>\n <code>Redis</code>  中的  <code>s</code>  对应  <code>ASCII</code>  码是:  <code>115</code> . 转化成二进制就是:  <code>0b01110011</code> 。</p>\n<p>看到这里，我要告诉你一个知识点：对于位图的操作，我们可以实现 <b>  <code>零存整取</code>  </b>。 什么意思呢？</p>\n<p>我来给你演示一下</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/bitmap-R%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png\" alt=\"R对应的位图\"></p>\n<p>如上图， <code>R</code>  这个字符，对应的每个二进制上的数。由于位图会自动填充空位为 0，所以我们只需要设置二进制位上为 <code>1</code>  的就可以了。具体命令如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; setbit k87 1 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 3 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 6 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get k87</span><br><span class=\"line\">&quot;R&quot;</span><br></pre></td></tr></table></figure>\n<p>解释一下，我们根据  <code>R</code>  每个二进制位上数值设置到 k87 中，然后通过 <code>get k87</code>  这个命令，返回了  <code>R</code> 。 这就是所谓的  <code>零存整取</code> 。如果我继续设置剩下的  <code>edis</code>  字符串呢？</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/bitmap-Redis%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png\" alt=\"Redis完整的位图\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; setbit k87 9 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 10 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 13 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 15 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 17 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 18 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 21 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 25 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 26 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 28 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 31 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 33 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 34 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 35 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 38 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; setbit k87 39 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; get k87</span><br><span class=\"line\">&quot;Redis&quot;</span><br></pre></td></tr></table></figure>\n<p>这里你就可能说，有谁会这样使用，自己计算出每个位，然后去获取完整的？ 是啊，不过这里只是一个例子，来说明 位图  <code>零存整取</code>  功能，接下来，我们接着看 位图  <code>整存零取</code> 的功能。</p>\n<p>这里呢，就要介绍  <code>gitbit</code>  这个命令。</p>\n<ul>\n<li><code>GETBIT</code></li>\n</ul>\n<p><code>GETBIT key offset</code></p>\n<p>对  <code>key</code>  所储存的字符串值，获取指定 <code>offset</code>  上的位 ( <code>bit</code> ).</p>\n<p>如果 <code>key</code>  不存在，获取 <code>offset</code>  超出范围，返回 <code>0</code> .</p>\n<p>首先我们设置 一个  <code>string</code>  类型的字符串到 <code>Redis</code>  中，然后依次获取每一位上的值。</p>\n<p>可以和下图进行比对。</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/bitmap-Redis%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png\" alt=\"Redis完整的位图\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set k88 Redis</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 2</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 3</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 4</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 5</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 6</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 7</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 8</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 9</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ....</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 38</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 39</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 演示超出范围</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 40</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 41</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; getbit k88 42</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n<p>这个就是 位图提供的   <code>整存零取</code> 的功能了。综合上面的两项功能，我们轻而易举的就可以得出 Redis 的位图是可以  <code>零存零取</code> 的。就是使用  <code>setbit</code>  和  <code>gitbit</code>  命令了。这里就不演示了。</p>\n<ul>\n<li><code>BITCOUNT</code></li>\n</ul>\n<p><code>bitCount key [start] [end]</code></p>\n<p>计算指定 <code>key</code>  的对应字符串，被设置为 <code>1</code>  的比特位的数量。</p>\n<p>还是以上面的 <code>Redis</code>  为例，一共是 <code>19</code>  位 <code>1</code> . 我们来演示一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 不存在的时候，返回0</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; bitcount k89</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; set k89 Redis</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; bitcount k89 </span><br><span class=\"line\">(integer) 19</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意这里start end 都是表示字节。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; bitcount k89 0 1 </span><br><span class=\"line\">(integer) 7</span><br></pre></td></tr></table></figure>\n<p>这个适合什么场景下使用呢？ 比如，我们要计算某个用户登录天数。第一天登录的时候，我们 可以设置  <code>setbit user1 1 1</code> , 第二天设置  <code>setbit use1 2 1</code> , 那么使用  <code>bitcount user1</code>  就能知道该用户总共的登录天数了，也能够计算出该用户在哪天登录了。</p>\n<ul>\n<li><code>BITPOS</code></li>\n</ul>\n<p><code>bitpos key  bit [start] [end]</code></p>\n<p>返回 key 的指定区段内容，第一个 bit 的位置。</p>\n<p>比如我们以  <code>Redis</code>  为例，如下图</p>\n<p><img data-src=\"./images/bitmap-Redis%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png\" alt=\"\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set key90 Redis</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; bitops key90 1</span><br><span class=\"line\">(error) ERR unknown command `bitops`, with args beginning with: `key90`, `1`, </span><br><span class=\"line\">127.0.0.1:6379&gt; bitpos key90 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; bitpos key90 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这里的start和end也指的是字节</span></span><br><span class=\"line\">127.0.0.1:6379&gt; bitpos key90 0 2 10</span><br><span class=\"line\">(integer) 16</span><br><span class=\"line\">127.0.0.1:6379&gt; bitpos key90 1 2 10</span><br><span class=\"line\">(integer) 17</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>BITOP</code></li>\n</ul>\n<p><code>BITOP operation destkey key [key …]</code></p>\n<p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>\n<p><code>operation</code>  可以是  <code>AND</code>  、  <code>OR</code>  、  <code>NOT</code>  、  <code>XOR</code>  这四种操作中的任意一种：</p>\n<p><code>BITOP AND destkey key [key ...]</code>  ，对一个或多个  <code>key</code>  求逻辑并，并将结果保存到  <code>destkey</code>  。</p>\n<p><code>BITOP OR destkey key [key ...]</code>  ，对一个或多个  <code>key</code>  求逻辑或，并将结果保存到  <code>destkey</code>  。</p>\n<p><code>BITOP XOR destkey key [key ...]</code>  ，对一个或多个  <code>key</code>  求逻辑异或，并将结果保存到  <code>destkey</code>  。</p>\n<p><code>BITOP NOT destkey key</code>  ，对给定  <code>key</code>  求逻辑非，并将结果保存到  <code>destkey</code>  。</p>\n<p>除了  <code>NOT</code>  操作之外，其他操作都可以接受一个或多个  <code>key</code>  作为输入。</p>\n<p>这里我们做一个简单例子。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; setbit k91_1 <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_1 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_1 <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_1 <span class=\"number\">3</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_1 <span class=\"comment\"># 1111 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\xf0&quot;</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_2 <span class=\"number\">3</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_2 <span class=\"number\">4</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; setbit k91_2 <span class=\"number\">5</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_2 <span class=\"comment\"># 000111 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\x1c&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## and 操作</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitop AND k91_d_1 k91_1 k91_2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_d_1 <span class=\"comment\"># 000100 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\x10&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## OR 操作</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitop OR k91_d_2 k91_1 k91_2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_d_2 <span class=\"comment\"># 111111 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\xfc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## XOR 亦或操作</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitop XOR k91_d_3 k91_1 k92_2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_d_3 <span class=\"comment\"># 111011 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\xf0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## NOT 操作</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitop NOT k91_d_4 k91_1</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_d_4 <span class=\"comment\"># 00001111 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\x0f&quot;</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitop NOT k91_d_5 k91_2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k91_d_5 <span class=\"comment\"># 111011 (低位-&gt;高位)</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\xe3&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>BITFIELD</code></li>\n</ul>\n<p><code>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</code></p>\n<p><code>BITFIELD</code>  命令可以将一个  <code>Redis</code>  字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量  <code>1234</code>  上的  <code>5</code>  位长有符号整数进行设置”、 “获取偏移量  <code>4567</code>  上的  <code>31</code>  位长无符号整数” 等操作。 此外，  <code>BITFIELD</code>  命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。<br>\n这是一个比较复杂的命令了。我们依次来看看。</p>\n<ul>\n<li><code>GET type offset</code></li>\n</ul>\n<p><code>type</code>  是什么呢？  <code>type</code>  是返回的数值类型。可选值有： <code>i8</code> （有符号 <code>8</code>  个 <code>bit</code>  位）, <code>i16</code> （有符号 <code>16</code>  个 <code>bi</code> t 位）, <code>u8</code> （无符号 <code>8</code>  个 <code>bit</code>  位）, <code>u16</code> （无符号 <code>16</code>  个 <code>bit</code>  位）,…</p>\n<p>这个的命令的功能就是返回执行的二进制的范围，<b>offset 是指第几个二进制位</b>。<br>\n注意：<br>\n <code>BITFIELD</code>  命令最大支持 <code>64</code>  位长的有符号整数以及  <code>63</code>  位长的无符号整数， 其中无符号整数的  <code>63</code>  位长度限制是由于  <code>Redis</code>  协议目前还无法返回  <code>64</code>  位长的无符号整数而导致的。</p>\n<p>用下面这个例子来演示一下。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; set k92 Redis</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k92 get i8 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k92 get u8 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k92 get i16 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">21093</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k92 get u16 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">21093</span></span><br></pre></td></tr></table></figure>\n<p>结合上面的那张图，我们看下</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/bitmap-Redis%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png\" alt=\"Redis的bitmap图\"></p>\n<p>我们手动的将前 <code>8</code>  个 <code>bit</code>  位装换成 <code>10</code>  进制，就是 <code>82</code> 。高位为 <code>0</code> ，所以此时， <code>u8</code>  和 <code>i8</code>  的值是一样的。同样的  <code>u16</code> , <code>i16</code> , <code>u24</code> , <code>u48</code> , 大家可以自行验证一下。</p>\n<ul>\n<li><code>SET type offset value</code></li>\n</ul>\n<p>这个命令是和 <code>GET</code>  命令相反的一个命令。</p>\n<p>直接用一个例子来演示一下。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; bitfield k93 SET u8 <span class=\"number\">0</span> <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k93</span><br><span class=\"line\"><span class=\"string\">&quot;R&quot;</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k93 SET u8 <span class=\"number\">8</span> <span class=\"number\">101</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k93</span><br><span class=\"line\"><span class=\"string\">&quot;Re&quot;</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k93 SET u8 <span class=\"number\">16</span> <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k93</span><br><span class=\"line\"><span class=\"string\">&quot;Red&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># ... </span></span><br><span class=\"line\"><span class=\"comment\"># 剩下的i和s，大家自己试一下吧</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>INCRBY type offset increment</code></li>\n</ul>\n<p>从制定的偏移位开始，增加 <code>increment</code> 。</p>\n<p>什么意思呢？</p>\n<p>来演示一下:</p>\n<p>字符 <code>A</code>  的 <code>ASCII</code>  码是 <code>65</code> ， <code>R</code>  是 <code>82</code> ，如果从 <code>A</code>  变成 <code>R</code> ，需要增加 <code>17</code> 。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:<span class=\"number\">6379</span>&gt; set k94 A</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k94 INCRBY u8 <span class=\"number\">0</span> <span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k94</span><br><span class=\"line\"><span class=\"string\">&quot;R&quot;</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k94 INCRBY u8 <span class=\"number\">8</span> <span class=\"number\">101</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">101</span>get</span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; get k94</span><br><span class=\"line\"><span class=\"string\">&quot;Re&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>OVERFLOW WRAP|SAT|FAIL</code></li>\n</ul>\n<p>这是 <code>bitmap</code>  对  <code>INCRBY</code>  命令执行时，发生异常行为的控制。</p>\n<p>用户可以通过  <code>OVERFLOW</code>  命令以及以下展示的三个参数， 指定  <code>BITFIELD</code>  命令在执行自增或者自减操作时， 碰上向上溢出（ <code>overflow</code> ）或者向下溢出（ <code>underflow</code> ）情况时的行为：</p>\n<p><code>WRAP</code>  ： 使用回绕（ <code>wrap around</code> ）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是  <code>C</code>  语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为  <code>127</code>  的  <code>i8</code>  整数执行加一操作， 那么将得到结果  <code>-128</code>  。</p>\n<p><code>SAT</code>  ： 使用饱和计算（ <code>saturation arithmetic</code> ）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为  <code>120</code>  的  <code>i8</code>  整数执行加  <code>10</code>  计算， 那么命令的结果将为  <code>i8</code>  类型所能储存的最大整数值  <code>127</code>  。 与此相反， 如果一个针对  <code>i8</code>  值的计算造成了下溢， 那么这个 i8 值将被设置为  <code>-127</code>  。</p>\n<p><code>FAIL</code>  ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。</p>\n<p>我们演示一下这几种情况</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 WRAP 方式，重复执行相同的命令，在一个2bit上，从 0,1,2,3 来回折返。</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_1 OVERFLOW WRAP incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 SAT 方式，当要发生溢出的时候，不再执行。</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95_2 OVERFLOW SAT incrby u2 <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (integer) <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用FAIL模式，则返回(nil)，不执行且返回nil</span></span><br><span class=\"line\"><span class=\"number\">127.0</span>.0.1:<span class=\"number\">6379</span>&gt; bitfield k95 OVERFLOW FAIL incrby u2 <span class=\"number\">102</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) (nil)</span><br></pre></td></tr></table></figure>\n<p><code>BITFIELD</code>  命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域：  <code>BITFIELD</code>  能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。</p>\n<p>以上就是 <code>Redis</code>  中 <code>bitmap</code>  相关的命令了。下面我简单的来看下 bitmap 这种 <code>&quot;数据结构&quot;</code>  是如何实现的。</p>\n<p>注意，这里的数据结构我还是加上了引号。具体为什么呢？</p>\n<h3 id=\"bitmap-的实现\"><a class=\"markdownIt-Anchor\" href=\"#bitmap-的实现\">#</a>  <code>bitmap</code>  的实现</h3>\n<p>话不多说，我们直接去看看源码中是怎么实现的。直接搜文件  <code>bit</code></p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/bitmap-%E6%9F%A5%E6%89%BE%E7%9B%AE%E5%BD%95.png\" alt=\"bitmap-查找目录\"></p>\n<p>我们要看 <code>src</code>  目录下的，所以，直接看 <code>bitops.c</code></p>\n<p>这里我们就是以一个命令 <code>setbit</code>  为例简单的来看看 <code>bitmap</code>  的运行过程。</p>\n<figure class=\"highlight c\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SETBIT 命令的实现</span></span><br><span class=\"line\"><span class=\"comment\"> * @param c 客户端对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setbitCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *o; <span class=\"comment\">///  setbit key offset value 中的 key对应的Redis Object。</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *err = <span class=\"string\">&quot;bit is not an integer or out of range&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> bitoffset; <span class=\"comment\">/// 指定要修改的位的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> byte, bit;  <span class=\"comment\">/// byte: 要修改的位 所占的字节。第byte个字节上。 bit，在所占字节中的第bit位上。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> byteval, bitval; <span class=\"comment\">/// byteval: 要修改的位所占的字节的值。十进制数。  bitVal 是原来的指定bit上的值</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> on; <span class=\"comment\">/// 修改的值。就是 setbit key offset value 中的value。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 解析 offset 参数，是否符合规范(是否位负数，是否超过512M)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getBitOffsetFromArgument(c, c-&gt;argv[<span class=\"number\">2</span>], &amp;bitoffset, <span class=\"number\">0</span>, <span class=\"number\">0</span>) != C_OK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">/// 解析 value 参数 =&gt; 赋值给on变量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getLongFromObjectOrReply(c, c-&gt;argv[<span class=\"number\">3</span>], &amp;on, err) != C_OK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 验证on(value)只能是0或者1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (on &amp; ~<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        addReplyError(c, err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// 返回key对应的对象</span></span><br><span class=\"line\">    <span class=\"comment\">/// 该对象是一个OBJ_STRING类型</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((o = lookupStringForBitCommand(c, bitoffset)) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 获取当前位置上的值</span></span><br><span class=\"line\">    byte = bitoffset &gt;&gt; <span class=\"number\">3</span>; <span class=\"comment\">/// 计算出字节，确定offset所在的字节。</span></span><br><span class=\"line\">    byteval = ((<span class=\"keyword\">uint8_t</span> *) o-&gt;ptr)[byte]; <span class=\"comment\">/// 将指定字节上的数转换成无符号整型数。</span></span><br><span class=\"line\">    bit = <span class=\"number\">7</span> - (bitoffset &amp; <span class=\"number\">0x7</span>); <span class=\"comment\">/// 计算要修改的位，是当前字节中的第几位。</span></span><br><span class=\"line\">    bitval = byteval &amp; (<span class=\"number\">1</span> &lt;&lt; bit); <span class=\"comment\">/// 计算出修改后的值。(bitVal是修改后的整个字节上值)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Update byte with new bit value and return original value */</span></span><br><span class=\"line\">    <span class=\"comment\">/// 更新 String 的值为 bitVal，并且返回原来的值。</span></span><br><span class=\"line\">    byteval &amp;= ~(<span class=\"number\">1</span> &lt;&lt; bit); <span class=\"comment\">/// 将字节上原来的值，指定位上置为0.(即要赋值的位，bit为当前字节中的位。)</span></span><br><span class=\"line\">    byteval |= ((on &amp; <span class=\"number\">0x1</span>) &lt;&lt; bit); <span class=\"comment\">/// 将on的值复制给byteVal,取或运算，如果on为1，则1，若on为0，则0，上一行代码已经将指定位置置为了0.</span></span><br><span class=\"line\">    ((<span class=\"keyword\">uint8_t</span> *) o-&gt;ptr)[byte] = byteval; <span class=\"comment\">/// 修改对象中指定字节的值。</span></span><br><span class=\"line\">    signalModifiedKey(c-&gt;db, c-&gt;argv[<span class=\"number\">1</span>]); <span class=\"comment\">/// 通知修改了key。</span></span><br><span class=\"line\">    notifyKeyspaceEvent(NOTIFY_STRING, <span class=\"string\">&quot;setbit&quot;</span>, c-&gt;argv[<span class=\"number\">1</span>], c-&gt;db-&gt;id);</span><br><span class=\"line\">    server.dirty++; <span class=\"comment\">// 从上次保存到数据库的更改次数</span></span><br><span class=\"line\">    addReply(c, bitval ? shared.cone : shared.czero); <span class=\"comment\">/// 返回原来的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码就是  <code>setBit</code>  命令的实现过程了，这篇文章中我们不做研究<b>我们只看第 <code>27</code>  行</b>. 这一行中有一个  <code>lookupStringForBitCommand</code>  方法。在这里我们猜测一下，<b> <code>bitmap</code>  其实就是一个  <code>OBJ_STRING</code>  类型的结构</b>。</p>\n<p>到底是不是呢？</p>\n<p>看一下源码。</p>\n<figure class=\"highlight c\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是用于需要将位写入字符串对象的命令实现的辅助函数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则，如果密钥持有错误的类型，则返回NULL，并且*向客户端发送错误。</span></span><br><span class=\"line\"><span class=\"comment\"> * 该命令创建或填充字符串零，以便可以寻址“ maxbit”位。</span></span><br><span class=\"line\"><span class=\"comment\"> * 该对象最终返回。</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则，如果密钥持有错误的类型，则返回NULL并将错误发送给客户端。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">lookupStringForBitCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">size_t</span> maxbit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> byte = maxbit &gt;&gt; <span class=\"number\">3</span>; <span class=\"comment\">// 计算字节</span></span><br><span class=\"line\">    <span class=\"comment\">/// 为写操作找出一个key。 【setbit key offset value】中argv[1] 即为key</span></span><br><span class=\"line\">    robj *o = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// 是否找到了key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 没有找到。 创建一个对象写入。对象为OBJ_STRING类型。</span></span><br><span class=\"line\">        o = createObject(OBJ_STRING, sdsnewlen(<span class=\"literal\">NULL</span>, byte + <span class=\"number\">1</span>));</span><br><span class=\"line\">        dbAdd(c-&gt;db, c-&gt;argv[<span class=\"number\">1</span>], o);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 找到了key对象，如果不是 OBJ_STRING 类型直接返回。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checkType(c, o, OBJ_STRING)) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">/// 获取要修改的对象。上一行代码已经进行了判断，确定其为 OBJ_STRING 类型。</span></span><br><span class=\"line\">        o = dbUnshareStringValue(c-&gt;db, c-&gt;argv[<span class=\"number\">1</span>], o);</span><br><span class=\"line\">        <span class=\"comment\">/// 增加 STRING类型的长度</span></span><br><span class=\"line\">        o-&gt;ptr = sdsgrowzero(o-&gt;ptr, byte + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在第 <code>17</code>  行和第 <code>23</code>  行。就很清楚了。</p>\n<p>所以，在文章一开始加上引号的 数据结构 ，谜题就解开了。</p>\n<p><b> <code>bitmap</code>  并不是一个新的数据结构，本质上是用  <code>STRING</code>  这个数据结构来实现的。</b></p>\n<p>如果你想看 <code>bitmap</code>  的全部源码，那么满足你！！👉👉 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vZmFuZ2ppYXhpYW9iYWkvcmVkaXMuZ2l0\">点击这里</span>👈👈</p>\n<p><b>公众号里回复  <code>redis源码</code> ，即可获取完整路径哦</b></p>\n<p>虽然 redis 源码不是我写的，但是我看过的都加上注释啦～</p>\n<p>除此之外，小白还自己实现了一个  <code>bitmap</code> 。感兴趣的朋友欢迎  <code>star</code> .👉👉 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2NvZGVfcmVwby9ibG9iL21hc3Rlci8wMV9kYXRhX3N0cnVjdHVyZXMvYml0bWFwL2JpdG1hcC9CaXRNYXAuamF2YQ==\">bitMap 源码，点击这里</span> 👈👈</p>\n<p><b>公众号里回复  <code>bitmap</code> , 即可获取完整路径哦</b></p>\n<p>当然: JDK 也提供了一个 <code>BitMap</code>  的实现，叫 <code>BitSet</code> ，位于 <code>java.util</code>  包下。其底层使用的是一个 <code>long</code>  类型的数组，一个 <code>long</code>  代表一个 <code>word</code> 。但 <code>BitSet</code>  没有解决上面提到的输入稀疏的问题。谷歌开源的 <code>EWAHCompressedBitMap</code>  解决了输入稀疏的问题。</p>\n<p>这里我们总结一下。</p>\n<table>\n<thead>\n<tr>\n<th><code>Redis</code>  的数据类型</th>\n<th style=\"text-align:center\">底层实现结构</th>\n<th style=\"text-align:center\">文章参考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>STRING</code></td>\n<td style=\"text-align:center\"><code>sds</code></td>\n<td style=\"text-align:center\"><a href=\"https://mp.weixin.qq.com/s/0sGGSYe5zYNiLUrK5XTsWQ\">数据类型之 <code>String</code> </a></td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td style=\"text-align:center\"><code>quicklist</code> ,  <code>ziplist</code></td>\n<td style=\"text-align:center\"><a href=\"https://mp.weixin.qq.com/s/n9fzELpKXR1d02yn0usyvg\">数据类型之 <code>list</code> </a></td>\n</tr>\n<tr>\n<td><code>hash</code></td>\n<td style=\"text-align:center\"><code>ziplist</code> ,  <code>dict</code></td>\n<td style=\"text-align:center\"><a href=\"https://mp.weixin.qq.com/s/bQ-jnUuHKLC8-M4G8HpZ9w\">数据类型之 <code>hash</code> </a></td>\n</tr>\n<tr>\n<td><code>set</code></td>\n<td style=\"text-align:center\"><code>dict</code>  , <code>intset</code></td>\n<td style=\"text-align:center\"><a href=\"https://mp.weixin.qq.com/s/qK-CujsG43kAjGpgXYhQWg\">数据类型之 <code>set</code> </a></td>\n</tr>\n<tr>\n<td><code>zset</code></td>\n<td style=\"text-align:center\"><code>dict</code> ,  <code>skipList</code></td>\n<td style=\"text-align:center\"><a href=\"https://mp.weixin.qq.com/s/4fyT9XCLv2MYCtB1WH0Jvg\">数据类型之 <code>zset</code> </a></td>\n</tr>\n<tr>\n<td><code>bitmap</code></td>\n<td style=\"text-align:center\"><code>sds</code></td>\n<td style=\"text-align:center\"><a href=\"#\">数据类型之 <code>bitmap</code> </a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/qrcode.jpg\" alt=\"微信二维码\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-5-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-5-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset/",
            "title": "Redis数据结构之有序集合 zset",
            "date_published": "2021-08-01T10:38:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>上一篇我们学习的  <code>set</code>  集合这一数据类型。其内部是由 <code>inset</code>  和 <code>hashtable</code>  这种两种数据结构编码的。<br>\n如果不记得了，那就来坐穿梭机回去看看吧。 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set/\">开始穿梭</a></p>\n<p>接下来，我们继续学习一个新的数据类型，有序集合.  <code>zset</code> .</p>\n<h2 id=\"zset简介\"><a class=\"markdownIt-Anchor\" href=\"#zset简介\">#</a>  <code>zset</code>  简介</h2>\n<p><code>zset</code>  , 中文名字叫 有序集合。序这个字，在 <code>Redis</code>  的实现是  <code>score</code>  字段。我们先不急这个字段，后面会介绍。</p>\n<p>在 <code>Redis</code>  中有序的数据类型，还有一个就是我们前面学习的  <code>list</code>  了。 它们还都可以获得某一定范围内的元素。</p>\n<p>而  <code>zset</code>  的优点是：  <code>list</code>  通过链表实现，在两端操作数据都很方便。但是操作中间的数据就比较慢了。  <code>zset</code>  是用  <code>hashtable</code>  和  <code>skiplist</code>  来实现的。即使是操作中间数据，速度也很快。时间复杂度为:  <code>O(logN)</code></p>\n<p><code>zset</code>  的缺点就是：就是比较耗费内存。</p>\n<h2 id=\"zset类型的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#zset类型的应用场景\">#</a>  <code>zset</code>  类型的应用场景</h2>\n<ul>\n<li>存储学生成绩快速做成绩排名功能。</li>\n<li>排行榜，比如：列出某用户当前的全球排名，比赛中胜场数排名。</li>\n<li>带权重的消息队列功能</li>\n</ul>\n<h2 id=\"zset的基本命令\"><a class=\"markdownIt-Anchor\" href=\"#zset的基本命令\">#</a>  <code>zset</code>  的基本命令</h2>\n<h3 id=\"zadd\"><a class=\"markdownIt-Anchor\" href=\"#zadd\">#</a>  <code>zadd</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将 <code>member</code>  添加有序集合中.</p>\n<p>如果 <code>member</code>  存在，会更新 <code>member</code>  的 <code>score</code>  值。</p>\n<ul>\n<li>\n<p><code>NX</code>  表示存在相同的 <code>member</code>  就会设置失败，NX 的作用就是 新增 <code>member</code> ，不会修改 <code>Member</code></p>\n</li>\n<li>\n<p><code>XX</code>  表示不存在相同的 <code>member</code>  就会设置失败。所以:  <code>XX</code>  总是更新元素。不会新增元素</p>\n</li>\n<li>\n<p><code>CH</code> ( <code>change</code> ): 返回修改的元素个数。更改的元素是添加的新元素以及已为其更新分数的现有元素。因此，命令行中指定的具有与过去相同分数的元素将不计算在内。注意：通常， <code>ZADD</code>  的返回值仅计算添加的新元素的数量。</p>\n</li>\n<li>\n<p><code>INCR</code> : 指定此选项后， <code>ZADD</code>  的行为类似于<a href=\"#ZINCRBY\"> <code>ZINCRBY</code> </a>。在此模式下只能指定一对得分元素。</p>\n</li>\n<li>\n<p>演示</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 设置一个元素</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 1 m1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 设置多个元素</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 2 m2 3 m3 4 m4 5 m5</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 演示 NX 语义,只能新增.</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 NX 5 m5</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 NX 6 m6</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 NX 6 m6</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 演示 XX 语言,只能修改</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 XX 7 m7</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 7 m7</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 进行修改，注意返回值. 如果要返回个数，则加 CH</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 XX 7 m7</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 XX 77 m7</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 演示CH, 返回修改的个数</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 CH 8 m8 9 m9 10 m10</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 CH 8 m8 999 m9 10 m10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 演示INCR, 增长</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 11 m11</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 此时 score 表示的是步长</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k67 INCR 10 m11</span><br><span class=\"line\">&quot;21&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 查看设置的值。</span></span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k67 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) &quot;m1&quot;</span><br><span class=\"line\"> 2) &quot;1&quot;</span><br><span class=\"line\"> 3) &quot;m2&quot;</span><br><span class=\"line\"> 4) &quot;2&quot;</span><br><span class=\"line\"> 5) &quot;m3&quot;</span><br><span class=\"line\"> 6) &quot;3&quot;</span><br><span class=\"line\"> 7) &quot;m4&quot;</span><br><span class=\"line\"> 8) &quot;4&quot;</span><br><span class=\"line\"> 9) &quot;m5&quot;</span><br><span class=\"line\">10) &quot;5&quot;</span><br><span class=\"line\">11) &quot;m6&quot;</span><br><span class=\"line\">12) &quot;6&quot;</span><br><span class=\"line\">13) &quot;m8&quot;</span><br><span class=\"line\">14) &quot;8&quot;</span><br><span class=\"line\">15) &quot;m10&quot;</span><br><span class=\"line\">16) &quot;10&quot;</span><br><span class=\"line\">17) &quot;m11&quot;</span><br><span class=\"line\">18) &quot;21&quot;</span><br><span class=\"line\">19) &quot;m7&quot;</span><br><span class=\"line\">20) &quot;77&quot;</span><br><span class=\"line\">21) &quot;m9&quot;</span><br><span class=\"line\">22) &quot;999&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"zscore\"><a class=\"markdownIt-Anchor\" href=\"#zscore\">#</a>  <code>zscore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZSCORE key member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>zset score</code></p>\n<p>查看对应元素的 <code>score</code>  值</p>\n<pre><code>* 当`key`不存在或者`member`不存在的时候,返回`(nil)`\n</code></pre>\n<p>返回 <code>score</code>  的值。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 验证k68不存在的时候，返回nil</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZSCORE k68 m1</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k68 1 m1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 返回元素的score值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZSCORE k68 m1</span><br><span class=\"line\"><span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 验证 member 不存在的时候，返回</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZSCORE k68 m2</span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"zincrby\"><a class=\"markdownIt-Anchor\" href=\"#zincrby\">#</a>  <code>zincrby</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZINCRBY key increment member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>zset increment by</code> <br>\n*  <code>increment</code> : 步长。<br>\n*  <code>member</code> : 指定的成员</p>\n<p>为有序集合 <code>key</code>  的成员 <code>member</code>  的 <code>score</code>  值加上  <code>increment</code> 。</p>\n<p>如果 <code>key</code>  或者 <code>member</code>  不存在，则新增一个元素。相当于  <code>zadd</code> .</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 插入一个不存在的key。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZINCRBY k69 10 m1</span><br><span class=\"line\"><span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k69 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#累加</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZINCRBY k69 10 m1</span><br><span class=\"line\"><span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k69 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 累加一个负数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZINCRBY k69 -30 m1</span><br><span class=\"line\"><span class=\"string\">&quot;-10&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k69 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;-10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zcard\"><a class=\"markdownIt-Anchor\" href=\"#zcard\">#</a>  <code>zcard</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZCARD key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回 有序集合的 <code>key</code>  中的元素个数。即 <code>member</code>  的个数。<br>\n不存在的时候，返回 <code>0</code> .</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 返回member的个数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k70 1 m1 2 m2 3 m3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCARD k70</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k70 4 m4 5 m5</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCARD k70</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 不存在的时候，返回0</span></span><br><span class=\"line\">127.0.0.1:6379&gt; EXISTS k70_1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCARD k70_1</span><br><span class=\"line\">(integer) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"zcount\"><a class=\"markdownIt-Anchor\" href=\"#zcount\">#</a>  <code>zcount</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZCOUNT key min max</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回  <code>score</code>  值在 <code>min</code>  和  <code>max</code>  之间的元素的个数。包括等于  <code>min</code>  和  <code>max</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k71 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; ZCOUNT k71 2 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br><span class=\"line\"><span class=\"comment\">#不存在的key或者不在区间内时，返回0</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zcount k71_1 0 10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; zcount k71 11 12</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; zcount k71 12 11</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n<h3 id=\"zrange\"><a class=\"markdownIt-Anchor\" href=\"#zrange\">#</a>  <code>zrange</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZRANGE key start stop [WITHSCORES]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>这个命令我们已经用过，就是返回指定开始结束位置上的元素。从  <code>0</code>  开始。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k72 1 3</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k72 1 3 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zrevrange\"><a class=\"markdownIt-Anchor\" href=\"#zrevrange\">#</a>  <code>zrevrange</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREVRANGE key start stop [WITHSCORES]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回有序集合中指定区间的成员。<br>\n其中成员的位置按  <code>score</code>  值递减 (从大到小) 来排列。 具有相同  <code>score</code>  值的成员按字典序的逆序 ( <code>reverse lexicographical order</code> ) 排列。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k73 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 使用 zrange 正序返回数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k73 0 3 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">7) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 zrevrange 倒序返回数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANGE k73 0 3 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m10\\x11&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\">7) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zrangebyscore\"><a class=\"markdownIt-Anchor\" href=\"#zrangebyscore\">#</a>  <code>zrangebyscore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>zset range by score</code></p>\n<p>类似  <code>zrange</code> , 不过是按照  <code>score</code>  的值进行排序的。</p>\n<p><code>[LIMIT offset count]</code> , 是从 offset 开始，返回 <code>count</code>  个。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回 score值在 [9,10]之间的member。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k74 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE k74 9 10 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m10\\x11&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从第2个(区间内索引为1)开始，返回1个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYSCORE k74 9 10 WITHSCORES LIMIT 1 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m10\\x11&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zrevrangebyscore\"><a class=\"markdownIt-Anchor\" href=\"#zrevrangebyscore\">#</a>  <code>zrevrangebyscore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回有序集  <code>key</code>  中，  <code>score</code>  值介于  <code>max</code>  和  <code>min</code>  之间 (默认包括等于  <code>max</code>  或  <code>min</code>  ) 的所有的成员。有序集成员按  <code>score</code>  值递减 (从大到小) 的次序排列。</p>\n<p>注意各个参数的位置哦。这里和  <code>zrevrange</code>  的参数不一样。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k75 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANGEBYSCORE k75 8 6 WITHSCORES </span><br><span class=\"line\">1) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;7&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANGEBYSCORE k75 8 6 WITHSCORES  LIMIT 1  1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zrank\"><a class=\"markdownIt-Anchor\" href=\"#zrank\">#</a>  <code>zrank</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZRANK key member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回有序集  <code>key</code>  中成员  <code>member</code>  的排名。其中有序集成员按  <code>score</code>  值递增 (从小到大) 顺序排列</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k76 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank k76 m4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; zrank k76 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 9</span><br></pre></td></tr></table></figure>\n<h3 id=\"zrevrank\"><a class=\"markdownIt-Anchor\" href=\"#zrevrank\">#</a>  <code>zrevrank</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREVRANK key member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回有序集  <code>key</code>  中成员  <code>member</code>  的排名。其中有序集成员按  <code>score</code>  值递减 (从大到小) 排序。</p>\n<p>排名以  <code>0</code>  为底，也就是说，  <code>score</code>  值最大的成员排名为  <code>0</code>  。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k77 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANK k77 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; ZREVRANK k77 m4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br></pre></td></tr></table></figure>\n<h3 id=\"zrem\"><a class=\"markdownIt-Anchor\" href=\"#zrem\">#</a>  <code>zrem</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREM key member [member ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>zset remove</code></p>\n<p>移除有序集  <code>key</code>  中的一个或多个成员，不存在的成员将被忽略。</p>\n<p>当  <code>key</code>  存在但不是有序集类型时，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k78 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 删除m2,m3,m4</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREM k78 m2 m3 m4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k78 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;7&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">12) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">13) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">14) <span class=\"string\">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zremrangebyrank\"><a class=\"markdownIt-Anchor\" href=\"#zremrangebyrank\">#</a>  <code>zremrangebyrank</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREMRANGEBYRANK key start stop</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>移除有序集  <code>key</code>  中，指定排名 ( <code>rank</code> ) 区间内的所有成员。</p>\n<p>区间分别以下标参数  <code>start</code>  和  <code>stop</code>  指出，包含  <code>start</code>  和  <code>stop</code>  在内。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k79 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 删除排名第2到排名第4的member</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREMRANGEBYRANK k79 1 3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k79 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;7&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">12) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">13) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">14) <span class=\"string\">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zremrangebyscore\"><a class=\"markdownIt-Anchor\" href=\"#zremrangebyscore\">#</a> zremrangebyscore</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREMRANGEBYSCORE key min max</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>移除有序集  <code>key</code>  中，所有  <code>score</code>  值介于  <code>min</code>  和  <code>max</code>  之间 (包括等于  <code>min</code>  或  <code>max</code>  ) 的成员。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k80 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 删除 score&gt;=1 and score &lt;=9 的元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREMRANGEBYSCORE k80 1 9</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 9</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange k80 0 -1  WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zrangebylex\"><a class=\"markdownIt-Anchor\" href=\"#zrangebylex\">#</a> zrangebylex</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（ <code>lexicographical ordering</code> ）来进行排序， 而这个命令则可以返回给定的有序集合键  <code>key</code>  中， 值介于  <code>min</code>  和  <code>max</code>  之间的成员。</p>\n<p>注意:</p>\n<p>合法的  <code>min</code>  和  <code>max</code>  参数必须包含 ( 或者  <code>[</code>  ， 其中  <code>(</code>  表示开区间（指定的值不会被包含在范围之内）， 而  <code>[</code>  则表示闭区间（指定的值会被包含在范围之内）。</p>\n<p>特殊值  <code>+</code>  和  <code>-</code>  在  <code>min</code>  参数以及  <code>max</code>  参数中具有特殊的意义， 其中  <code>+</code>  表示正无限， 而  <code>-</code>  表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令  <code>ZRANGEBYLEX &lt;zset&gt; - + </code> ， 命令将返回有序集合中的所有元素</p>\n<blockquote>\n<p><code>lex</code> :<br>\n 表示如果 <code>score</code>  相等，则按照 <code>member</code>  的字典顺序排序。<br>\n此外这个命令，比如 <code>ZRANGBYSCORE</code>  稍微强大一点儿。可以指定区间范围，当只知道 <code>member</code> ，不知道 score 的时候，可以是使用带有  <code>lex</code>  的命令。</p>\n</blockquote>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd k81 1 a 2 b 3 c 4 d 5 f 6 g</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\"><span class=\"comment\"># 返回 score值在a的score值和c的score值之间的member</span></span><br><span class=\"line\"><span class=\"comment\"># 即: score&gt; Score(a) &amp;&amp; score &lt;= Score(c)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYLEX k81 (a  [c </span><br><span class=\"line\">1) <span class=\"string\">&quot;b&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;c&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回 小于等于c的Score值的元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYLEX k81 -  [c </span><br><span class=\"line\">1) <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;b&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;c&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回所有元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGEBYLEX k81 - + </span><br><span class=\"line\">1) <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;b&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;c&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;f&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;g&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zlexcount\"><a class=\"markdownIt-Anchor\" href=\"#zlexcount\">#</a>  <code>zlexcount</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZLEXCOUNT key min max</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>对于一个所有成员的分值都相同的有序集合键  <code>key</code>  来说， 这个命令会返回该集合中， 成员介于  <code>min</code>  和  <code>max</code>  范围内的元素数量。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd k82 1 a 2 b 3 c 4 d 5 f 6 g</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; ZLEXCOUNT k82 2 5</span><br><span class=\"line\">(error) ERR min or max not valid string range item</span><br><span class=\"line\">127.0.0.1:6379&gt; ZLEXCOUNT k82 a b</span><br><span class=\"line\"><span class=\"comment\"># 大于Score(a),小于等于Score(b)的member,只有b.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZLEXCOUNT k82 (a [b</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 大于Score(a),小于等于Score(d)的member,有b.c.d，三个</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZLEXCOUNT k82 (a [d</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"zremrangebylex\"><a class=\"markdownIt-Anchor\" href=\"#zremrangebylex\">#</a>  <code>zremrangebylex</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZREMRANGEBYLEX key min max</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>对于一个所有成员的分值都相同的有序集合键  <code>key</code>  来说， 这个命令会移除该集合中， 成员介于  <code>min</code>  和  <code>max</code>  范围内的所有元素。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd k83 1 a 2 b 3 c 4 d 5 f 6 g</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\"><span class=\"comment\"># 删除 score值在 (Score(a),Score(c)] 之间的member</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZREMRANGEBYLEX k83 (a [c</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 删除了，b,c</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zrange k83 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;f&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;g&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zscan\"><a class=\"markdownIt-Anchor\" href=\"#zscan\">#</a> zscan</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>这是一个查询命令。 同  <code>SCAN</code>  命令。可以参考这篇文章 <a href=\"./010-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4.md\">010 - 其他命令</a></p>\n<p><code>SCAN</code>  命令是一个基于游标的迭代器（ <code>cursor based iterator</code> ）：  <code>SCAN</code>  命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为  <code>SCAN</code>  命令的游标参数， 以此来延续之前的迭代过程。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k84 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; zscan k84 0 MATCH m* COUNT 3</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;7&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\">   17) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">   18) <span class=\"string\">&quot;9&quot;</span></span><br><span class=\"line\">   19) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">   20) <span class=\"string\">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zunionstore\"><a class=\"markdownIt-Anchor\" href=\"#zunionstore\">#</a>  <code>zunionstore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</code></p>\n<ul>\n<li>\n<p>解释<br>\n计算给定的一个或多个有序集合的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集 (结果集) 储存到 destination 。<br>\n如果 key 相同的时候，对应的 score 值会相加。</p>\n<ul>\n<li><code>WEIGHTS</code> : 使用  <code>WEIGHTS</code>  选项，你可以为 每个 给定有序集 分别 指定一个乘法因子 ( <code>multiplication factor</code> )，每个给定有序集的所有成员的  <code>score</code>  值在传递给聚合函数 ( <code>aggregation function</code> ) 之前都要先乘以该有序集的因子。</li>\n<li><code>AGGREGATE</code> : 使用  <code>AGGREGATE</code>  选项，你可以指定并集的结果集的聚合方式。<br>\n默认使用的参数  <code>SUM</code>  ，可以将所有集合中某个成员的  <code>score</code>  值之 和 作为结果集中该成员的  <code>score</code>  值；使用参数  <code>MIN</code>  ，可以将所有集合中某个成员的 最小  <code>score</code>  值作为结果集中该成员的  <code>score</code>  值；而参数  <code>MAX</code>  则是将所有集合中某个成员的 最大  <code>score</code>  值作为结果集中该成员的  <code>score</code>  值。</li>\n</ul>\n</li>\n<li>\n<p>演示</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; ZADD k85_1 1 m1 2 m2 3 m3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k85_2 1 m1 4 m4 5 m5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZUNIONSTORE k85 2 k85_1 k85_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; zrange k85 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 演示 Weights参数： WEIGHTS 2 3</span></span><br><span class=\"line\"><span class=\"comment\"># 指: 第一个zset的所有元素 *2 ，第二个有序集合中的元素 *3</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZUNIONSTORE k85 2 k85_1 k85_2 WEIGHTS 2 3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k85 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;12&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;15&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 演示 Weights参数： WEIGHTS 2 4</span></span><br><span class=\"line\"><span class=\"comment\"># 指: 第一个zset的所有元素 *2 ，第二个有序集合中的元素 *3</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZUNIONSTORE k85 2 k85_1 k85_2 WEIGHTS 2 4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k85 0 -1 WITHSCORES</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;4&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;16&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;20&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"zinterstore\"><a class=\"markdownIt-Anchor\" href=\"#zinterstore\">#</a> zinterstore</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>计算给定的一个或多个有序集的交集，其中给定  <code>key</code>  的数量必须以  <code>numkeys</code>  参数指定，并将该交集 (结果集) 储存到  <code>destination</code>  。</p>\n<p>默认情况下，结果集中某个成员的  <code>score</code>  值是所有给定集下该成员  <code>score</code>  值之和.</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd k86_1 1 m1 2 m2 3 m3 4 m4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; ZADD k86_2 20 m2 30 m3 50 m5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; ZINTERSTORE k86 2 k86_1 k86_2 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 取交集(默认相加)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; zrange k86 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;22&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;33&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># WEIGTHS 参数和上面的 ZUNIONSTORE命令一样.</span></span><br><span class=\"line\"><span class=\"comment\"># 这里演示一下, AGGREGATE参数</span></span><br><span class=\"line\"><span class=\"comment\"># 默认使用的是SUM. 就是本命令中上面的例子了.</span></span><br><span class=\"line\"><span class=\"comment\"># 下面演示MIN 和 MAX</span></span><br><span class=\"line\">127.0.0.1:6379&gt; ZINTERSTORE k86 2 k86_1 k86_2 AGGREGATE MIN</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k86 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; ZINTERSTORE k86 2 k86_1 k86_2 AGGREGATE MAX</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; ZRANGE k86 0 -1 WITHSCORES</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;30&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"zset的内部结构\"><a class=\"markdownIt-Anchor\" href=\"#zset的内部结构\">#</a>  <code>zset</code>  的内部结构</h2>\n<p>这里我们主要看 <code>skiplist</code> ，如果忘记了 <code>hashtable</code> ，就看着<a href=\"2021/08/01/Redis%E7%B3%BB%E5%88%97/C-8-Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E5%85%B8Dict/\">这篇文章</a></p>\n<p>我们从命令 <code>zadd</code>  入手，找到 <code>zset</code>  的 <code>add</code>  通用方法 <code>zaddGenericCommand(c,ZADD_NONE);</code>  来看一下。省略了部分代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (server.zset_max_ziplist_entries == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            server.zset_max_ziplist_value &lt; <span class=\"built_in\">sdslen</span>(c-&gt;argv[scoreidx+<span class=\"number\">1</span>]-&gt;ptr))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 创建 OBJ_ENCODING_SKIPLIST 编码的结构</span></span><br><span class=\"line\">    zobj = <span class=\"built_in\">createZsetObject</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 创建 OBJ_ZSET 编码的结构</span></span><br><span class=\"line\">    zobj = <span class=\"built_in\">createZsetZiplistObject</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>来看一下  <code>createZsetObject()</code>  方法的实现，就再清晰不过了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 创建 Zset 对象。</span></span><br><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">createZsetObject</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    zset *zs = <span class=\"built_in\">zmalloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(*zs));</span><br><span class=\"line\">    robj *o;</span><br><span class=\"line\"></span><br><span class=\"line\">    zs-&gt;dict = <span class=\"built_in\">dictCreate</span>(&amp;zsetDictType, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    zs-&gt;zsl = <span class=\"built_in\">zslCreate</span>();</span><br><span class=\"line\">    o = <span class=\"built_in\">createObject</span>(OBJ_ZSET, zs);</span><br><span class=\"line\">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，就是我们和  <code>zset</code>  这种数据类型的初次深入见面了。 我们先看下  <code>zset</code>  这种结构体的定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 有序集合的结构定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 字典，键为成员,值为score</span></span><br><span class=\"line\">    <span class=\"comment\">/// 用于支持 O(1) 复杂度的按成员分值操作。</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">/// 跳跃表,按分值排序成员</span></span><br><span class=\"line\">    <span class=\"comment\">/// 用于支持平均复杂度为 O(logN)的按分值定位成员以及范围的操作。</span></span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n<p><code>dict</code>  前面已经看过了，这里来看下 <code>zskiplist</code> 。</p>\n<h3 id=\"skiplist\"><a class=\"markdownIt-Anchor\" href=\"#skiplist\">#</a>  <code>skiplist</code></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 跳跃表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 表头，表尾</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"comment\">/// 表中层数最大的节点的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    sds ele;</span><br><span class=\"line\">    <span class=\"comment\">/// 分数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">/// 后退的指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 层</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">/// 前进指针</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"comment\">/// 跨度</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>本章是一个新的常用数据类型， <code>ZSET</code>  有序集合。底层的数据结构是使用的是  <code>skipList</code>  和  <code>hashtable</code>  . 关于 <code>Skiplist</code>  的初步了解文章<a href=\"#\">穿梭机</a> 和  <code>Redis</code>  中  <code>skiplist</code>  的实现源码解读<a href=\"\">穿梭机</a></li>\n<li>然后简单介绍了  <code>Redis ZSET</code>  数据类型的基础使用场景。关键字有  <code>有序</code> ， <code>排名</code> ， <code>权重</code> 等.</li>\n<li><code>ZSET</code>  的  <code>20</code>  个常有命令。 后面我会针对这  <code>20</code>  个命令的实现进行简单的分享.</li>\n<li>然后简单的看了一下 <code>Redis</code>  中的数据结构的实现，还是那句话， <code>Redis</code>  的数据结构是动态编码的，  <code>ZSET</code>  是有 <code>hashtable</code>  和  <code>skiplist</code>  实现的。 skiplist 是一个非常高效的数据结构，增删查的效率都是  <code>O(logN)</code> . 实现原理可以参考这篇文章<a href=\"#\">直通车</a>，里面有几种流行的语言的实现，可以针对自己擅长的语言进行查看。</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set/",
            "title": "Redis数据结构之集合 Set",
            "date_published": "2021-08-01T10:28:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>前一篇文章，我们学习的是 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/\">Redis 的数据结构之 hash</a>， 学习了其基本的操作和使用内部数据结构是 <code>hashtable</code>  和 <code>ziplist</code> ，其中 <code>Redis</code>  中的 <code>hashtable</code>  是用  <code>dict</code>  表示的。如果不记得了其内部构成，就再看看看着<a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/\">上篇文章</a>吧。现在我们继续学习下一个数据类型  <code>set</code> 。</p>\n<h2 id=\"set简介\"><a class=\"markdownIt-Anchor\" href=\"#set简介\">#</a>  <code>set</code>  简介</h2>\n<p><code>Redis</code>  的  <code>set</code>  数据类型表示 一堆不重复值的集合。</p>\n<p><code>Redis</code>  的 <code>set</code>  数据类型有两种编码方式.  <code>OBJ_ENCODING_INTSET</code>  和  <code>OBJ_ENCODING_HT</code> .</p>\n<ul>\n<li>\n<p><code>OBJ_ENCODING_HT</code>  这种编码方式在上一篇文章 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/\">07-Redis 的数据类型之 hash</a> 中已经简单的介绍过了。其实现的数据结构为  <code>dict</code> 。</p>\n</li>\n<li>\n<p><code>OBJ_ENCODING_INTSET</code> , 这种编码方式是我们要新学习的编码方式。 <a href=\"#intset\">电梯直达</a></p>\n</li>\n</ul>\n<p>如果你看到这句话，那就说明你是一个特别认真的人。哈哈哈，我们还是先遵循惯例。先学习 <code>set</code>  类型相关的命令。</p>\n<h2 id=\"set类型的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#set类型的应用场景\">#</a>  <code>set</code>  类型的应用场景</h2>\n<ul>\n<li>社交系统中存储关注信息，点赞信息，利用交并差运算，计算共同好友等业务中。比如 <code>qq</code>  的好友推荐逻辑，就可以使用差集运算。</li>\n<li>需要去重的业务逻辑中。某一时间端内系统的增长人数。</li>\n<li>统计访问网站的独立 <code>IP</code> 。</li>\n</ul>\n<h2 id=\"set的基本命令\"><a class=\"markdownIt-Anchor\" href=\"#set的基本命令\">#</a>  <code>set</code>  的基本命令</h2>\n<h3 id=\"sadd\"><a class=\"markdownIt-Anchor\" href=\"#sadd\">#</a>  <code>sadd</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SADD key member [member ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set add</code></p>\n<p>将一个或多个  <code>member</code>  元素加入到集合  <code>key</code>  当中，已经存在于集合的  <code>member</code>  元素将被忽略。</p>\n<p>假如  <code>key</code>  不存在，则创建一个只包含  <code>member</code>  元素作成员的集合。</p>\n<p>当  <code>key</code>  不是集合类型时，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd k52 mem1 mem2 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd k52 mem1 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd k52 mem1 mem3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"smembers\"><a class=\"markdownIt-Anchor\" href=\"#smembers\">#</a>  <code>smembers</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SMEMBERS key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set members</code></p>\n<p>返回集合  <code>key</code>  中的所有成员。</p>\n<p>不存在的  <code>key</code>  被视为空集合</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询元素， 注意保存是无序的.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k53 m1 m2 m3 m4 m5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k53</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sismember\"><a class=\"markdownIt-Anchor\" href=\"#sismember\">#</a>  <code>sismember</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SISMEMBER key member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set is members</code></p>\n<p>判断  <code>member</code>  元素是否集合  <code>key</code>  的成员。</p>\n<p>如果  <code>member</code>  元素是集合的成员，返回  <code>1</code>  。 如果  <code>member</code>  元素不是集合的成员，或  <code>key</code>  不存在，返回  <code>0</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k54 m1 m2 m3 m4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER k54 m2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SISMEMBER k54 m5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"spop\"><a class=\"markdownIt-Anchor\" href=\"#spop\">#</a>  <code>spop</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SPOP key [count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set pop</code></p>\n<p>移除并返回集合中的 <b>随机一个</b> 元素。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k55 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 随机移除一个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; spop k55</span><br><span class=\"line\"><span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; spop k55</span><br><span class=\"line\"><span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; spop k55</span><br><span class=\"line\"><span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 随机移除3个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; spop k55 3</span><br><span class=\"line\">1) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 查看所有元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k55</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"srandmemeber\"><a class=\"markdownIt-Anchor\" href=\"#srandmemeber\">#</a>  <code>srandmemeber</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SRANDMEMBER key [count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set rand member</code></p>\n<p>返回集合中的 随机  <code>count</code>  个元素 (不会删除元素)</p>\n<p>如果  <code>count</code>  为正数，且小于集合基数，那么命令返回一个包含  <code>count</code>  个元素的数组，数组中的元素各不相同。如果  <code>count</code>  大于等于集合基数，那么返回整个集合。</p>\n<p>如果  <code>count</code>  为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为  <code>count</code>  的绝对值。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k56 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 随机返回一个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 </span><br><span class=\"line\"><span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 </span><br><span class=\"line\"><span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 </span><br><span class=\"line\"><span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># count是正数，小于集合的元素数,返回count个元素，无重复元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 5</span><br><span class=\"line\">1) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># count是正数，大于集合的元素数,返回整个集合</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 20</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># count为负数， 返回20个集合中的元素，元素会重复</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SRANDMEMBER k56 -20</span><br><span class=\"line\"> 1) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 2) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 3) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\"> 4) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\"> 5) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 6) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"> 7) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\"> 8) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\"> 9) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">10) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">11) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">12) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">13) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">14) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">15) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">16) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">17) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">18) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">19) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">20) <span class=\"string\">&quot;m6&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"srem\"><a class=\"markdownIt-Anchor\" href=\"#srem\">#</a>  <code>srem</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SREM key member [member ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set remove</code></p>\n<p>移除集合  <code>key</code>  中的一个或多个  <code>member</code>  元素，不存在的  <code>member</code>  元素会被忽略。</p>\n<p>当  <code>key</code>  不是集合类型，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k57 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; SREM k57 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k57</span><br><span class=\"line\">1) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">7) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SREM k57 m11 m12</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"smove\"><a class=\"markdownIt-Anchor\" href=\"#smove\">#</a>  <code>smove</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SMOVE source destination member</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set move</code></p>\n<p>将  <code>member</code>  元素从  <code>source</code>  集合移动到  <code>destination</code>  集合。</p>\n<p><b> <code>SMOVE</code>  是原子性操作</b>。</p>\n<p>如果  <code>source</code>  集合不存在或不包含指定的  <code>member</code>  元素，则  <code>SMOVE</code>  命令不执行任何操作，仅返回  <code>0</code>  。否则，  <code>member</code>  元素从  <code>source</code>  集合中被移除，并添加到  <code>destination</code>  集合中去。</p>\n<p>当  <code>destination</code>  集合已经包含  <code>member</code>  元素时，  <code>SMOVE</code>  命令只是简单地将  <code>source</code>  集合中的  <code>member</code>  元素删除。</p>\n<p>当  <code>source</code>  或  <code>destination</code>  不是集合类型时，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k58 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 移动两个元素到k58_dis</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMOVE k58 k58_dis m1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SMOVE k58 k58_dis m2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SMOVE k58 k58_dis m1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># k58中的m1，m2 已被移除。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k58</span><br><span class=\"line\">1) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;m10&quot;</span></span><br><span class=\"line\">7) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">8) <span class=\"string\">&quot;m9&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># k58_dis中的m1,m2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k58_dis</span><br><span class=\"line\">1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m1&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"scard\"><a class=\"markdownIt-Anchor\" href=\"#scard\">#</a>  <code>scard</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SCARD key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回集合  <code>key</code>  的基数 (集合中元素的数量)。<br>\n集合的基数。 当  <code>key</code>  不存在时，返回  <code>0</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k59 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\"><span class=\"comment\"># 获取元素个数</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SCARD k59</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br></pre></td></tr></table></figure>\n<h3 id=\"sinter\"><a class=\"markdownIt-Anchor\" href=\"#sinter\">#</a>  <code>sinter</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code> SINTER key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set intersection</code>  :  <code>set</code>  的交集</p>\n<p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p>\n<p>不存在的  <code>key</code>  被视为空集。</p>\n<p>当给定集合当中有一个空集时，结果也为空集 (根据集合运算定律)。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k60_1 m1 m2 m3 m4 m5 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k60_2 m2 m3 m4 m5 m6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k60_3 m4 m5 m6 m7 m8</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 指定了一个key，返回集合的所有元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER k60_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 多个key的时候，返回集合的交集。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER k60_1 k60_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 多个key的时候，返回集合的交集。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER k60_1 k60_2 k60_3</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># k60_4不存在，为空集</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SINTER k60_1 k60_4</span><br><span class=\"line\">(empty list or <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"sinterstore\"><a class=\"markdownIt-Anchor\" href=\"#sinterstore\">#</a>  <code>sinterstore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SINTERSTORE destination key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set intersection and store</code></p>\n<p>这个命令类似于 SINTER key [key …] 命令，返回集合的交集。但它将结果保存到 destination 集合，而不是简单地返回结果集。</p>\n<p>如果 destination 集合已经存在，则将其覆盖。</p>\n<p>destination 可以是 key 本身。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k61_1 m1 m2 m3 m4 m5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k61_2 m4 m5 m6 m7 m8</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 将k61_1 和 k61_2 集合的交集存储到k61_dis中</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SINTERSTORE k61_dis k61_1 k61_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 查看 k61_dis</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k61_dis</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># k61_1 和 k61_2 没有变化</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k61_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k61_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;m7&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m8&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果目标集合(k61_dis)存在，元素会被覆盖掉。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k61_3 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SINTERSTORE k61_dis k61_1 k61_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k61_dis</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sunion\"><a class=\"markdownIt-Anchor\" href=\"#sunion\">#</a>  <code>sunion</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SUNION key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set union</code></p>\n<p>返回一个集合的全部成员，如果是多个集合 (key), 返回所有给定集合的并集。</p>\n<p>不存在的 key 被视为空集。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k62_1 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k62_2 m2 m3 m4 m5 m6 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 一个key，返回整个集合。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SUNION k62_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 多个key，返回并集</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SUNION k62_1 k62_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;m4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sunionstore\"><a class=\"markdownIt-Anchor\" href=\"#sunionstore\">#</a>  <code>sunionstore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SUNIONSTORE destination key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set union and store</code></p>\n<p>同 SINTERSTORE , 只不过存储的是并集的结果。 将多个集合的并集存储到 distination 中。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k63_1 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k63_2 m2 m3 m4 m5 m6 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SUNIONSTORE k63_dis k62_1 k62_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k63_dis</span><br><span class=\"line\">1) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;m4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sdiff\"><a class=\"markdownIt-Anchor\" href=\"#sdiff\">#</a>  <code>sdiff</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SDIFF key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set difference</code></p>\n<p>如果指定一个集合， <code>key</code> ，返回一个集合的全部成员，</p>\n<p>如果指定了多个集合 ( <code>key</code> ), 则返回 所有给定集合之间的差集。</p>\n<p>不存在的  <code>key</code>  被视为空集。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k64_1 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k64_2 m2 m3 m4 m5 m6 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\"><span class=\"comment\"># 返回 k64_1 - k64_2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFF k64_1 k64_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 返回 k64_2 - k64_1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFF k64_2 k64_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sdiffstore\"><a class=\"markdownIt-Anchor\" href=\"#sdiffstore\">#</a>  <code>sdiffstore</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SDIFFSTORE destination key [key ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将集合的差集存储到  <code>destination</code>  集合中.</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SADD k65_1 m1 m2 m3 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SADD k65_2 m2 m3 m4 m5 m6 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFFSTORE k65_dis_1 k65_1 k65_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k65_dis_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SDIFFSTORE k65_dis_2 k65_2 k65_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SMEMBERS k65_dis_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sscan\"><a class=\"markdownIt-Anchor\" href=\"#sscan\">#</a>  <code>sscan</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>set scan</code></p>\n<p>这是一个查询命令。 同  <code>SCAN</code>  命令。可以参考这篇文章 <a href=\"./010-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4.md\">010 - 其他命令</a></p>\n<p><code>SCAN</code>  命令是一个基于游标的迭代器（ <code>cursor based iterator</code> ）：  <code>SCAN</code>  命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为  <code>SCAN</code>  命令的游标参数， 以此来延续之前的迭代过程。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SSCAN k66 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SSCAN k66 0</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;m6&quot;</span></span><br><span class=\"line\">   2) <span class=\"string\">&quot;m1&quot;</span></span><br><span class=\"line\">   3) <span class=\"string\">&quot;m3&quot;</span></span><br><span class=\"line\">   4) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">   5) <span class=\"string\">&quot;m4&quot;</span></span><br><span class=\"line\">   6) <span class=\"string\">&quot;m5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; SSCAN k66 1 MATCH m2 Count 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2) 1) <span class=\"string\">&quot;m2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n<h2 id=\"set的内部结构\"><a class=\"markdownIt-Anchor\" href=\"#set的内部结构\">#</a>  <code>set</code>  的内部结构</h2>\n<p>在 t_set.c 这个文件中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">setTypeCreate</span><span class=\"params\">(sds value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isSdsRepresentableAsLongLong</span>(value,<span class=\"literal\">NULL</span>) == C_OK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">createIntsetObject</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">createSetObject</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表明， <code>set</code>  数据类型是由两种数据结构来实现的。</p>\n<p>而在  <code>createSetObject()</code> ，指明了其编码方式是  <code>OBJ_ENCODING_HT</code> , 即哈希表的方式，也就是使用 dict 这种数据结构来存储的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">createSetObject</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    dict *d = <span class=\"built_in\">dictCreate</span>(&amp;setDictType, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    robj *o = <span class=\"built_in\">createObject</span>(OBJ_SET, d);</span><br><span class=\"line\">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hashtable\"><a class=\"markdownIt-Anchor\" href=\"#hashtable\">#</a>  <code>hashtable</code></h3>\n<p>这里就不赘述了。直接上<a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/\">穿梭机</a>吧。</p>\n<h3 id=\"intset\"><a class=\"markdownIt-Anchor\" href=\"#intset\">#</a> intset</h3>\n<p>在 <code>createIntsetObject()</code>  中指明了使用的编码方式是  <code>OBJ_ENCODING_INTSET</code> . 如下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">createIntsetObject</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    intset *is = <span class=\"built_in\">intsetNew</span>();</span><br><span class=\"line\">    robj *o = <span class=\"built_in\">createObject</span>(OBJ_SET, is);</span><br><span class=\"line\">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看看  <code>intset</code>  到底什么何方利器.</p>\n<p>我直接全项目搜索:  <code>intset</code>  ，就找到了  <code>intset.h</code> .</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding; </span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字段解释\"><a class=\"markdownIt-Anchor\" href=\"#字段解释\">#</a> 字段解释:</h4>\n<ul>\n<li><code>encoding</code> : 数据编码，表示 <code>intset</code>  中的每个数据元素用几个字节来存储。它有三种可能的取值： <code>INTSET_ENC_INT16</code>  表示每个元素用 <code>2</code>  个字节存储， <code>INTSET_ENC_INT32</code>  表示每个元素用 <code>4</code>  个字节存储， <code>INTSET_ENC_INT64</code>  表示每个元素用 <code>8</code>  个字节存储。因此， <code>intset</code>  中存储的整数最多只能占用 <code>64bit</code> 。</li>\n<li><code>length</code> : 表示 <code>intset</code>  中的元素个数。 <code>encoding</code>  和 <code>length</code>  两个字段构成了 <code>intset</code>  的头部（ <code>header</code> ）。</li>\n<li><code>contents</code> : 是一个柔性数组（ <code>flexible array member</code> ），表示 <code>intset</code>  的 <code>header</code>  后面紧跟着数据元素。这个数组的总长度（即总字节数）等于 <code>encoding * length</code> 。柔性数组在 <code>Redis</code>  的很多数据结构的定义中都出现过（例如 <code>sds</code> ,  <code>quicklist</code> ,  <code>skiplist</code> ），用于表达一个偏移量。 <code>contents</code>  需要单独为其分配空间，这部分内存不包含在 <code>intset</code>  结构当中。</li>\n</ul>\n<p>这里有个问题.</p>\n<p>Redis 是如何决定一个 set 使用哪种编码方式的呢？</p>\n<p>set 的编码是由第一个元素决定的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">setTypeCreate</span><span class=\"params\">(sds value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isSdsRepresentableAsLongLong</span>(value,<span class=\"literal\">NULL</span>) == C_OK)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">createIntsetObject</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">createSetObject</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isSdsRepresentableAsLongLong</span><span class=\"params\">(sds s, <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> *llval)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">string2ll</span>(s, <span class=\"built_in\">sdslen</span>(s), llval) ? C_OK : C_ERR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果  <code>value</code>  可以转换成  <code>long long</code>  类型的话，就使用  <code>inset</code>  编码方式。</p>\n<p>通过看源码发现:</p>\n<p>当 <code>intset</code>  的元素个数超过  <code>set_max_intset_entries</code>  这个配置的时候，就会从 <code>intset</code>  编码 ( <code>OBJ_ENCODING_INTSET</code> ) 转换成  <code>ht</code>  编码 ( <code>OBJ_ENCODING_HT</code> )。</p>\n<p>这个我们会在后续文章中说明这里的方案。</p>\n<p>好了，关于 set 类型的介绍就到这里了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li><code>set</code>  这种类型是一种无重复元素的集合。</li>\n<li><code>set</code>  的业务场景关键字：去重，交并差运算。但是一定是无序的。如果要求有序的话，那就 <a href=\"./09-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset.md\">下一篇文章  zset</a> ~</li>\n<li><code>set</code>  的  <code>15</code>  个命令，务必熟记！！！</li>\n<li><code>set</code>  的内部编码方式。哈希表编码和 <code>intset</code>  编码。后面会有 关于  <code>intset</code>  数据结构的详细介绍的文章～</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/",
            "title": "Redis数据结构之 Hash",
            "date_published": "2021-08-01T07:18:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>前一篇文章，我们学习的是 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-2-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/\">Redis 的数据结构 list</a>， 学习了其基本的操作和使用内部数据结构是 <code>quicklist</code>  和 <code>ziplist</code> ，这两种数据结构虽然起得名字是 <code>list</code> ，但是其内部结构却是链表。如果不记得了其内部构成，就再看看看着<a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-2-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/\">上篇文章</a>吧。现在我们继续学习下一个数据类型  <code>hash</code></p>\n<h2 id=\"hash简介\"><a class=\"markdownIt-Anchor\" href=\"#hash简介\">#</a>  <code>hash</code>  简介</h2>\n<p><code>hash</code>  是一个键值对集合。是  <code>string</code>  类型的  <code>key</code>  和  <code>value</code>  的映射表，hash 特别适合用于存储对象，每个 <code>hash</code>  类型可以存储  <code>2^32-1</code>  个键值对。</p>\n<p><code>hash</code>  实际上就是一个 哈希表。类似于  <code>Java</code>  里的 <code>HashTable</code> 。</p>\n<p>但是  <code>Redis</code>  的哈希是有两种数据结构 (内部编码) 来表示的。</p>\n<ul>\n<li>\n<p>一种是  <code>ziplist</code>  , 上篇文章中我们简单的介绍了 <code>ziplist</code>  的内部构成，见 <a href=\"./06-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist.md\">Redis 的数据结构 list</a>, 以及 <code>ziplist</code>  的编码方式，可以看这篇文章 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/C-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bziplist/\">10-Redis 的数据结构之 ziplist.md</a>. 那么  <code>Redis</code>  什么时候会使用 <code>ziplist</code>  这种编码方式呢？</p>\n<ul>\n<li>当  <code>hash</code>  类型的元素的个数小于  <code>hash-max-ziplist-enties</code>  配置，默认 <code>512</code> .</li>\n<li>所有的值都小于 <code>hash-max-ziplist-value</code>  的值，默认是 <code>64</code>  个字节的时候。<br>\n当同时满足以上两个条件的时候， 就会使用  <code>ziplist</code>  这种结构。</li>\n</ul>\n</li>\n</ul>\n<p>这种方式最大的优点就是节约空间。</p>\n<ul>\n<li>另一种就是使用  <code>hashtable</code>  来编码了。当不满足上面提及的两个条件时，就会使用  <code>hashtable</code>  来编码。实际上是  <code>dict</code>  这种数据结构。这里我们又可以学习到一个新的数据结构  <code>dict</code></li>\n</ul>\n<h2 id=\"hash的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#hash的应用场景\">#</a> hash 的应用场景</h2>\n<ul>\n<li>缓存对象信息：对象的每个属性对应着 <code>hash</code>  的一个键值对。改变的时候，只需要改变对应的某个 <code>filed-value</code>  即可。</li>\n<li>缓存购物车的信息：用户的 <code>id</code>  为 <code>key</code> ， 商品的 <code>id</code>  为  <code>field</code> . 商品的数量为 <code>value</code> 。 比如:  <code>hset userId productId productCount</code></li>\n</ul>\n<h2 id=\"hash的基本命令\"><a class=\"markdownIt-Anchor\" href=\"#hash的基本命令\">#</a>  <code>hash</code>  的基本命令</h2>\n<h3 id=\"hset\"><a class=\"markdownIt-Anchor\" href=\"#hset\">#</a>  <code>hset</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>hset key field value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将哈希表  <code>hash</code>  中域  <code>field</code>  的值设置为  <code>value</code>  。</p>\n<p>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行  <code>HSET</code>  操作。</p>\n<p>如果域  <code>field</code>  已经存在于哈希表中， 那么它的旧值将被新值  <code>value</code>  覆盖。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 设置一个hash结构</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k38 f1 v38</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 获取一个字段</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HGET k38 f1</span><br><span class=\"line\"><span class=\"string\">&quot;v38&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 设置一个已经存在的值, 注意返回的值。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k38 f1 v38v38</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET k38 f1</span><br><span class=\"line\"><span class=\"string\">&quot;v38v38&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hsetnx\"><a class=\"markdownIt-Anchor\" href=\"#hsetnx\">#</a>  <code>hsetnx</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HSETNX key field value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>当且仅当域  <code>field</code>  尚未存在于哈希表的情况下， 将它的值设置为  <code>value</code>  。</p>\n<p>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</p>\n<p>如果哈希表  <code>hash</code>  不存在， 那么一个新的哈希表将被创建并执行  <code>HSETNX</code>  命令。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个不存在的 key</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX k39 f1 v39</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET k39 f1</span><br><span class=\"line\"><span class=\"string\">&quot;v39&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 再次设置</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSETNX k39 f1 v39v39</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; HGET k39 f1</span><br><span class=\"line\"><span class=\"string\">&quot;v39&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hget\"><a class=\"markdownIt-Anchor\" href=\"#hget\">#</a>  <code>hget</code></h3>\n<p>这个命令上面已经用到了。这里就不浪费时间了。</p>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HGET key field</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>获取对应的  <code>key</code>  下的域  <code>field</code>  的值。不存在的时候，返回  <code>nil</code></p>\n<h3 id=\"hgetall\"><a class=\"markdownIt-Anchor\" href=\"#hgetall\">#</a>  <code>hgetall</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HGETALL key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回哈希表  <code>key</code>  中，所有的域和值。</p>\n<p>在返回值里，紧跟每个域名 ( <code>field name</code> ) 之后是域的值 ( <code>value</code> )，所以返回值的长度是哈希表大小的两倍。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HGETALL k39 </span><br><span class=\"line\">1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v39&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset k39 f2 v39_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HGETALL k39 </span><br><span class=\"line\">1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v39&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v39_2&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hexists\"><a class=\"markdownIt-Anchor\" href=\"#hexists\">#</a>  <code>hexists</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code> HEXISTS key field</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>检查给定域  <code>field</code>  是否存在于哈希表  <code>hash</code>  当中。</p>\n<p>存在返回 <code>1</code> , 不存在返回 <code>0</code> 。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HEXISTS k40 f1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k40 f1 v40</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HEXISTS k40 f1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"del\"><a class=\"markdownIt-Anchor\" href=\"#del\">#</a>  <code>del</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HDEL key field [field ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HSET k41 f1 v41_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k41 f2 v41_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k41 f3 v41_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HGETALL k41</span><br><span class=\"line\">1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v41_1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v41_2&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;f3&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;v41_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HDEL k41 f1 f3 f4 </span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; HGETALL k41</span><br><span class=\"line\">1) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v41_2&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hlen\"><a class=\"markdownIt-Anchor\" href=\"#hlen\">#</a>  <code>hlen</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HLEN key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回哈希表  <code>key</code>  中域的数量。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HSET k42 f1 v42_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k42 f2 v42_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k42 f3 v42_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen k42</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"hstrlen\"><a class=\"markdownIt-Anchor\" href=\"#hstrlen\">#</a>  <code>hstrlen</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HSTRLEN key field</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回哈希表  <code>key</code>  中， 与给定域  <code>field</code>  相关联的值的字符串长度（ <code>string length</code> ）。</p>\n<p>如果给定的键或者域不存在， 那么命令返回  <code>0</code>  。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HSET k43 f1 <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HSTRLEN k43 f1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 11</span><br><span class=\"line\">127.0.0.1:6379&gt; HSTRLEN k43 f2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"hincrby\"><a class=\"markdownIt-Anchor\" href=\"#hincrby\">#</a> hincrby</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HINCRBY key field increment</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>为哈希表  <code>key</code>  中的域  <code>field</code>  的值加上增量  <code>increment</code>  。</p>\n<p>增量也可以为负数，相当于对给定域进行减法操作。</p>\n<p>如果  <code>key</code>  不存在，一个新的哈希表被创建并执行  <code>HINCRBY</code>  命令。</p>\n<p>如果域  <code>field</code>  不存在，那么在执行命令前，域的值被初始化为  <code>0</code>  。</p>\n<p>对一个储存字符串值的域  <code>field</code>  执行  <code>HINCRBY</code>  命令将造成一个错误。</p>\n<p>本操作的值被限制在  <code>64</code>  位 ( <code>bit</code> ) 有符号数字表示之内。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不存在的key与域 field</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY k45 f1 100</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 100</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY k45 f1 -200</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -100</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY k45 f1 200</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 100</span><br><span class=\"line\"><span class=\"comment\"># 错误的类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k45 f2 v45</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY k45 f2 100</span><br><span class=\"line\">(error) ERR <span class=\"built_in\">hash</span> value is not an <span class=\"built_in\">integer</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hincrbyfloat\"><a class=\"markdownIt-Anchor\" href=\"#hincrbyfloat\">#</a>  <code>hincrbyfloat</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HINCRBYFLOAT  key field increment</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>为哈希表  <code>key</code>  中的域  <code>field</code>  加上浮点数增量  <code>increment</code>  。</p>\n<p>如果哈希表中没有域  <code>field</code>  ，那么  <code>HINCRBYFLOAT</code>  会先将域  <code>field</code>  的值设为  <code>0</code>  ，然后再执行加法操作。</p>\n<p>如果键  <code>key</code>  不存在，那么  <code>HINCRBYFLOAT</code>  会先创建一个哈希表，再创建域  <code>field</code>  ，最后再执行加法操作。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HINCRBYFLOAT  k46 f1 100.5</span><br><span class=\"line\"><span class=\"string\">&quot;100.5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBYFLOAT  k46 f1 100.5</span><br><span class=\"line\"><span class=\"string\">&quot;201&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBYFLOAT  k46 f1 -100.5</span><br><span class=\"line\"><span class=\"string\">&quot;100.5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; HSET k46 f2 v46_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"hmset\"><a class=\"markdownIt-Anchor\" href=\"#hmset\">#</a>  <code>hmset</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HMSET key field value [field value ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>同时将多个  <code>field-value</code>  (域 - 值) 对设置到哈希表  <code>key</code>  中。</p>\n<p>此命令会覆盖哈希表中已存在的域。</p>\n<p>如果  <code>key</code>  不存在，一个空哈希表被创建并执行  <code>HMSET</code>  操作。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HMSET k47  f1 v47_1 f2 v47_2 f3 v47_3</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; HGETALL k47</span><br><span class=\"line\">1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v47_1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v47_2&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;f3&quot;</span></span><br><span class=\"line\">6) <span class=\"string\">&quot;v47_3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hmget\"><a class=\"markdownIt-Anchor\" href=\"#hmget\">#</a>  <code>hmget</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HMGET key field [field ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回哈希表  <code>key</code>  中，一个或多个给定域的值。</p>\n<p>如果给定的域不存在于哈希表，那么返回一个  <code>nil</code>  值。</p>\n<p>因为不存在的  <code>key</code>  被当作一个空哈希表来处理，所以对一个不存在的  <code>key</code>  进行  <code>HMGET</code>  操作将返回一个只带有  <code>nil</code>  值的表。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HMSET k48 f1 v1 f2 v2 f3 v3 f4 v4</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; hmget k48 f1 f3 f4</span><br><span class=\"line\">1) <span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v4&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n<h3 id=\"hkeys\"><a class=\"markdownIt-Anchor\" href=\"#hkeys\">#</a>  <code>hkeys</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HKEYS key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回哈希表  <code>key</code>  中的所有域。</p>\n<p>当  <code>key</code>  不存在时，返回一个空表。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HMSET k49 f1 v1 f2 v2 f3 v3 f4 v4</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; HKEYS k49</span><br><span class=\"line\">1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;f3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;f4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hvals\"><a class=\"markdownIt-Anchor\" href=\"#hvals\">#</a>  <code>hvals</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HVALS key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回  <code>key</code>  对应的所有的 <code>value</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HMSET k50 f1 v1 f2 v2 f3 v3 f4 v4 </span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; HVALS k50</span><br><span class=\"line\">1) <span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v4&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"hscan\"><a class=\"markdownIt-Anchor\" href=\"#hscan\">#</a>  <code>hscan</code></h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>这是一个查询命令。 同 SCAN 命令。可以参考这篇文章 <a href=\"./010-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4.md\">010 - 其他命令</a></p>\n<p><code>SCAN</code>  命令是一个基于游标的迭代器（ <code>cursor based iterator</code> ）：  <code>SCAN</code>  命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为  <code>SCAN</code>  命令的游标参数， 以此来延续之前的迭代过程。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HMSET k51  f1 v1 f2 v2 f3 v3 f4 v4 f5 v5 f6 v6 f7 v7 f8 v8</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; hscan k51 0 </span><br><span class=\"line\">1) <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">2)  1) <span class=\"string\">&quot;f1&quot;</span></span><br><span class=\"line\">    2) <span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\">    3) <span class=\"string\">&quot;f2&quot;</span></span><br><span class=\"line\">    4) <span class=\"string\">&quot;v2&quot;</span></span><br><span class=\"line\">    5) <span class=\"string\">&quot;f3&quot;</span></span><br><span class=\"line\">    6) <span class=\"string\">&quot;v3&quot;</span></span><br><span class=\"line\">    7) <span class=\"string\">&quot;f4&quot;</span></span><br><span class=\"line\">    8) <span class=\"string\">&quot;v4&quot;</span></span><br><span class=\"line\">    9) <span class=\"string\">&quot;f5&quot;</span></span><br><span class=\"line\">   10) <span class=\"string\">&quot;v5&quot;</span></span><br><span class=\"line\">   11) <span class=\"string\">&quot;f6&quot;</span></span><br><span class=\"line\">   12) <span class=\"string\">&quot;v6&quot;</span></span><br><span class=\"line\">   13) <span class=\"string\">&quot;f7&quot;</span></span><br><span class=\"line\">   14) <span class=\"string\">&quot;v7&quot;</span></span><br><span class=\"line\">   15) <span class=\"string\">&quot;f8&quot;</span></span><br><span class=\"line\">   16) <span class=\"string\">&quot;v8&quot;</span></span><br></pre></td></tr></table></figure>\n<p>以上，就是  <code>Redis</code>  中 <code>hash</code>  类型相关的 <code>15</code>  个命令了。务必熟记～</p>\n<h2 id=\"hash的内部结构\"><a class=\"markdownIt-Anchor\" href=\"#hash的内部结构\">#</a>  <code>hash</code>  的内部结构</h2>\n<p>在  <code>hash</code>  类型简介的时候，我们就说过  <code>hash</code>  是用两种数据结构来编码的。</p>\n<ul>\n<li>\n<p><code>ziplist</code></p>\n</li>\n<li>\n<p><code>hashtable</code> ( <code>dict</code> )</p>\n</li>\n</ul>\n<p><code>ziplist</code>  之前已经分享过了。具体参考之前的文章吧。 <a href=\"./06-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist.md\">链接</a></p>\n<p>这里我们就简单的来看下  <code>hashtable</code> .</p>\n<p>我们直接搜索  <code>hash</code>  , 可以发现  <code>t_hash.c</code>  这个文件，引入了  <code>server.h</code>  . 大体看了一下，都是函数的实现。那我们看下  <code>server.h</code>  ，应该存在对  <code>hastable</code>  的定义吧。然而，并没有。</p>\n<p>那我们来看下 <code>t_hash.c</code>  中添加方法的实现吧.  <code>int hashTypeSet(robj *o, sds field, sds value, int flags)</code></p>\n<p>源码太长了，这里就不粘了， 可以看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vZmFuZ2ppYXhpYW9iYWkvcmVkaXMvYmxvYi9yZWRpczUuMF9jaGluZXNlX3RyYW5zbGF0ZS9zcmMvdF9oYXNoLmM=\">源码</span></p>\n<p>通过查看源码可以得出:</p>\n<ul>\n<li><code>hash</code>  类型的默认编码是  <code>OBJ_ZIPLIST</code> . 即默认是使用  <code>ziplist</code>  这种数据结构进行编码存储的。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">robj *<span class=\"title\">createHashObject</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = <span class=\"built_in\">ziplistNew</span>();</span><br><span class=\"line\">    robj *o = <span class=\"built_in\">createObject</span>(OBJ_HASH, zl);</span><br><span class=\"line\">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当 <code>hash</code>  元素的个数大于  <code>hash_max_ziplist_entries</code>  时会，转换成  <code>hashTable</code> ( <code>OBJ_ENCODING_HT</code> ),</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"built_in\">hashTypeLength</span>(o) &gt; server.hash_max_ziplist_entries)</span><br><span class=\"line\">            <span class=\"built_in\">hashTypeConvert</span>(o, OBJ_ENCODING_HT);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>但是在  <code>redis 5.0.7</code>  中暂时不支持这种方式，还没有实现。(<b>没有实现从 <code>ziplist</code>  编码转化成 <code>hash</code>  编码。</b>)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hashTypeConvert</span><span class=\"params\">(robj *o, <span class=\"keyword\">int</span> enc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">hashTypeConvertZiplist</span>(o, enc);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">/// 这里！！！</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">serverPanic</span>(<span class=\"string\">&quot;Not implemented&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">serverPanic</span>(<span class=\"string\">&quot;Unknown hash encoding&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当创建的 <code>hash</code>  类型是  <code>hashtable</code>  编码 ( <code>OBJ_ENCODING_HT</code> ) 时，是使用 <code>dict</code>  这种类型存储的.</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// dict类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">/// 2个哈希表来实现</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 哈希表实现</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table; <span class=\"comment\">/// 哈希表节点指针数据(java源码中的桶的概念)</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size; <span class=\"comment\">/// 指针数组的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask; <span class=\"comment\">/// 指针数据的长度掩码,用于计算索引值</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used; <span class=\"comment\">/// 哈希表现有的节点数量</span></span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///哈希表的节点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"comment\">/// 值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">/// 下一个节点: dictht 是使用链地址法来处理hash冲突。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<p>整个  <code>dict</code>  结构就可以这么表示:</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/Redis-01-dict%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8.png\" alt=\"Redis-01-dict结构存储\"></p>\n<p>到这里，我们就知道了  <code>hash</code>  这种类型，是如何存储的了。 如果你还想了解<br>\n <code>dict</code>  是如何  <code>rehash</code> , 扩容，缩容。以及  <code>dict api</code>  相关实现的话，移驾这篇文章吧。 <a href=\"./Redis%E4%B8%AD%E7%9A%84dict%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md\">起驾～</a></p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li><code>hash</code>  结构，是一种哈希表结构。通过两种数据结构 <code>ziplist</code>  和  <code>hashtable</code> ( <code>dict</code> ) 实现。</li>\n<li>要熟练掌握的  <code>hash</code>  相关的 <code>15</code>  个命令。</li>\n<li><code>hashtable</code>  的编码格式，实际上就是使用的  <code>dict</code>  这种编码方式。我们简单的学习了 <code>Redis</code>  中 <code>dict</code>  结构的实现。还有一篇专门的文章，来介绍  <code>dict</code>  的详细内容。</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-2-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-2-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/",
            "title": "Redis数据结构之 List",
            "date_published": "2021-08-01T07:08:55.000Z",
            "content_html": "<h2 id=\"书接上回\"><a class=\"markdownIt-Anchor\" href=\"#书接上回\">#</a> 书接上回</h2>\n<p>上一篇文章 <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BString/\">Redis 的数据结构 string</a> 我们一起学习了这种类型的常用命令，并且还学习了  <code>Redis</code>  中的字符串的结构表示以及好处，这里我们接着学习另外一种数据结构  <code>list</code> 。</p>\n<h2 id=\"list-简介\"><a class=\"markdownIt-Anchor\" href=\"#list-简介\">#</a>  <code>list</code>  简介</h2>\n<p><code>list</code> , 一般都会称为列表。在 <code>Redis</code>  中，这种数据结构是一种比较灵活的结构，由于其元素的是有序的，所以可以充当栈和队列这两种数据结构。实际在开发总也有很多应用场景。</p>\n<p>一个 <code>List</code>  最多可以包含  <code>2^32-1</code>  个元素。</p>\n<p>很多人都会以为 <code>list</code>  是用数组来实现的，非也，非也。它内部是 <code>quicklist</code>  这种数据结构。想要先睹为快的，那么坐<a href=\"##%60list%60%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E4%B9%8B%60quicklist%60\">电梯直达</a>吧。</p>\n<h2 id=\"list的相关命令\"><a class=\"markdownIt-Anchor\" href=\"#list的相关命令\">#</a>  <code>list</code>  的相关命令</h2>\n<h3 id=\"lpush命令\"><a class=\"markdownIt-Anchor\" href=\"#lpush命令\">#</a>  <code>LPUSH</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LPUSH key value [value …]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>lpush</code>  :  <code>left push</code> 。</p>\n<p>将一个或者多个值插入到列表 <code>key</code>  的表头，返回列表的长度。元素可以是重复的。</p>\n<p>如果 <code>key</code>  不存在，那么会先穿件一个列表，然后再执行 <code>push</code>  操作.</p>\n<p>如果 <code>key</code>  值存在，但是 <code>value</code>  类型不是列表类型时，会返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置一个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH k22 v22</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询指定区间内的数据,使用lrange命令</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k22 0 10</span><br><span class=\"line\">1) &quot;v22&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 一次插入多个值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH k22 v22_1 v22_2 v22_3 v22_4</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k22 0 10</span><br><span class=\"line\">1) &quot;v22_4&quot;</span><br><span class=\"line\">2) &quot;v22_3&quot;</span><br><span class=\"line\">3) &quot;v22_2&quot;</span><br><span class=\"line\">4) &quot;v22_1&quot;</span><br><span class=\"line\">5) &quot;v22&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"lpushx-命令\"><a class=\"markdownIt-Anchor\" href=\"#lpushx-命令\">#</a>  <code>lpushx</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LPUSHX key value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>仅当  <code>key</code>  存在的时候，才将  <code>value</code>  插入列表的表头。返回列表中元素的个数。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当key值不存在的时候，不会放入列表中</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSHX k23 v23</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 再次尝试放入，也不可以。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSHX k23 v23</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\"><span class=\"comment\"># 先往数组放入一个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k23 v23</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 再次尝试使用lpushx放入数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSHX k23 v23_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"><span class=\"comment\"># 再次尝试使用lpushx放入数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSHX k23 v23_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"><span class=\"comment\"># 查看列表 k23 中的数据。注意：和插入的顺序是相反的。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; Lrange k23 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v23_2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v23_1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v23&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"rpush-命令\"><a class=\"markdownIt-Anchor\" href=\"#rpush-命令\">#</a>  <code>rpush</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>RPUSH key value [value ...]</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>rpush</code>  就是 <code>right push</code> 。将一个或多个值  <code>value</code>  插入到列表  <code>key</code>  的表尾 (最右边)。返回列表的长度。</p>\n<p>如果  <code>key</code>  不存在的时候，会创建一个空列表，然后在执行  <code>rpush</code>  操作。</p>\n<p>如果  <code>key</code>  存在，但是不是一个列表类型时，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 往列表中加入数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH k24 v24</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; RPUSH k24 v24_1 v25_2 v25_3</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k24 0 -1</span><br><span class=\"line\">1) &quot;v24&quot;</span><br><span class=\"line\">2) &quot;v24_1&quot;</span><br><span class=\"line\">3) &quot;v25_2&quot;</span><br><span class=\"line\">4) &quot;v25_3&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 演示 key 存在，但是不是一个列表类型</span></span><br><span class=\"line\">127.0.0.1:6379&gt; set k24_1 v24_1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush k24_1 v24_1</span><br><span class=\"line\">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpushx-命令\"><a class=\"markdownIt-Anchor\" href=\"#rpushx-命令\">#</a>  <code>rpushx</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>rpushx key value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>与  <code>lpushx</code>  类似，如果 <code>key</code>  不存在时，什么都不会操作。如果 <code>key</code>  存在，才会将元素添加到表尾。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> key不存在的时候，不会插入数据</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpushx k25 v25</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先设置一个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush k25 v25_1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; rpushx k25 v25_2</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; rpushx k25 v25_3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看列表中的数据。注意和插入的顺序是一致的。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k25 0 -1</span><br><span class=\"line\">1) &quot;v25_1&quot;</span><br><span class=\"line\">2) &quot;v25_2&quot;</span><br><span class=\"line\">3) &quot;v25_3&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"lpop-命令\"><a class=\"markdownIt-Anchor\" href=\"#lpop-命令\">#</a>  <code>lpop</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LPOP key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>left pop</code> ;</p>\n<p>移除并返回列表的头元素。当 <code>key</code>  不存在的时候，返回 <code>nil</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> key不存在的时候，返回nil</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPOP k26</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置一个列表，有三个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k26 v26_1 v26_2 v26_3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查看列表中的元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k26 0 -1</span><br><span class=\"line\">1) &quot;v26_3&quot;</span><br><span class=\"line\">2) &quot;v26_2&quot;</span><br><span class=\"line\">3) &quot;v26_1&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 依次pop出元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpop k26</span><br><span class=\"line\">&quot;v26_3&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lpop k26</span><br><span class=\"line\">&quot;v26_2&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lpop k26</span><br><span class=\"line\">&quot;v26_1&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lpop k26</span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>tip：  <code>lpush</code>  +  <code>lpop</code>  =&gt; 栈， <code>rpush</code>  +  <code>lpop</code>  =&gt; 队列。</p>\n</blockquote>\n<h3 id=\"rpop-命令\"><a class=\"markdownIt-Anchor\" href=\"#rpop-命令\">#</a>  <code>rpop</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>rpop key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>rpop</code>  ：  <code>right pop</code> ;</p>\n<p>和 lpop 相反。移除并返回列表的尾元素。如果 key 不存在返回 nil。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># key 不存在，返回nil</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpop k27</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 先设置一个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k27 v27_1 v27_2 v27_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k27 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v27_3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v27_2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v27_1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 一次pop每个值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpop k27</span><br><span class=\"line\"><span class=\"string\">&quot;v27_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpop k27</span><br><span class=\"line\"><span class=\"string\">&quot;v27_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpop k27</span><br><span class=\"line\"><span class=\"string\">&quot;v27_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpop k27</span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>tip:  <code>lpush</code>  +  <code>rpop</code>  =&gt; 队列， <code>rpush</code>  +  <code>rpop</code>  =&gt; 栈。</p>\n</blockquote>\n<h3 id=\"lrange-命令\"><a class=\"markdownIt-Anchor\" href=\"#lrange-命令\">#</a>  <code>lrange</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LRANGE key start stop</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>获取指定区间内的元素。0 表示第一个元素。如果超过了实际范围就返回空数组。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; LRANGE k22 0 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;v22_4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v22_3&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v22_2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v22_1&quot;</span></span><br><span class=\"line\">5) <span class=\"string\">&quot;v22&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k22 0 1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v22_4&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v22_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k22 10 100</span><br><span class=\"line\">(empty list or <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"rpoplpush-命令\"><a class=\"markdownIt-Anchor\" href=\"#rpoplpush-命令\">#</a>  <code>rpoplpush</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>RPOPLPUSH source destination</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将  <code>source</code>  的尾元素插入到 <code>destination</code>  列表的头元素中，返回该元素。 注意，这是一个原子操作。</p>\n<p>比如:  <code>source</code> :  <code>a,b,c</code></p>\n<p><code>distination</code> :  <code>1,2,3</code></p>\n<p>使用  <code>RPOPLPUSH source distination</code>  , 则：</p>\n<p><code>source</code> :  <code>a,b</code></p>\n<p><code>distination</code> :  <code>c,1,2,3</code></p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置列表1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k28_1 v28_c v28_b v28_a</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"><span class=\"comment\"># 设置列表2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k28_2 v28_3 v28_2 v28_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"><span class=\"comment\"># 使用 rpoppush命令</span></span><br><span class=\"line\">127.0.0.1:6379&gt; RPOPLPUSH k28_1 k28_2</span><br><span class=\"line\"><span class=\"string\">&quot;v28_c&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 查看列表1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k28_1 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v28_a&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v28_b&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 查看列表2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k28_2 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v28_c&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v28_1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v28_2&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v28_3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"lrem-命令\"><a class=\"markdownIt-Anchor\" href=\"#lrem-命令\">#</a>  <code>lrem</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LREM key count value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>至多移除列表中  <code>count</code>  个与参数  <code>value</code>  相等的元素。</p>\n<p>有以下情況:</p>\n<p><code>count &gt; 0</code>  : 从表头开始向表尾搜索，移除与  <code>value</code>  相等的元素，最多移除 <code>count</code>  个 。</p>\n<p><code>count &lt; 0</code>  : 从表尾开始向表头搜索，移除与  <code>value</code>  相等的元素，最多移除 <code>|count|</code>  个。</p>\n<p><code>count = 0</code>  : 移除表中所有与  <code>value</code>  相等的值。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 演示 count&gt;0 时</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置一个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k29_1 v29_1  v29  v29_2 v29 v29_3 v29</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从表头开始，移除2个 v29</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrem k29_1 2 v29</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k29_1 0 -1</span><br><span class=\"line\">1) &quot;v29_3&quot;</span><br><span class=\"line\">2) &quot;v29_2&quot;</span><br><span class=\"line\">3) &quot;v29&quot;</span><br><span class=\"line\">4) &quot;v29_1&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 演示count&lt;0 时</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k29_2 v29_1 v29  v29_2 v29 v29_3 v29</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; lrem k29_2 -2 v29</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k29_2 0 -1</span><br><span class=\"line\">1) &quot;v29&quot;</span><br><span class=\"line\">2) &quot;v29_3&quot;</span><br><span class=\"line\">3) &quot;v29_2&quot;</span><br><span class=\"line\">4) &quot;v29_1&quot;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 演示count=0时</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k29_3 v29_1 v29  v29_2 v29 v29_3 v29</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; lrem k29_3 0 v29</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; LRANGE k29_3 0 -1</span><br><span class=\"line\">1) &quot;v29_3&quot;</span><br><span class=\"line\">2) &quot;v29_2&quot;</span><br><span class=\"line\">3) &quot;v29_1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"llen-命令\"><a class=\"markdownIt-Anchor\" href=\"#llen-命令\">#</a>  <code>llen</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>LLEN key</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>获取列表的长度。</p>\n<p>如果  <code>key</code>  不存在的时候，返回 <code>0</code> .</p>\n<p>如果  <code>key</code>  对应类型不是  <code>list</code>  ，则返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; llen k30</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k30 v30_1 v30_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; llen k30</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删掉k30，演示，类型不是list的时候，报错</span></span><br><span class=\"line\">127.0.0.1:6379&gt; del k30</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k30 v30</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; llen k30</span><br><span class=\"line\">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>\n<h3 id=\"lindex-命令\"><a class=\"markdownIt-Anchor\" href=\"#lindex-命令\">#</a>  <code>lindex</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>lindex key index</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>返回列表中，下标为  <code>index</code>  的元素.  <code>-1</code>  表示列表的最后一个元素，如果 <code>key</code>  不存在，或者 <code>index</code>  超出范围，返回 <code>nil</code> ， 如果 key 不是一个列表类型，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; lpush k31 v31_3 v31_2 v31_1</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; LINDEX k31 2</span><br><span class=\"line\">&quot;v31_3&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; LINDEX k31 1</span><br><span class=\"line\">&quot;v31_2&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; LINDEX k31 0</span><br><span class=\"line\">&quot;v31_1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"linsert-命令\"><a class=\"markdownIt-Anchor\" href=\"#linsert-命令\">#</a>  <code>linsert</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>linsert key BEFORE|AFTER pivot value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将 <code>value</code>  插入到 <code>key</code>  队列 <code>pivot</code>  值之前或者之后。返回插入完成之后列表的长度。</p>\n<p>如果  <code>pivot</code>  不存在 或者  <code>key</code>  不存在，不执行任何操作。</p>\n<p>如果  <code>key</code>  对应的不是一个列表类型，返回一个错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; linsert k32 BEFORE k31_1 k31_0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k32 v32_1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> k32_3 =&gt; pivot不存在</span></span><br><span class=\"line\">127.0.0.1:6379&gt; linsert k32 BEFORE v32_3 v31_2</span><br><span class=\"line\">(integer) -1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> pivot之前插入</span></span><br><span class=\"line\">127.0.0.1:6379&gt; linsert k32 BEFORE v32_1 v31_0</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> pivot之后插入</span></span><br><span class=\"line\">127.0.0.1:6379&gt; linsert k32 AFTER v32_1 v31_2</span><br><span class=\"line\">(integer) 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"lset-命令\"><a class=\"markdownIt-Anchor\" href=\"#lset-命令\">#</a> lset 命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>lset key index value</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>将列表中的 索引为 <code>index</code>  的值设置为 <code>value</code> 。 如果 <code>index</code>  超出范围，则返回一个错误</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; lpush k33 v33_3 v33_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k33 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v33_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v33_3&quot;</span></span><br><span class=\"line\"><span class=\"comment\">## 将第二个值，索引为1，设置为v33_2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lset k33 1 v33_2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k33 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v33_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v33_2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 超出范围返回错误</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lset k33 2 v33_2</span><br><span class=\"line\">(error) ERR index out of range</span><br></pre></td></tr></table></figure>\n<h3 id=\"ltrim-命令\"><a class=\"markdownIt-Anchor\" href=\"#ltrim-命令\">#</a>  <code>ltrim</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>ltrim key start stop</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p>保留列表从 <code>start</code>  到 <code>stop</code>  之间的元素。其他元素都将被删除。 注意：包含 (不删除) <code>start</code>  和 <code>stop</code>  两个元素.</p>\n<p>如果 <code>key</code>  不存在，直接返回 <code>OK</code> , 如果 <code>key</code>  对应的不是列表，直接返回错误。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; lpush k34 v34_1 v34_2 v34_3 v34_4 v34_5 v34_6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; ltrim k34 1 4</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k34  0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v34_5&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v34_4&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v34_3&quot;</span></span><br><span class=\"line\">4) <span class=\"string\">&quot;v34_2&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"blpop-命令\"><a class=\"markdownIt-Anchor\" href=\"#blpop-命令\">#</a> blpop 命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>BLPOP key [key ...] timeout</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>lpop</code>  的 阻塞版本。  <code>block left pop</code></p>\n<p>当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br>\n当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># push到三组列表，分别三个元素</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k35 v35_1 v35_2 v35_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k35 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v35_3&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_2&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v35_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k35_1 v35_1 v35_2 v35_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k35_2 v35_1 v35_2 v35_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 阻塞调用lpop, 从左到右 依次pop元素，直到有一个元素可以pop。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k35_2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v35_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; blpop k35 k35_1 k35_2 10</span><br><span class=\"line\"><span class=\"comment\"># 没有元素的时候会阻塞一直到超时。</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">(10.59s)</span><br></pre></td></tr></table></figure>\n<h3 id=\"brpop-命令\"><a class=\"markdownIt-Anchor\" href=\"#brpop-命令\">#</a>  <code>brpop</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>BRPOP key [key ...] timeout</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>rpop</code>  的阻塞版本。  <code>block right pop</code> <br>\n 当给定多个 <code>key</code>  的时候，按照 <code>key</code>  的先后顺序依次检查各个列表。直到弹出一个元素或者超时。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置两个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k36 v36_1 v36_2 v36_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k36_1 v36_1 v36_2 v36_3</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"><span class=\"comment\"># 阻塞式的pop出每个值。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\">1) <span class=\"string\">&quot;k36_1&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v36_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOP k36 k36_1 10</span><br><span class=\"line\"><span class=\"comment\"># 阻塞10s</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">(10.61s)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Tips:  <code>lpush</code>  +  <code>brpop</code>  =&gt; 阻塞队列。</p>\n</blockquote>\n<h3 id=\"brpoplpush-命令\"><a class=\"markdownIt-Anchor\" href=\"#brpoplpush-命令\">#</a>  <code>brpoplpush</code>  命令</h3>\n<ul>\n<li>语法</li>\n</ul>\n<p><code>BRPOPLPUSH source destination timeout</code></p>\n<ul>\n<li>解释</li>\n</ul>\n<p><code>rpoplpush</code>  的阻塞版本。  <code>block right left push</code> 。</p>\n<p>当列表  <code>source</code>  为空的时候，该命令将阻塞，直到超时，或者 source 中有一个元素可以 pop。</p>\n<ul>\n<li>演示</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个列表</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k37_source v37_1 v37_2 v37_3 v37_4</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 4</span><br><span class=\"line\"><span class=\"comment\"># 将source移动到distination中。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOPLPUSH k37_source k37_distination 10</span><br><span class=\"line\"><span class=\"string\">&quot;v37_1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 查看下distination。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lrange k37_distination 0 -1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v37_1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOPLPUSH k37_source k37_distination 10</span><br><span class=\"line\"><span class=\"string\">&quot;v37_2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOPLPUSH k37_source k37_distination 10</span><br><span class=\"line\"><span class=\"string\">&quot;v37_3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOPLPUSH k37_source k37_distination 10</span><br><span class=\"line\"><span class=\"string\">&quot;v37_4&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这时我们启动两个客户端,演示阻塞直到另一个客户端执行source列表中的插入操作。</span></span><br><span class=\"line\"><span class=\"comment\"># 客户端1中继续执行 BRPOPLPUSH, 然后马上在客户端2中，输入&quot;LPUSH k37_source v37_5&quot;.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 客户端1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; BRPOPLPUSH k37_source k37_distination 10</span><br><span class=\"line\"><span class=\"string\">&quot;v37_5&quot;</span></span><br><span class=\"line\">(3.02s)</span><br><span class=\"line\"><span class=\"comment\"># 客户端2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; LPUSH k37_source v37_5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"list内部结构之quicklist\"><a class=\"markdownIt-Anchor\" href=\"#list内部结构之quicklist\">#</a>  <code>list</code>  内部结构之 <code>quicklist</code></h2>\n<h3 id=\"quicklist\"><a class=\"markdownIt-Anchor\" href=\"#quicklist\">#</a>  <code>quicklist</code></h3>\n<p>我们来看一下 <code>list</code>  的内部实现  <code>quicklist</code>  结构.</p>\n<p>特别注明：  <code>quicklist</code>  是双向的链表结构。</p>\n<p>在 <code>Redis</code>  中使用如下结构体表示.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 头结点</span></span><br><span class=\"line\">    quicklistNode *head;</span><br><span class=\"line\">    <span class=\"comment\">// 尾结点</span></span><br><span class=\"line\">    quicklistNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">// 列表的元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count;</span><br><span class=\"line\">    <span class=\"comment\">// 链表的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 单个节点的填充因子</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill : <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不进行节点压缩的最大深度</span></span><br><span class=\"line\">    <span class=\"comment\">// 超过这个节点就会进行节点压缩</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> compress : <span class=\"number\">16</span>;</span><br><span class=\"line\">&#125; quicklist;</span><br></pre></td></tr></table></figure>\n<p><code>quicklist</code>  是回一个通用的双向链接快速列表实现。它的每个节点用  <code>quicklistNode</code>  表示。</p>\n<p>一起来看下  <code>qucklistNode</code>  是什么吧。</p>\n<h3 id=\"quicklistnode\"><a class=\"markdownIt-Anchor\" href=\"#quicklistnode\">#</a>  <code>quicklistNode</code></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 前一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 后一个节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据指针。</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果指向的数据没有被压缩,那么会指向zipList结构。</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果进行了压缩，那么会指向 quickLZF结构。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz;</span><br><span class=\"line\">    <span class=\"comment\">// 元素的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count : <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码方式，1=RAW，2=LZF</span></span><br><span class=\"line\">    <span class=\"comment\">// 1 表示未被压缩</span></span><br><span class=\"line\">    <span class=\"comment\">// 2 表示使用LZF结构进行的压缩</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> encoding : <span class=\"number\">2</span>;   </span><br><span class=\"line\">    <span class=\"comment\">// 使用的容器是什么？1=NONE,2=ZIPLIST</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> container : <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前一个节点是否被压缩</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> recompress : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 是否压缩</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attempted_compress : <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 暂时留出来，以后使用。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> extra : <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>\n<p><code>quicklistNode</code>  是一个 <code>32byte</code>  的结构体，用于描述一个 <code>quicklist</code>  的一个节点。从代码中可看出，使用了位图来节约空间。在上面的代码中我们还提到两种数据结构，对应的是代码中  <code>zl</code>  指针，指向的位置，如果数据被压缩，指向 <code>quicklistLZF</code>  和 没有数据没有被压缩就是指向  <code>ziplist</code> .</p>\n<h3 id=\"ziplist\"><a class=\"markdownIt-Anchor\" href=\"#ziplist\">#</a>  <code>ziplist</code></h3>\n<p><code>ziplist</code>  这种结构比较复杂，而且在源码中也没有给出明确定义。那  <code>ziplist</code>  这么神秘的结构到底是什么样的呢？</p>\n<p>别着急，我们先大体熟悉下 <code>ziplist</code>  这种结构的设计意图。</p>\n<p><code>ziplist</code>  是一个经过特殊编码的双向链表，它的设计意图就是 提高存储效率，  <code>ziplist</code>  可以用于存储字符串或者整数，其中整数是按照真正的二进制进行编码的。 它能以 <code>O(1)</code>  的效率在表的两端进行 <code>pop</code>  和 <code>push</code>  操作。</p>\n<p>我们都知道，普通的链表每项都是一块独立的内存空间，各项之间都是通过指针连接起来的。这种方式，会带来大量的空间碎片，指针引用也会占用部分空间内存。所以 <code>ziplist</code>  是将表中每项放在连续的空间内存中 (类似数组)， <code>ziplist</code>  还对值采取了一个可变长度的存储方式，大的值就用大空间，小的值就用小空间。</p>\n<h4 id=\"ziplist结构的官方定义\"><a class=\"markdownIt-Anchor\" href=\"#ziplist结构的官方定义\">#</a> ziplist 结构的官方定义。</h4>\n<blockquote>\n<p>The general layout of the ziplist is as follows:<br>\n <code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code> <br>\n <code>&lt;uint32_t zlbytes&gt;</code>  is an unsigned integer to hold the number of bytes that  the ziplist occupies, including the four bytes of the zlbytes field itself.  This value needs to be stored to be able to resize the entire structure  without the need to traverse it first.<br>\n <code>&lt;uint32_t zltail&gt;</code>  is the offset to the last entry in the list. This allows  a pop operation on the far side of the list without the need for full  traversal.<br>\n <code>&lt;uint16_t zllen&gt;</code>  is the number of entries. When there are more than  2^16-2 entries, this value is set to 2^16-1 and we need to traverse the entire list to know how many items it holds.<br>\n <code>&lt;uint8_t zlend&gt;</code>  is a special entry representing the end of the ziplist. Is encoded as a single byte equal to 255. No other normal entry starts with a byte set to the value of 255.</p>\n</blockquote>\n<p>根据上面中解释我们可以得出以下这种模型：</p>\n<p><img data-src=\"./images/ziplist-01-Ziplist%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>如果没有特殊指定的话，都是采用小尾数法存储的。</p>\n<ul>\n<li>\n<p><code>zlbytes</code> : 存储一个无符号整数，用于存储 ziplist 的所用的字节数，(包括 zlbytes 字段本身的四个字节)，当重新分配内容的时候，不需要遍历整个列表来计算内存大小。</p>\n</li>\n<li>\n<p><code>zltail</code> : 一个无符号整数，表示 ziplist 中最后一个元素的偏移字节数，这样可以方便的找到最后一个元素，从而可以以 O (1) 的复杂度在尾端进行 pop 和 push。</p>\n</li>\n<li>\n<p><code>zllen：压缩列表包含的结点的个数，即entry的个数。</code> <br>\n这里的 <code>zllen</code>  是占用 <code>16bit</code> , 也就是说最多存储  <code>2^16-2</code>  个。但是 <code>ziplist</code>  超了 <code>2^16-2</code>  个也是可以表示的。那种情况就是 <code>16</code>  个 <code>1</code>  的时候，只需要从头遍历到尾就好了。</p>\n</li>\n<li>\n<p><code>entry</code> : 真正存放数据的数据项，每个数据项都有自己的内部结构。</p>\n</li>\n<li>\n<p><code>zlend</code> :  <code>ziplist</code>  的最后一个字节，值固定等于 <code>255</code> ，就是一个结束标记。</p>\n</li>\n</ul>\n<h4 id=\"entry-结构\"><a class=\"markdownIt-Anchor\" href=\"#entry-结构\">#</a> entry 结构</h4>\n<p><code>entry</code>  是由三部分构成的。</p>\n<ul>\n<li>\n<p><code>previous length（pre_entry_length）</code> ： 表示前一个数据节点占用的总字节数，这个字段的用处是为了让 ziplist 能够从后向前遍历（从后一项的位置，只需向前偏移 <code>previous length</code>  个字节，就找到了前一项）。这个字段采用变长编码。</p>\n</li>\n<li>\n<p><code>encoding</code> （ <code>encoding&amp;cur_entry_length</code> ）：表示当前数据节点 content 的内容类型以及长度。也采用变长编码。</p>\n</li>\n<li>\n<p><code>entry-data</code> ：表示当前节点存储的数据， <code>entry-data</code>  的内容类型有整数类型和字节数组类型，且某些条件下 <code>entry-data</code>  的长度可能为 <code>0</code> 。</p>\n</li>\n</ul>\n<p>所以我们可以得出  <code>ziplist</code>  是一个这样的结构。</p>\n<p><img data-src=\"./images/ziplist-01-entry%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>有时，encoding 也可以代表 entry 本身，就像小整数一样。</p>\n<p><img data-src=\"./images/ziplist-01-entry%E7%9A%84%E7%BB%93%E6%9E%842.png\" alt=\"\"></p>\n<p>这里就是大体的了解下 ziplist 这种数据结构。</p>\n<blockquote>\n<p>这里是一篇关于 <a href=\"./10-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bziplist.md\">ziplist</a> 详细解读的文章。</p>\n</blockquote>\n<h3 id=\"quicklistlzf\"><a class=\"markdownIt-Anchor\" href=\"#quicklistlzf\">#</a>  <code>quicklistLZF</code></h3>\n<p>看完了比较神秘的 <code>ziplist</code>  结构，我们来看一个比较简单的 <code>quicklist</code>  的压缩节点的结构  <code>quicklistLZF</code> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * quicklistLZF是一个4 + N字节的 struct。</span></span><br><span class=\"line\"><span class=\"comment\"> * sz 是 compressed 字段的字节长度。&#x27;compressed&#x27; 是长度为 sz的 LZF数据。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 未被压缩的长度保存到 quicklistNode-&gt;sz中。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 当压缩了quicklistNode-&gt;zl时，quicklistNode-&gt;zl指向的是一个 quicklistLZF类型的数据。</span></span><br><span class=\"line\"><span class=\"comment\"> * 未压缩的时候，指向的是ziplist.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistLZF</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">///compressed数组长度 </span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz; </span><br><span class=\"line\">    <span class=\"keyword\">char</span> compressed[];</span><br><span class=\"line\">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li><code>list</code>  相关的命令。以及常见的应用场景。比如栈和队列等等。</li>\n<li><code>list</code>  其实是一种链表结构，但是不是一个普通的链表结构。</li>\n<li><code>list</code>  是由  <code>quicklist</code>  这种数据结构实现的。 <code>quicklist</code>  中的每个节点是 <code>quicklistNode</code> , 而 <code>quicklist</code>  中 <code>zl</code>  指针，指向的是 一个 <code>ziplist</code>  或者 <code>quickListLZF</code> 。</li>\n<li><code>ziplist</code>  是一个比较神秘的数据结构，有 <code>5</code>  部分构成，是连续存储的，可以实现 <code>O(1)</code>  的尾端 <code>pop</code>  和 <code>push</code>  操作。</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BString/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BString/",
            "title": "Redis数据结构之 String",
            "date_published": "2021-08-01T06:58:55.000Z",
            "content_html": "<p>今天来聊聊  <code>Redis</code>  的 <code>string</code> ，这一数据结构。</p>\n<h3 id=\"string简介\"><a class=\"markdownIt-Anchor\" href=\"#string简介\">#</a>  <code>string</code>  简介</h3>\n<p><code>string</code>  是 <code>Redis</code>  中最基本，也是最简单的数据结构。一个键 ( <code>key</code> ) 对应着一个 <code>string</code>  类型的值 ( <code>value</code> ). 我们都知道 <code>redis</code>  是使用 <code>C</code>  语言来编写的，但是  <code>string</code>  这一个数据结构并非是使用 <code>C</code>  语言的  <code>string(char[])</code>  来实现的，要想先了解，那就做电梯吧 -&gt;( <a href=\"#%60Redis%60%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">电梯直达</a> ).</p>\n<p>现在，先暂且抛开内部实现，我们先看看有怎么使用这一数据结构。</p>\n<h3 id=\"string相关常用命令\"><a class=\"markdownIt-Anchor\" href=\"#string相关常用命令\">#</a>  <code>string</code>  相关常用命令</h3>\n<h4 id=\"set命令\"><a class=\"markdownIt-Anchor\" href=\"#set命令\">#</a>  <code>set</code>  命令</h4>\n<p><code>SET key value [expiration EX seconds|PX milliseconds] [NX|XX]</code></p>\n<p>使用示例:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.设置一个键值对 f1=&gt;f1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k1 v1</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 根据键查询值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k1</span><br><span class=\"line\"><span class=\"string\">&quot;v1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.设置一个键值对(f2=&gt;f2),设置超时时间为10s</span></span><br><span class=\"line\"><span class=\"comment\"># EX 表示秒</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k2 v2 EX 10</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get k2</span><br><span class=\"line\"><span class=\"string\">&quot;v2&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 等待10s之后去查询f2</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k2</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.设置一个键值对(f3=&gt;f3),设置超时时间为 10000毫秒</span></span><br><span class=\"line\"><span class=\"comment\"># PX 表示为毫秒</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k3 v3 PX 10000</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get k3</span><br><span class=\"line\"><span class=\"string\">&quot;v3&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k3</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.设置键值对k4=&gt;v4,验证&quot;存在相同的key就设置失败&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># setnx 命令也可实现,注意返回值。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k4 v4 NX</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 如果存在相同的key就设置失败(与下面的注意对比)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k4 v4 NX</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.验证&quot;不存在相同的key就设置失败&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k5 v5 XX</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 先设置一个键值对,</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k5 v5 </span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 设置不存在相同的key就设置失败</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k5 v5 XX</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<h4 id=\"setnx命令\"><a class=\"markdownIt-Anchor\" href=\"#setnx命令\">#</a>  <code>setnx</code>  命令</h4>\n<p><code>setnx key value</code></p>\n<p><code>set if not exists</code>  的缩写。如果已存在 key, 返回 0, 不存在返回 1. 常用于分布式锁。</p>\n<p>使用实例</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个不存在的键值对 k6=&gt;v6</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setnx k6 v6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 如果key已经存在,则返回0。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setnx k6 v6</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n<h4 id=\"setex-命令\"><a class=\"markdownIt-Anchor\" href=\"#setex-命令\">#</a>  <code>setEx</code>  命令</h4>\n<p><code>setex key seconds value</code></p>\n<p>给键值对设置生存时间 (秒级别)。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置k7=&gt;v7这个键值对的生存时间为5s</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setex k7 5 v7</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get k7</span><br><span class=\"line\">&quot;v7&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 过5s秒钟之后,再查看。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k7</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>\n<h4 id=\"psetex-命令\"><a class=\"markdownIt-Anchor\" href=\"#psetex-命令\">#</a>  <code>psetEx</code>  命令</h4>\n<p><code>psetex key milliseconds value</code></p>\n<blockquote>\n<p><code>tip</code> : 命令助记:  <code>psetex</code>  ,  <code>p</code>  直接的是毫秒。可以参考 <code>set</code>  命令的 <code>PX</code>  选项。</p>\n</blockquote>\n<p>给键值对设置生存时间 (毫秒级别)。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置键值对</span></span><br><span class=\"line\">127.0.0.1:6379&gt; psetex k8 5000 v8</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"comment\"># 获取k8的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k8</span><br><span class=\"line\"><span class=\"string\">&quot;v8&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 5s之后，获取k8的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k8</span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n<h4 id=\"get命令\"><a class=\"markdownIt-Anchor\" href=\"#get命令\">#</a>  <code>get</code>  命令</h4>\n<p>这个命令不多说了，获取 <code>key</code>  相关联的 <code>value</code> .  <code>get key</code></p>\n<h4 id=\"getset命令\"><a class=\"markdownIt-Anchor\" href=\"#getset命令\">#</a>  <code>getset</code>  命令</h4>\n<p><code>getset key value</code></p>\n<p>设置键值对， <code>key=&gt;value</code> , 如果 <code>key</code>  已经存在，返回旧值。不存在返回  <code>nil</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置键值对</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getset k9 v9</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 获取值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k9</span><br><span class=\"line\"><span class=\"string\">&quot;v9&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 在设置一次k9,值为vv9,返回旧值 v9</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getset k9 vv9</span><br><span class=\"line\"><span class=\"string\">&quot;v9&quot;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ps: 如果原来的存在 key，但是 value 的类型与新设置的类型不一致，会抛出命令错误。</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置一个list类型，key为k9_1, Value中只有一个元素v9_1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k9_1 v9_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\"><span class=\"comment\"># 使用getset命令载设置一次,抛出命令错误。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getset k9_1 vv9_1</span><br><span class=\"line\">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>\n<h4 id=\"strlen-命令\"><a class=\"markdownIt-Anchor\" href=\"#strlen-命令\">#</a>  <code>strlen</code>  命令</h4>\n<p><code>strlen key</code></p>\n<p>返回字符串的长度。如果 key 不存在的时候，返回 0, 如果 key 对应的不是一个字符串时，返回错误.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k10 v10</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen k10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\"><span class=\"comment\"># 演示报错</span></span><br><span class=\"line\">127.0.0.1:6379&gt; lpush k10_1 v10</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen k10_1</span><br><span class=\"line\">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>\n<h4 id=\"append命令\"><a class=\"markdownIt-Anchor\" href=\"#append命令\">#</a>  <code>APPEND</code>  命令</h4>\n<p><code>APPEND key value</code>  命令</p>\n<p>根据 key，给 key 对应的值追加字符串。如果 key 不存在，就设置一对键值对。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果key不存在则设置键值对</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append k11 v11</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; get k11</span><br><span class=\"line\"><span class=\"string\">&quot;v11&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果存在，则追加</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append k11 v11</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\">127.0.0.1:6379&gt; get k11</span><br><span class=\"line\"><span class=\"string\">&quot;v11v11&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"setrange命令\"><a class=\"markdownIt-Anchor\" href=\"#setrange命令\">#</a>  <code>setrange</code>  命令</h4>\n<p><code>setrange key offset value</code></p>\n<p>从偏移量  <code>offset</code>  开始覆写原来 <code>key</code>  的值。如果 <code>key</code>  不存的时候当作空字符串处理。返回被设置后 <code>Value</code>  的长度。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置不存在的key</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setrange k12 3 v12</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 6</span><br><span class=\"line\"><span class=\"comment\"># 在offset前的空位置会用 \\x00 填充</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get k12</span><br><span class=\"line\"><span class=\"string\">&quot;\\x00\\x00\\x00v12&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 设置已经存在的key</span></span><br><span class=\"line\">127.0.0.1:6379&gt; setrange k12 4 v12</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 7</span><br><span class=\"line\">127.0.0.1:6379&gt; get k12</span><br><span class=\"line\"><span class=\"string\">&quot;\\x00\\x00\\x00vv12&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"getrange命令\"><a class=\"markdownIt-Anchor\" href=\"#getrange命令\">#</a>  <code>getrange</code>  命令</h4>\n<p><code>getrange key start end</code></p>\n<p>获取指定区间的值。报错 start 和 end 位置。索引位置是从 0 开始的。</p>\n<p>负数偏移量表示从字符创的末位开始计数。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k13 v13v13v13</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; getrange k13 2 5</span><br><span class=\"line\"><span class=\"string\">&quot;3v13&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 从索引为2处，到倒数第4位。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getrange k13 2 -4</span><br><span class=\"line\"><span class=\"string\">&quot;3v13&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果end大于Value的长度，返回目前start到结束的部分</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getrange k13 3 10</span><br><span class=\"line\"><span class=\"string\">&quot;v13v13&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 超过Value的长度返回为 &quot;&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; getrange k13 100 120</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"incr-命令\"><a class=\"markdownIt-Anchor\" href=\"#incr-命令\">#</a>  <code>incr</code>  命令</h4>\n<p><code>incr key</code></p>\n<p>在 key 对应的 Value 上进行自增 1. 如果 Value 可以解释为数据，则自增，反之，返回错误。</p>\n<p>返回值为自增后的值。</p>\n<p>如果 ke 不存在，则先初始化 key 对应的 Value=0， 然后再自增。</p>\n<p>相对的是: <a href=\"#%60DECR%60%E5%91%BD%E4%BB%A4\"> <code>DECR</code>  命令</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; incr k14</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; get k14</span><br><span class=\"line\"><span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; incr k14</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"incrby命令\"><a class=\"markdownIt-Anchor\" href=\"#incrby命令\">#</a>  <code>incrby</code>  命令</h4>\n<p><code>incrby key increment</code></p>\n<p>带有步长的自增命令。</p>\n<p>相对的命令是: <a href=\"%60DECRBY%60%E5%91%BD%E4%BB%A4\"> <code>DECRBY</code>  命令</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; incrby k15 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; INCRBY k15 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 10</span><br><span class=\"line\">127.0.0.1:6379&gt; INCRBY k15 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 15</span><br></pre></td></tr></table></figure>\n<h4 id=\"incrbyfloat命令\"><a class=\"markdownIt-Anchor\" href=\"#incrbyfloat命令\">#</a>  <code>INCRBYFLOAT</code>  命令</h4>\n<p><code>INCRBYFLOAT key increment</code></p>\n<p>带有步长的浮点数自增</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; INCRBYFLOAT k16 5.0</span><br><span class=\"line\"><span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; INCRBYFLOAT k16 5.2</span><br><span class=\"line\"><span class=\"string\">&quot;10.2&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; INCRBYFLOAT k16 5.4</span><br><span class=\"line\"><span class=\"string\">&quot;15.6&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"decr命令\"><a class=\"markdownIt-Anchor\" href=\"#decr命令\">#</a>  <code>DECR</code>  命令</h4>\n<p><code>DECR key</code></p>\n<p>自减 <code>1</code> .</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果key，不存在，同样会初始化为0，然后自减1</span></span><br><span class=\"line\">127.0.0.1:6379&gt; DECR k17</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -1</span><br><span class=\"line\">127.0.0.1:6379&gt; DECR k17</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -2</span><br><span class=\"line\">127.0.0.1:6379&gt; DECR k17</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -3</span><br></pre></td></tr></table></figure>\n<h4 id=\"decrby命令\"><a class=\"markdownIt-Anchor\" href=\"#decrby命令\">#</a>  <code>DECRBY</code>  命令</h4>\n<p>带有步长的自减命令，与 <a href=\"%60INCRBY%60%E5%91%BD%E4%BB%A4\"> <code>INCRBY</code>  命令</a>相对。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果key不存在，会初始化为0，在进行自减。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; DECRBY k18 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -5</span><br><span class=\"line\">127.0.0.1:6379&gt; DECRBY k18 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) -10</span><br></pre></td></tr></table></figure>\n<h4 id=\"mget命令\"><a class=\"markdownIt-Anchor\" href=\"#mget命令\">#</a>  <code>mget</code>  命令</h4>\n<p><code>mget key [key ...]</code></p>\n<p>一次性返回多个 <code>key</code>  的值。 如果 <code>key</code>  不存在，返回  <code>(nil)</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k19_0 v19_0</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> k19_1 v19_1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; mget k19_0 k19_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v19_0&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v19_1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果key不存在的时候，返回 (nil)</span></span><br><span class=\"line\">127.0.0.1:6379&gt; mget k19_0 k19_1 k10_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;v19_0&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v19_1&quot;</span></span><br><span class=\"line\">3) (nil)</span><br></pre></td></tr></table></figure>\n<h4 id=\"mset命令\"><a class=\"markdownIt-Anchor\" href=\"#mset命令\">#</a>  <code>mset</code>  命令</h4>\n<p>同时为设置多个键值对。 如果 key 已经存在，直接覆盖掉。</p>\n<p>注意： 这个原子性操作。所有给定的 key 都会在同一时间内被设置。</p>\n<blockquote>\n<p>tips: 如果希望，已经存在的 key 不被覆盖，可以参考 <a href=\"#%60msetnx%60%E5%91%BD%E4%BB%A4\"> <code>msetnx</code>  命令</a></p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一下设置三对</span></span><br><span class=\"line\">127.0.0.1:6379&gt; mset k20_0 v20_0 k20_1 v20_1 k20_2 v20_2</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; mget k20_0 k20_1 k20_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;v20_0&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v20_1&quot;</span></span><br><span class=\"line\">3) <span class=\"string\">&quot;v20_2&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 演示已有的key对应的值会被覆盖掉。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; mset k20_2 vv20_2 k20_3 v20_3</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; mget k20_2 k20_3</span><br><span class=\"line\">1) <span class=\"string\">&quot;vv20_2&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v20_3&quot;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"msetnx命令\"><a class=\"markdownIt-Anchor\" href=\"#msetnx命令\">#</a>  <code>msetnx</code>  命令</h4>\n<p><code>MSETNX key value [key value ...]</code></p>\n<p>当且仅当所有给定的 key 不存在的时候，才会设置键值对。即使有一个 key 存在，该命令也不会设置其他的 key 对应的键值对.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 演示设置成功</span></span><br><span class=\"line\">127.0.0.1:6379&gt; MSETNX k21_0 v21_0 k21_1 v21_1</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; MGET k21_0 k21_1</span><br><span class=\"line\">1) <span class=\"string\">&quot;v21_0&quot;</span></span><br><span class=\"line\">2) <span class=\"string\">&quot;v21_1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存在其中的一个给定key，就不能设置成功</span></span><br><span class=\"line\">127.0.0.1:6379&gt; msetnx k21_1 vv21_1 k21_2 v21_2</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; MGET k21_1 k21_2</span><br><span class=\"line\">1) <span class=\"string\">&quot;v21_1&quot;</span></span><br><span class=\"line\">2) (nil)</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis如何实现string这一数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis如何实现string这一数据结构\">#</a>  <code>Redis</code>  如何实现 <code>String</code>  这一数据结构</h3>\n<p>在  <code>string</code>  的相关命令介绍的时候，我其实使用一个错误的描述。就是将 <code>Redis</code>  的 <code>String</code>  类型称为字符串。这种说法其实不正确的。</p>\n<p>在  <code>redis</code>  中， <code>string</code>  这一数据结构使用 <code>sds</code>  来表示的。</p>\n<h4 id=\"sds\"><a class=\"markdownIt-Anchor\" href=\"#sds\">#</a>  <code>sds</code></h4>\n<p><code>sds</code>  是  <code>simple dynamic string</code>  的简称。 意思是  <code>简单的动态字符串</code> 。 这里面的 <code>string</code>  就是实打实的 <code>C</code>  语言中的字符串 ( <code>char[]</code> ).  <code>Redis</code>  也并非一点也没有使用  <code>C</code>  语言的字符串，像一些字面量常亮，日志都是使用 <code>C</code>  语言的字符串。</p>\n<p>那  <code>sds</code>  到底是一个什么样的结构呢？</p>\n<p>在源码的  <code>src</code>  目录下，我找到了  <code>sds.h</code>  这样一个文件。这里规定了  <code>sds</code>  结构。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">attribute__</span> ((__<span class=\"title\">packed__</span>)) <span class=\"title\">sdshdr64</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 表示已使用的长度,即buf[]的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> len; </span><br><span class=\"line\">    <span class=\"comment\">// 已分配的长度(包括未使用的长度)</span></span><br><span class=\"line\">    <span class=\"comment\">// alloc-len,对应着之前版本的free</span></span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> alloc; </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags; </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>tips: 如果你注意到了这个结构体的命名。那么来看下<a href=\"\">这篇文章</a>吧。</p>\n</blockquote>\n<p><code>sds</code>  保留了  <code>C</code>  字符串以空字符结尾的惯例。保留的这个空字符的长度不会保存在  <code>len</code>  字段中。保留这一惯例的好处就是可以使用 <code>C</code>  字符串函数库的一些方法。</p>\n<p>假设我们分配了 <code>10</code>  个字节空间，只保存了  <code>redis</code>  这个 <code>C</code>  字符串，那么 在 <code>sds</code>  中，是这么表示的：</p>\n<p><img data-src=\"/images/Redis%E7%B3%BB%E5%88%97/images/01-01-sds%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"01-01-sds示意图.png\"></p>\n<h4 id=\"使用sds比使用c字符串有什么好处呢\"><a class=\"markdownIt-Anchor\" href=\"#使用sds比使用c字符串有什么好处呢\">#</a> 使用 <code>sds</code>  比使用 <code>C</code>  字符串有什么好处呢？</h4>\n<h5 id=\"获取字符长度的时间复杂度为-o1\"><a class=\"markdownIt-Anchor\" href=\"#获取字符长度的时间复杂度为-o1\">#</a> 获取字符长度的时间复杂度为  <code>O(1)</code></h5>\n<p><code>C</code>  语言获取一个字符串的长度为  <code>O(N)</code> . 需要遍历字符串并累加，判断字符是否为  <code>'\\0'</code>  来获得字符串的长度。</p>\n<p><code>sds</code>  只需要根据  <code>len</code>  字段获取即可。怎么获取的呢？</p>\n<p>我们来看下源码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义char类型的指针类型。</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;</span><br><span class=\"line\"><span class=\"comment\">// 获取长度的结构体指针的宏.</span></span><br><span class=\"line\"><span class=\"comment\">// 可根据指向buf的指针返回指向sdshdr结构体首地址的宏</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sds 直接指向结构体里的buf</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// sds是直接指向结构体里的buf数据, 当获取len等字段的信息,只需要减去结构体长度，回退一下指针就可以了。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里使用的尾指针法。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> flags = s[<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 判断属于那种 sdshdr,对应减去不同的地址。</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_5:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SDS_TYPE_5_LEN</span>(flags);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_8:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SDS_HDR</span>(<span class=\"number\">8</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_16:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SDS_HDR</span>(<span class=\"number\">16</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_32:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SDS_HDR</span>(<span class=\"number\">32</span>,s)-&gt;len;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SDS_TYPE_64:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SDS_HDR</span>(<span class=\"number\">64</span>,s)-&gt;len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"可以杜绝缓冲区溢出\"><a class=\"markdownIt-Anchor\" href=\"#可以杜绝缓冲区溢出\">#</a> 可以杜绝缓冲区溢出</h5>\n<p><code>C</code>  语言是不会判断数组是否越界的。比如  <code>strcat</code>  方法，如果当前的数据不能容纳拼接之后字符时，必然会发生缓存区溢出。<br>\n但是  <code>sds</code>  则不会。我们来看下  <code>sds</code>  的字符串拼接的方法  <code>sdscat</code> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// s 原来的字符串，t是要拼接的字符串</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscat</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sdscatlen</span>(s, t, <span class=\"built_in\">strlen</span>(t));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatlen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *t, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取原来字符串的长度。(见上面的方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = <span class=\"built_in\">sdslen</span>(s);</span><br><span class=\"line\">    <span class=\"comment\">// 扩大sds字符串末尾的可用空间，</span></span><br><span class=\"line\">    <span class=\"comment\">//以便调用者确保在调用此函数后可以覆盖字符串末尾的addlen字节，</span></span><br><span class=\"line\">    <span class=\"comment\">//再为null项再加上一个字节。 具体实现，参考源码(sds.c:204)。</span></span><br><span class=\"line\">    s = <span class=\"built_in\">sdsMakeRoomFor</span>(s,len);</span><br><span class=\"line\">    <span class=\"comment\">// 如果内存分配失败，就会返回null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 调用C语言的分配</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(s+curlen, t, len);</span><br><span class=\"line\">    <span class=\"comment\">// sds设置 sdshdr的len字段的值。</span></span><br><span class=\"line\">    <span class=\"built_in\">sdssetlen</span>(s, curlen+len);</span><br><span class=\"line\">    <span class=\"comment\">// 添加最后一个字符为: &#x27;\\0&#x27;</span></span><br><span class=\"line\">    s[curlen+len] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"sds-优化了c语言的内存分配策略\"><a class=\"markdownIt-Anchor\" href=\"#sds-优化了c语言的内存分配策略\">#</a> sds 优化了 C 语言的内存分配策略</h5>\n<h6 id=\"空间预分配\"><a class=\"markdownIt-Anchor\" href=\"#空间预分配\">#</a> 空间预分配</h6>\n<p>空间预分配策略遵循下面的公式:</p>\n<ul>\n<li>如果 <code>SDS</code>  的长度小于最大的预分配空间 ( <code>1MB</code> ), 那么会分配两倍的新空间，再加上结尾的空字符 <code>'\\0'</code>  举个例子：原有的 <code>sds</code>  的 <code>len</code>  为 <code>5</code> , <code>alloc</code>  为 <code>5</code> , 要拼接的字符串长度为 <code>15</code> , 那么新分配的空间大小是:  <code>(5byte+15byte)*2 + 1byte = 41byte</code> .</li>\n<li>如果 <code>sds</code>  的长度大于等于默认的预分配空间，那么就在新分配的空间大小基础上，在分配 <code>1MB</code>  的空间。如果修改后的， <code>SDS</code>  的 <code>len</code>  是  <code>20M</code> ，那么 <code>alloc</code>  就是  <code>20M + 1M + 1byte</code></li>\n</ul>\n<p>具体分配过程见下面的源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SDS 默认最大的预分配空间为1M</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sds 预分配空间</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sh, *newsh;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> avail = <span class=\"built_in\">sdsavail</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type, oldtype = s[<span class=\"number\">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hdrlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果空间足够，直接返回 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (avail &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    len = <span class=\"built_in\">sdslen</span>(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">char</span>*)s-<span class=\"built_in\">sdsHdrSize</span>(oldtype);</span><br><span class=\"line\">    newlen = (len+addlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\"></span><br><span class=\"line\">    type = <span class=\"built_in\">sdsReqType</span>(newlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class=\"line\"><span class=\"comment\">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * at every appending operation. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class=\"line\"></span><br><span class=\"line\">    hdrlen = <span class=\"built_in\">sdsHdrSize</span>(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldtype==type) &#123;</span><br><span class=\"line\">        newsh = <span class=\"built_in\">s_realloc</span>(sh, hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Since the header size changes, need to move the string forward,</span></span><br><span class=\"line\"><span class=\"comment\">         * and can&#x27;t use realloc */</span></span><br><span class=\"line\">        newsh = <span class=\"built_in\">s_malloc</span>(hdrlen+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"keyword\">char</span>*)newsh+hdrlen, s, len+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">s_free</span>(sh);</span><br><span class=\"line\">        s = (<span class=\"keyword\">char</span>*)newsh+hdrlen;</span><br><span class=\"line\">        s[<span class=\"number\">-1</span>] = type;</span><br><span class=\"line\">        <span class=\"built_in\">sdssetlen</span>(s, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sdssetalloc</span>(s, newlen);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"惰性空间释放\"><a class=\"markdownIt-Anchor\" href=\"#惰性空间释放\">#</a> 惰性空间释放</h6>\n<p>当对 sds 进行缩短操作时，程序并不会立马对内存重分配来回收收缩的空间，而是仅仅改变 <code>len</code>  属性，并且在队对应的位置上将字符设置为:  <code>'\\0'</code></p>\n<p>以 函数  <code>sdstrim</code>  为例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdstrim</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cset)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *start, *end, *sp, *ep;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    sp = start = s;</span><br><span class=\"line\">    ep = end = s+<span class=\"built_in\">sdslen</span>(s)<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sp &lt;= end &amp;&amp; <span class=\"built_in\">strchr</span>(cset, *sp)) sp++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ep &gt; sp &amp;&amp; <span class=\"built_in\">strchr</span>(cset, *ep)) ep--;</span><br><span class=\"line\">    len = (sp &gt; ep) ? <span class=\"number\">0</span> : ((ep-sp)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 进行移位</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != sp) <span class=\"built_in\">memmove</span>(s, sp, len);</span><br><span class=\"line\">    <span class=\"comment\">// 设置字符串结束符</span></span><br><span class=\"line\">    s[len] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置len字段的值</span></span><br><span class=\"line\">    <span class=\"built_in\">sdssetlen</span>(s,len);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述实现中，并没有进行内存回收。 <code>sds</code>  也提供了内存回收的函数 <code>sds_free</code> . 具体可以看 <code>Redis 5.0.7</code>  版源码.  <code>sds.c</code>  第 <code>1120</code>  行。这里不再深入学习了。</p>\n<h4 id=\"二进制安全\"><a class=\"markdownIt-Anchor\" href=\"#二进制安全\">#</a> 二进制安全</h4>\n<p><code>sds</code>  的 <code>API</code>  都是二进制安全的。因为 <code>Redis</code>  对  <code>sds</code>  结构中的 <code>buf</code>  数组中的数据都是以二进制的方式处理的。</p>\n<h4 id=\"兼容部分的c字符串函数\"><a class=\"markdownIt-Anchor\" href=\"#兼容部分的c字符串函数\">#</a> 兼容部分的 <code>C</code>  字符串函数</h4>\n<p><code>Redis</code>  还是遵循了 <code>C</code>  字符串以  <code>'\\0'</code>  结尾的习惯，所以保存了文本数据的 <code>sds</code>  是可以复用  <code>&lt;string.h&gt;</code>  库中的函数。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<ul>\n<li>\n<p><code>string</code>  是 <code>redis</code>  中最简单的数据结构.  <code>string</code>  不是 <code>C</code>  字符串，而是对 <code>C</code>  字符串进行了封装.</p>\n</li>\n<li>\n<p>学习了 <code>string</code>  类型相关的 <code>api</code> 。  <code>set</code> , <code>setnx</code> , <code>setex</code> ,  <code>get</code> ,  <code>getset</code> ,  <code>incr</code> ,  <code>decr</code> ,…</p>\n</li>\n<li>\n<p><code>sds</code>  这种设计的好处，提高了性能，优化内存分配，二进制安全，兼容 <code>C</code>  字符串。</p>\n</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/02-Redis%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/02-Redis%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/",
            "title": "Redis 多个数据库",
            "date_published": "2021-08-01T06:48:55.000Z",
            "content_html": "<p><code>Redis</code>  默认提供了 <code>16</code>  个数据库。每个数据库都有一个 <code>id</code> , 从  <code>0</code>  开始，[0,15]。 不同的数据库中数据隔离保存。我们可以通过修改 redis 的配置文件进行修改数据库的数量。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">database</span> <span class=\"string\">32</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用  <code>select &lt;ID&gt;</code>  可以切换数据库.</li>\n</ul>\n<p>示例如下:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; select 1</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 演示数据隔离</span></span><br><span class=\"line\">127.0.0.1:6379[1]&gt; <span class=\"built_in\">set</span> <span class=\"built_in\">test</span> 1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379[1]&gt; select 2</span><br><span class=\"line\">Ok</span><br><span class=\"line\">127.0.0.1:6379[2]&gt; get <span class=\"built_in\">test</span></span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure>\n<p>可以通过命令之前的部分区分我们所在的数据库.<br>\n <code>127.0.0.1:6379[2]&gt; select 2</code>  执行这个命令的时候，我们是在数据库 <code>1</code>  中的。</p>\n<ul>\n<li>使用  <code>flushdb</code>  只能删除 <b>该数据库 (一个库)</b> 中的数据。</li>\n<li>使用  <code>flushall</code>  可以删除 <b>所有库</b> 中的数据。</li>\n</ul>\n<h2 id=\"redis使用分库的意义\"><a class=\"markdownIt-Anchor\" href=\"#redis使用分库的意义\">#</a> redis 使用分库的意义</h2>\n<ul>\n<li>避免不同应用相同 <code>key</code>  的影响。</li>\n<li>更便于管理。<br>\n一个实例上运行多个库，只运维这一个实例就可以了。</li>\n<li>也有不少文章说，redis 的作者曾说过，“多数据库的设计可能是最糟糕的决定.”. Redis 是单线程的，即使是多数据库也不会带来性能提升。但是这个并没有和前面的两个好处冲突。下面是作者的原话:</li>\n</ul>\n<blockquote>\n<p>I understand how this can be useful, but unfortunately I consider Redis multiple database errors my worst decision in Redis design at all… without any kind of real gain, it makes the internals a lot more complex. The reality is that databases don’t scale well for a number of reason, like active expire of keys and VM. If the DB selection can be performed with a string I can see this feature being used as a scalable O(1) dictionary layer, that instead it is not.</p>\n</blockquote>\n<blockquote>\n<p>With DB numbers, with a default of a few DBs, we are communication better what this feature is and how can be used I think. I hope that at some point we can drop the multiple DBs support at all, but I think it is probably too late as there is a number of people relying on this feature for their work.</p>\n</blockquote>\n<h3 id=\"redis的分库是怎么实现\"><a class=\"markdownIt-Anchor\" href=\"#redis的分库是怎么实现\">#</a> Redis 的分库是怎么实现？</h3>\n<p><code>Redis</code>  服务器间所有的数据库都保存在 服务器状态  <code>redis.h/redisServer</code>  结构的 db 数组中。 <code>db</code>  数组中的每个元素都是一个  <code>redis.h/redisDb</code>  结构。每个 <code>redisDb</code>  结构代表一个数据库.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 保存所有数据库</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// 数据库的数量(redis.conf文件中 database配置的)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dbnum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个 <code>Redis</code>  客户端都有自己的目标数据库，每个客户端执行数据库写命令或者数据库读命令的时候，目标数据库都会成为这些命令的操作对象.<br>\n 每个客户端用  <code>RedisClient</code>  来描述。  <code>RedisClient</code>  结构的 <code>db</code>  属性记录了客户端当前的目标数据库，这个属性是一个指向  <code>redisDb</code>  的指针.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisClient</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录客户端端正在使用的数据库id</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure>\n<h4 id=\"举个例子\"><a class=\"markdownIt-Anchor\" href=\"#举个例子\">#</a> 举个例子:</h4>\n<p>假设我们客户端连接的是数据库 <code>1</code> , 那么客户端与服务器端之间的关系是这样的:</p>\n<p><img data-src=\"./images/00-01%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"00-01多数据库示意图\"></p>\n<p>如果我们运行  <code>select 2</code> , 其实，就是改变的 db 的指针。让它指向了  <code>db(2)</code> , 这就是  <code>select</code>  命令的运行原理。如下图。</p>\n<p><img data-src=\"./images/00-02%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"00-02多数据库示意图\"></p>\n<p>以上就是 关于  <code>Redis</code>  多数据库的内容了。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-Redis%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-Redis%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/",
            "title": "Redis 简介",
            "date_published": "2021-08-01T06:40:55.000Z",
            "content_html": "<p><code>Redis</code>  是一个开放源代码（ <code>BSD</code>  许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图 ( <code>bitMap</code> )，超日志 ( <code>hyperlog</code> )，带有半径查询和流的地理空间索引 ( <code>geohash</code> )。 <code>Redis</code>  还内置了副本， <code>Lua</code>  脚本， <code>LRU</code>  驱逐策略，事务和不同级别的磁盘持久性，并通过 <code>Redis Sentinel</code>  和 <code>Redis Cluster</code>  自动分区提供了高可用性。</p>\n<p><code>Redis</code>  还支持一下特性:</p>\n<ul>\n<li>事务</li>\n<li>发布 / 订阅模式</li>\n<li><code>lua</code>  脚本</li>\n<li>键值的允许生存时长.</li>\n<li><code>LRU</code>  驱逐</li>\n<li>故障自动转移</li>\n</ul>\n<h2 id=\"与其他数据库对比\"><a class=\"markdownIt-Anchor\" href=\"#与其他数据库对比\">#</a> 与其他数据库对比</h2>\n<p>与其他数据库的对比:</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Redis</th>\n<th>MongoDB</th>\n<th>Hbase</th>\n<th>Mysql</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据库类型</td>\n<td>NoSQL</td>\n<td>NOSQL</td>\n<td>NoSQL</td>\n<td>关系型数据库</td>\n</tr>\n<tr>\n<td>数据类型</td>\n<td>key-value, 提供 String,List,zet 等多种结构</td>\n<td>Collection.Document.BSON</td>\n<td>基于列模式的映射数据库，可表示简单的 key-value 的映射关系。</td>\n<td>DB.table.row/col</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>支持 (RDB/AOF)</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>是否支持集群</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>缓存 (内存稳定，读写性能极佳), 读多写少</td>\n<td>使用 Mysql 等关系型数据库，但是会遇到表结构不稳定的时候 (灵活)</td>\n<td>数据库大，特别大，列数据库，适合写多读少的场景</td>\n<td>常规的数据存储</td>\n</tr>\n<tr>\n<td>是否支持索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>是否支持事务</td>\n<td>支持</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Redis/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Redis/",
            "title": "Redis的单机部署",
            "date_published": "2021-08-01T06:38:55.000Z",
            "content_html": "<h1 id=\"源码安装\"><a class=\"markdownIt-Anchor\" href=\"#源码安装\">#</a> 源码安装</h1>\n<h2 id=\"下载地址\"><a class=\"markdownIt-Anchor\" href=\"#下载地址\">#</a> 下载地址</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2Rvd25sb2FkLnJlZGlzLmlvL3JlbGVhc2VzL3JlZGlzLTUuMC43LnRhci5neg==\">http://download.redis.io/releases/redis-5.0.7.tar.gz</span></p>\n<h2 id=\"安装步骤\"><a class=\"markdownIt-Anchor\" href=\"#安装步骤\">#</a> 安装步骤</h2>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar xvf redis-5.0.7.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">[root@fangjiaxiaobai <span class=\"built_in\">local</span>]<span class=\"comment\"># cd ./redis-5.0.7/</span></span><br><span class=\"line\">[root@fangjiaxiaobai redis-5.0.7]<span class=\"comment\"># make &amp;&amp; make install</span></span><br><span class=\"line\"></span><br><span class=\"line\">Hint: It<span class=\"string\">&#x27;s a good idea to run &#x27;</span>make <span class=\"built_in\">test</span><span class=\"string\">&#x27; ;)</span></span><br><span class=\"line\"><span class=\"string\"># 出现上面的提示代表成功了</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"可能出现以下错误\"><a class=\"markdownIt-Anchor\" href=\"#可能出现以下错误\">#</a> 可能出现以下错误:</h3>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh: cc: <span class=\"built_in\">command</span> not found</span><br><span class=\"line\">解决方案: yum install gcc</span><br><span class=\"line\"></span><br><span class=\"line\">jemalloc/jemalloc.h: No such file or directory</span><br><span class=\"line\">原因是jemalloc重载了Linux下的ANSI C的malloc和free函数。解决办法：make时添加参数。</span><br><span class=\"line\"></span><br><span class=\"line\">解决方案: make MALLOC=libc</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动\"><a class=\"markdownIt-Anchor\" href=\"#启动\">#</a> 启动</h3>\n<p>[root@fangjiaxiaobai ~]# cd /usr/local/redis-5.0.7/src/</p>\n<p>[root@fangjiaxiaobai init.d]# ./redis_6379 start</p>\n<h3 id=\"关闭\"><a class=\"markdownIt-Anchor\" href=\"#关闭\">#</a> 关闭</h3>\n<p>[root@fangjiaxiaobai src]# ./redis-cli -p 6379 shutdown</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/07/23/Redis%E7%B3%BB%E5%88%97/00-%E5%89%8D%E8%A8%80/",
            "url": "https://fangjiaxiaobai.github.io/2021/07/23/Redis%E7%B3%BB%E5%88%97/00-%E5%89%8D%E8%A8%80/",
            "title": "Redis 开篇杂谈",
            "date_published": "2021-07-23T06:28:55.000Z",
            "content_html": "<h2 id=\"杂谈\"><a class=\"markdownIt-Anchor\" href=\"#杂谈\">#</a> 杂谈</h2>\n<p>这里说些杂谈吧。</p>\n<p>以下的文章中，同一个名词并非代表的是同一种对象。比如 list。</p>\n<p>在 t_list.c 中，list 的表示的 面向于用户的 Redis 数据结构 List (列表)。而在 adlsit.c 中表示的 Redis 数据结构的底层实现 list (其实是链表这种数据结构 - 此处的数据结构，表示真实的数据结构)。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/07/23/Redis%E7%B3%BB%E5%88%97/00-%E7%9B%AE%E5%BD%95/",
            "url": "https://fangjiaxiaobai.github.io/2021/07/23/Redis%E7%B3%BB%E5%88%97/00-%E7%9B%AE%E5%BD%95/",
            "title": "Redis 开篇 & 说明",
            "date_published": "2021-07-23T06:18:55.000Z",
            "content_html": "<p>本系列学习笔记以  <code>redis5.0.7</code>  版本为基础进行学习.</p>\n<ul>\n<li><code>2021-07-21 Redis 6.0.6</code></li>\n<li><code>2019-12-19 Redis 6.x</code>  开始发布，具体内容: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2FudGlyZXovcmVkaXMvNi4wLzAwLVJFTEVBU0VOT1RFUw==\">Redis 6.x 版本发布明细</span></li>\n</ul>\n<h2 id=\"开篇说明\"><a class=\"markdownIt-Anchor\" href=\"#开篇说明\">#</a> 开篇 &amp; 说明</h2>\n<ul>\n<li><a href=\"/2021/07/23/Redis%E7%B3%BB%E5%88%97/00-%E5%89%8D%E8%A8%80/\">Redis 开篇 &amp; 说明 </a></li>\n</ul>\n<h2 id=\"新手入门\"><a class=\"markdownIt-Anchor\" href=\"#新手入门\">#</a> 新手入门</h2>\n<h3 id=\"基础概念\"><a class=\"markdownIt-Anchor\" href=\"#基础概念\">#</a> 基础概念</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"><label for=\"cbx_0\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-Redis%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94/\">Redis 简介及其他数据库对比</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\"><label for=\"cbx_1\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/02-Redis%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/\">Redis 的多个数据库</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\"><label for=\"cbx_2\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/01-%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Redis/\">Redis 的单机部署</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\"><label for=\"cbx_3\"> Redis 的集群部署 (源码安装 /docker 安装)</label></li>\n</ul>\n<h3 id=\"五种常用的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#五种常用的数据类型\">#</a> 五种常用的数据类型</h3>\n<blockquote>\n<p>常用的命令以及浅浅的了解内部结构。</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\"><label for=\"cbx_4\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BString/\">Redis 数据结构之  <code>String</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\"><label for=\"cbx_5\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-2-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/\">Redis 数据结构之  <code>List</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_6\" checked=\"true\" disabled=\"true\"><label for=\"cbx_6\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/\">Redis 数据结构之  <code>Hash</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_7\" checked=\"true\" disabled=\"true\"><label for=\"cbx_7\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-4-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88set/\">Redis 数据结构之集合  <code>Set</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_8\" checked=\"true\" disabled=\"true\"><label for=\"cbx_8\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-5-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset/\">Redis 数据结构之有序集合  <code>Zset</code> </a></label></li>\n</ul>\n<h3 id=\"知道会很牛逼的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#知道会很牛逼的数据类型\">#</a> 知道会很牛逼的数据类型</h3>\n<blockquote>\n<p>常用的命令以及浅浅的了解内部结构。</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_9\" checked=\"true\" disabled=\"true\"><label for=\"cbx_9\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-6-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E4%BD%8D%E5%9B%BEbitmap/\">Redis 数据结构之位图  <code>BitMap</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_10\" checked=\"true\" disabled=\"true\"><label for=\"cbx_10\"> <a href=\"/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-7-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BHyperLogLogs/\">Redis 数据结构之  <code>HyperLogLogs</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" disabled=\"true\"><label for=\"cbx_11\"> GeoHash</label></li>\n</ul>\n<h3 id=\"其他命令\"><a class=\"markdownIt-Anchor\" href=\"#其他命令\">#</a> 其他命令</h3>\n<blockquote>\n<p>除了基本的数据结构之外的 <code>Redis</code>  的命令。</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_12\" disabled=\"true\"><label for=\"cbx_12\"> help</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_13\" disabled=\"true\"><label for=\"cbx_13\"> auth</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_14\" disabled=\"true\"><label for=\"cbx_14\"> scan</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_15\" disabled=\"true\"><label for=\"cbx_15\"> keys</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_16\" disabled=\"true\"><label for=\"cbx_16\"> select</label></li>\n</ul>\n<h2 id=\"内功心法\"><a class=\"markdownIt-Anchor\" href=\"#内功心法\">#</a> 内功心法</h2>\n<h3 id=\"redis中的数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis中的数据结构\">#</a> Redis 中的数据结构</h3>\n<blockquote>\n<p><code>Redis</code>  内部的数据结构详解</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_17\" checked=\"true\" disabled=\"true\"><label for=\"cbx_17\"> <a href=\"/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-4-%E8%B7%B3%E8%A1%A8/\">Redis 中的数据结构之跳表及其原理</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_18\" checked=\"true\" disabled=\"true\"><label for=\"cbx_18\"> <a href=\"/2021/08/02/Redis%E7%B3%BB%E5%88%97/C-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8Bziplist/\">Redis 数据结构之详解 <code>ziplist</code> </a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_19\" disabled=\"true\"><label for=\"cbx_19\"> intset</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_20\" disabled=\"true\"><label for=\"cbx_20\"> dict</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_21\" disabled=\"true\"><label for=\"cbx_21\"> skiplist</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_22\" disabled=\"true\"><label for=\"cbx_22\"> module object</label></li>\n</ul>\n<blockquote>\n<p>高阶 <code>Redis</code>  使用，助力成为大牛</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_23\" disabled=\"true\"><label for=\"cbx_23\"> Redis 的数据淘汰机制</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_24\" disabled=\"true\"><label for=\"cbx_24\"> 持久化策略</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_25\" disabled=\"true\"><label for=\"cbx_25\"> 主从复制</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_26\" disabled=\"true\"><label for=\"cbx_26\"> 事务机制</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_27\" disabled=\"true\"><label for=\"cbx_27\"> 哨兵机制</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_28\" disabled=\"true\"><label for=\"cbx_28\"> 监察器</label></li>\n</ul>\n<h2 id=\"实战与应用\"><a class=\"markdownIt-Anchor\" href=\"#实战与应用\">#</a> 实战与应用</h2>\n<blockquote>\n<p>说的再多，不如动手练练</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_29\" disabled=\"true\"><label for=\"cbx_29\"> Redis 实现分布式锁。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_30\" disabled=\"true\"><label for=\"cbx_30\"> Redis 实现发布订阅模式</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_31\" disabled=\"true\"><label for=\"cbx_31\"> 布隆过滤器</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_32\" disabled=\"true\"><label for=\"cbx_32\"> 限流实例</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_33\" disabled=\"true\"><label for=\"cbx_33\"> 延时队列</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_34\" disabled=\"true\"><label for=\"cbx_34\"> 统计 PV</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_35\" disabled=\"true\"><label for=\"cbx_35\"> 限流</label></li>\n</ul>\n<h2 id=\"运维\"><a class=\"markdownIt-Anchor\" href=\"#运维\">#</a> 运维</h2>\n<blockquote>\n<p>不让别人擦屁股</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_36\" disabled=\"true\"><label for=\"cbx_36\"> 配置文件详解</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_37\" disabled=\"true\"><label for=\"cbx_37\"> 数据持久化</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_38\" disabled=\"true\"><label for=\"cbx_38\"> 数据迁移</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_39\" disabled=\"true\"><label for=\"cbx_39\"> 再谈集群</label></li>\n</ul>\n<h2 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\">#</a> 其他</h2>\n<blockquote>\n<p>不仅要有内涵，更要有颜值。</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_40\" disabled=\"true\"><label for=\"cbx_40\">  <code>Redis</code>  面试题</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_41\" disabled=\"true\"><label for=\"cbx_41\">  <code>Redis</code>  为什么这么快</label></li>\n</ul>\n<h2 id=\"学习路线图\"><a class=\"markdownIt-Anchor\" href=\"#学习路线图\">#</a> 学习路线图</h2>\n<blockquote>\n<p>这里是灯塔。</p>\n</blockquote>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_42\" disabled=\"true\"><label for=\"cbx_42\"> 路线图</label></li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "目录",
                "Redis"
            ]
        }
    ]
}