{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"数据结构与算法\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "title": "冒泡排序",
            "date_published": "2021-09-01T04:47:55.000Z",
            "content_html": "<h2 id=\"基本思想\"><a class=\"markdownIt-Anchor\" href=\"#基本思想\">#</a> 基本思想</h2>\n<p>每次都操作两个相邻的数据。每次冒泡操作都对相邻的两个数据进行比较，看是否满足大小关系要求，如果不满足，就进行互换。每次冒泡都会冒出一个最小 / 大值，并移动到它应该在的位置。重复 n 次，就完成了对 n 个数据的排序工作.</p>\n<h2 id=\"排序逻辑图\"><a class=\"markdownIt-Anchor\" href=\"#排序逻辑图\">#</a> 排序逻辑图</h2>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序01-冒泡法排序01\"></p>\n<p>这里在详细的写一下第一次排序的过程：</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F02.png\" alt=\"算法01-排序01-冒泡法排序02.png\"></p>\n<p>按照以上逻辑的代码实现</p>\n<h2 id=\"算法实现\"><a class=\"markdownIt-Anchor\" href=\"#算法实现\">#</a> 算法实现</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; length-i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j - <span class=\"number\">1</span>] &gt; a[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j - <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">                a[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种实现，在这种情景下，就会浪费时间。</p>\n<p>如果原始数组为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5,0,1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>排序过程如下:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F03.png\" alt=\"算法01-排序01-冒泡法排序03.png\"></p>\n<p>可以发现，在完成第一趟排序的时候，实际上已经是正确的排序结果了。我们可以采用下面的方式进行优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; length - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j - <span class=\"number\">1</span>] &gt; a[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j - <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">                a[j] = temp;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出:</p>\n<ul>\n<li>冒泡排序是基于比较，交换的排序算法。</li>\n<li>冒泡排序使用的空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, 是一个原地排序算法。</li>\n<li>以上代码实现的冒泡算法是稳定的排序算法.  <code>if(a[i]&lt;=a[j])</code>  就是一个不稳定的排序算法了.</li>\n<li>冒泡算法最好情况下的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, 最坏情况下的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. 那平均情况下的时间复杂度怎么计算呢？</li>\n</ul>\n<h2 id=\"计算平均情况下的时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#计算平均情况下的时间复杂度\">#</a> 计算平均情况下的时间复杂度</h2>\n<p>这里，我们引入三个概念</p>\n<ul>\n<li>有序元素对：如果  <code>i&lt;j</code>  , 并且  <code>a[i]&lt;a[j]</code> , 那么这个一对儿数就是有序的。</li>\n<li>逆序元素对：如果  <code>i&lt;j</code>  , 并且  <code>a[i]&gt;a[j]</code> , 那么这个一对儿数就是逆序的。</li>\n<li>有序度：数组中具有有序关系的元素对的个数.</li>\n<li>满有序度：完全有序的数列。</li>\n</ul>\n<p>其中  <code>满有序度</code>  =  <code>有序度</code>  +  <code>逆序度</code> 。</p>\n<p>举个例子:</p>\n<p><strong> <code>[4,5,6,3,2,1]</code> </strong></p>\n<p>有序度为 3, 也称为 <em>原始有序度</em>, 分别为:  <code>(4,5)</code>   <code>(4,6)</code>   <code>(5,6)</code></p>\n<p>满有序度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">\\frac {n*(n-1)}{2}=15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">∗</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span></p>\n<p>冒泡排序中包含两个操作原子，比较和交换。没交换一次，有序度就会加 1. 所以，交换次数，就是逆有序度。 那么， <code>逆有序度 = 满有序度 - 初始有序度</code> 。也就是: 15 - 3 = 12. 需要进行 12 次操作。</p>\n<p>平均情况下，要进行<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>4</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac {n*(n-1)}{4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">∗</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 次操作。比较操作肯定要比交换操作多，而最坏情况下的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 所以平均情况下的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "冒泡排序",
                "交换排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E6%A1%B6%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E6%A1%B6%E6%8E%92%E5%BA%8F/",
            "title": "桶排序",
            "date_published": "2021-09-01T04:42:55.000Z",
            "content_html": "<h2 id=\"排序思想\"><a class=\"markdownIt-Anchor\" href=\"#排序思想\">#</a> 排序思想</h2>\n<p>把将要排序的数据分到几个有序的桶里，每个同理的数据再单独进行排序，桶内拍完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了.</p>\n<h2 id=\"排序实现逻辑\"><a class=\"markdownIt-Anchor\" href=\"#排序实现逻辑\">#</a> 排序实现逻辑</h2>\n<p><span class=\"label danger\">💔内容太饿了，离家出走了…</span></p>\n<h2 id=\"桶排序算法实现\"><a class=\"markdownIt-Anchor\" href=\"#桶排序算法实现\">#</a> 桶排序算法实现</h2>\n<p><span class=\"label danger\">💔内容太饿了，离家出走了…</span></p>\n<h2 id=\"算法评估\"><a class=\"markdownIt-Anchor\" href=\"#算法评估\">#</a> 算法评估</h2>\n<ul>\n<li>桶排序的时间复杂度为: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>桶排序不是稳定的排序算法</li>\n</ul>\n<h2 id=\"时间复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度分析\">#</a> 时间复杂度分析</h2>\n<p>如果要排序的数据有 n 个，我们把它们均匀的分到 m 个桶内，每个桶里就有 k=n/m 个元素，每个桶内部使用快速排序，时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k*logk)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>。 m 个桶排序的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m*k*logk)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>. 因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">k = n / m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">m</span></span></span></span>, 所以整个桶排序的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">O(n*log{\\frac{n}{m}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span>). 当桶的个数 m 接近数据个数 n 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">log\\frac{n}{m}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 就是一个非常小的常量，这个时候，桶排序的时间复杂度接近 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>桶排序的对排序数据的要求非常苛刻。</p>\n<ul>\n<li>要排序的数据要很容易就能划分为 m 个桶，并且 桶与桶 之间要有着天然的大小顺序.</li>\n<li>数据要在各个同之间的分布时比较均匀的。 如果经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不均匀，那桶内数据排序的时间复杂度就不是一个常量级了。在极端的情况下，所有的数据都被划分到一个桶里，那就退化为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的排序算法了.</li>\n</ul>\n<p>桶排序比较适合永载外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限， 无法把数据全部加载到内存中。 下面说一个例子</p>\n<h2 id=\"桶排序的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#桶排序的应用场景\">#</a> 桶排序的应用场景</h2>\n<p>假如我们有 10GB 的订单数据，我们希望 按照订单的金额进行排序，可是内存有限，只有几百 MB, 怎么进行排序呢？</p>\n<p>我们可以先扫描一遍文件，看订单金额所在的数据范围。 假设扫描完毕之后，我们最小的金额是 1 元，最大的时 10 万元，我们将其分为 100 个桶，第一个存 1-1000 元，第二个存 1000-2000，并且，每个桶要按照金额大小命名 (00,01,02…)，依次对每个桶，进行排序就好了.</p>\n<p>如果，这个 10GB 的数据是分布不均匀的，就会造成某些文件特大。我们还可以对大的文件进行拆分。继续讲这个区间的文件拆成 100 个，如果还不能，再进行拆分。知道这个文件都可以读入内存为止。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "桶排序",
                "线性思想排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/",
            "title": "快速排序",
            "date_published": "2021-09-01T04:39:55.000Z",
            "content_html": "<h2 id=\"快速排序思想\"><a class=\"markdownIt-Anchor\" href=\"#快速排序思想\">#</a> 快速排序思想</h2>\n<p>快速排序的核心思想也是 分治思想。</p>\n<p>快速排序主要要以待排数组中的某个数字为基准。将整个数组中的数据分为小于基准的一组和大于等于基于的一组.(或者是小于等于基准的一组和大于基于的一组), 分别对每组进行拆分，直到每组中只有一个数据。</p>\n<p>递推公式如下:</p>\n<p>假设 <code>low</code>  为待排数组中的起始索引. <code>high</code>  为待排数组中的终止索引.  <code>std</code>  为基准的索引.</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>q</mi><mi>u</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>S</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator=\"true\">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>q</mi><mi>u</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>S</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator=\"true\">,</mo><mi>s</mi><mi>t</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>q</mi><mi>u</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>S</mi><mi>o</mi><mi>r</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>t</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">quickSort(low,high) = quickSort(low,std-1)+quickSort(std+1,high)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>终止条件为:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>&gt;</mo><mo>=</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">low&gt;=high\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span></span></span></span></span></p>\n<h2 id=\"排序过程图\"><a class=\"markdownIt-Anchor\" href=\"#排序过程图\">#</a> 排序过程图</h2>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F04-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序04-快速排序01.png\"></p>\n<p>简单解释下:</p>\n<p>我们首先选定基准，假设以本次递归的第一个数为基准，进行排序.<br>\n 如图：第一次递归的基准为 5, 我把大于 5 的数，放在右侧，小于 5 的数放在左侧，(例子中没有大约 5 的数)，第二次以 0 为基准，把大于 0 的数，放在右侧，小于 0 的数，放在左侧。重复这样的逻辑，直到最后一次递归。</p>\n<h2 id=\"排序代码实现\"><a class=\"markdownIt-Anchor\" href=\"#排序代码实现\">#</a> 排序代码实现</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quick_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = high;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">std</span> = a[low];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i&lt;j&amp;&amp;a[j] &gt;= <span class=\"built_in\">std</span>) &#123;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[j] &lt; <span class=\"built_in\">std</span>) &#123;</span><br><span class=\"line\">            a[i++] = a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i&lt;j&amp;&amp;a[i] &lt;= <span class=\"built_in\">std</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] &gt; <span class=\"built_in\">std</span>) &#123;</span><br><span class=\"line\">            a[j--] = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a[i] = <span class=\"built_in\">std</span>;</span><br><span class=\"line\">    quick_sort(a, low, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    quick_sort(a, i + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序的优化\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的优化\">#</a> 快速排序的优化</h2>\n<p>之前说， 快速排序的时间复杂度退化到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的主要原因是：分区点选的不够合理.</p>\n<p>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多.</p>\n<p>为了提高排序算法的性能，我们也要尽可能的让每次分区都比较均匀.</p>\n<p>比较常用，比较简单的选择分区点的方法有:</p>\n<ul>\n<li>三数取中法</li>\n</ul>\n<p>我们从某个区间的首，尾，中间， 分别取出一个数，然后对比大小，取这三个数据的中间值作为分区点。 也可以多取几个区间，取出中间值，然后在这些中间值，取出中间值。比如三数取中，五数取中，十数取中等等。</p>\n<ul>\n<li>随机法</li>\n</ul>\n<p>每次都从排序的区间中随机选择一个元素作为分区点。</p>\n<p>这种方式，并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选的很差的情况。所以时间复杂度退化为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的情况，可能性也不大。</p>\n<h2 id=\"快排算法评估\"><a class=\"markdownIt-Anchor\" href=\"#快排算法评估\">#</a> 快排算法评估</h2>\n<ul>\n<li>时间复杂度为 最好情况下为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, 最坏情况下为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 平均情况下的时间复杂度为:</li>\n<li>空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, 是一种原地排序算法</li>\n<li>是一种不稳定的排序算法.</li>\n</ul>\n<p>注意：快排算法虽然在最坏情况下的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> , 但是在平均情况下，时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，不尽如此，快排的时间复杂度退化到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的概率非常小，我们也可以通过合理选择基准的方式来避免这总情况.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "快速排序",
                "分支思想排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "一致性哈希算法的实现",
            "date_published": "2021-09-01T04:36:55.000Z",
            "content_html": "<p>上一篇介绍了 哈希算法和一致性哈希算法的原理，我们知道哈希算法在分布式场景应用中存在着定位问题。所有有一致性哈希算法。<br>\n今天我们就动手实现以下哈希算法。</p>\n<p>可选性 回顾一下 <b><a href=\"/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/\">哈希算法和一致性哈希算法</a></b></p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\">#</a> 说明</h1>\n<p>以下多次出现服务端节点，客户端节点这两个名字，含义如下：</p>\n<p>服务端节点： 在实际场景中，比如分布式缓存，上一篇文章中的例子，服务端节点就是多个 Redis 机器。</p>\n<p>客户端节点： 就是要缓存的数据，这里使用这两个名词来代表不同的两个部分。</p>\n<h1 id=\"实现功能\"><a class=\"markdownIt-Anchor\" href=\"#实现功能\">#</a> 实现功能</h1>\n<p>以上篇中提及的分布式缓存的例子为背景实现一致性哈希算法，主要实现两个功能：</p>\n<ul>\n<li>\n<p>新增服务节点</p>\n<p>创建一个哈希环，然后可以存放服务端节点信息。后续新增节点也能正常存储。</p>\n</li>\n<li>\n<p>根据客户端节点找到对应的服务节点</p>\n<p>传入客户端的信息，我们可以根据 client 的信息或者其他的信息进行哈希运算，然后确定存储的服务端节点。</p>\n</li>\n<li>\n<p>实现根据服务端节点进行删除</p>\n<p>模拟实现部分服务端不可用。即例子中的缓存节点挂掉。</p>\n</li>\n</ul>\n<h1 id=\"实现方案\"><a class=\"markdownIt-Anchor\" href=\"#实现方案\">#</a> 实现方案</h1>\n<p>首先我们需要定义一个接口规范，规定好要实现的内容，比如，保存服务端节点信息，即新增操作，根据客户端节点找到服务节点的功能，即查询操作。</p>\n<h2 id=\"排序list的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#排序list的实现方式\">#</a> 排序 + List 的实现方式</h2>\n<p>主要思路如下： 将所有的节点保存到一个 List 中。然后对 List 进行<b>排序</b>，当获取服务端节点的时候，只需要找到第一个 哈希值比他大的服务端节点的就可以了。</p>\n<p>不考虑排序的时间复杂度： 最优时间复杂度：O (1)，第一个节点就是目标节点。最坏情况下：O (n+1), 招了一圈都没有找到。所以平均的时间复杂度是 O (N)。<br>\n那排序的时间复杂度呢？最快的就是 O (NlogN);</p>\n<p>综合下来，这种实现方案的时间复杂度就是： O (NlogN)。</p>\n<p>主要实现代码如下 (文末完整代码，注释颇多)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortListConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash环容器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;NodeBucket&gt; hashCircle = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认使用 &#123;<span class=\"doctag\">@link</span> ConsistentHash#hash &#125;算法实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(HashHandle&lt;Node&gt; hashHandle, Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新增服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashCircle == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hashCircle = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            value.setVirtualNodeId(i);</span><br><span class=\"line\">            hashCircle.add(DefaultNodeBucket.of(value, (node) -&gt; hashHandle.hash(value)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        hashCircle.sort(Comparator.comparingInt(NodeBucket::getHash));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 找不到符合条件的第一个节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientNode 根据 客户端节点的Hash值获取到目标服务端节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Integer hash = hash(clientNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;NodeBucket&gt; first = hashCircle.stream().filter(item -&gt; item.getHash() &gt; hash).findFirst();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.map(NodeBucket::getNode).orElse(hashCircle.get(<span class=\"number\">0</span>).getNode());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取所有服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 所有服务端节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.hashCircle.stream().map(NodeBucket::getNode).collect(Collectors.toList());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> node 节点的信息,可能是客户端，也可能是服务端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 哈希值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle.remove(DefaultNodeBucket.of((ServerNode) node, hashHandle));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性表遍历的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#线性表遍历的实现方式\">#</a> 线性表遍历的实现方式</h2>\n<p>首先说明一下，这里使用的是线性表遍历的方式，并没有指定说使用的数组还是链表，根据具体场景来选择吧，实现方式略有不同。我用数组的形式来实现。</p>\n<p>上一种实现方式，使用了排序导致了时间复杂度为 O (NlogN)。那么我不用排序行不行？</p>\n<p>可以的！我们首先将服务端节点保存到数组中，然后根据客户端哈希值和服务端节点哈希值的差，找出最小的那个节点就可以了。每次遍历实现的话，遍历一次就可以了，时间复杂度为 O (N).</p>\n<p>主要实现逻辑代码如下（文末有完整实现代码，注释颇多）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraverseArrayConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用数组实现的哈希环</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeBucket[] hashCircle = <span class=\"keyword\">new</span> NodeBucket[]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> defaultSize = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MaxSize = Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity, Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity, Integer virtualNumber, HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode serverNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查大小是否需要扩容</span></span><br><span class=\"line\">        checkSize();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            serverNode.setVirtualNodeId(i);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle[length++] = DefaultNodeBucket.of(serverNode, hashHandle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = defaultSize;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt;= MaxSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length + <span class=\"number\">1</span> &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = size &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = Arrays.copyOf(<span class=\"keyword\">this</span>.hashCircle, size, NodeBucket[].class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.equals(hashCircle[index].getNode())) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(hashCircle, index+<span class=\"number\">1</span>, hashCircle, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        hashCircle[--size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        Integer hash = <span class=\"keyword\">this</span>.hashHandle.hash(clientNode);</span><br><span class=\"line\">        ServerNode findNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// 查找符合条件的服务端节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            NodeBucket nodeBucket = <span class=\"keyword\">this</span>.hashCircle[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> difference;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((difference = Math.abs(nodeBucket.getHash() - hash)) &lt; min) &#123;</span><br><span class=\"line\">                min = difference;</span><br><span class=\"line\">                findNode = nodeBucket.getNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Stream.of(<span class=\"keyword\">this</span>.hashCircle).map(NodeBucket::getNode).collect(Collectors.toList());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"sortedmap实现方案\"><a class=\"markdownIt-Anchor\" href=\"#sortedmap实现方案\">#</a> SortedMap 实现方案</h2>\n<p>上面两种的实现方案，并非是最优的。根本原因就是<b>数据结构</b>的限制。 线性表决定了这一切。我们考虑换一种数据结构呢？</p>\n<p>考虑下使用<b>树</b>形结构</p>\n<p>最快的树形数据结构，就是二叉平衡树了。二叉平衡树有两种 AVL 树和红黑树。</p>\n<p>我们使用红黑树，因为红黑树的主要功能就是存储<b>有序的数据</b>，并且查询地效率是 O (logN)。</p>\n<p>考虑到手写实现一个红黑树，着实有点复杂，这种我们使用 JDK 中的 TreeMap 来实现。</p>\n<p>将所有的服务节点放到 TreeMap 中，这种结构天然支持排序的，所以我们只需要主要的实现找到服务节点的这个过程就好了。</p>\n<p>首先计算出客户端的哈希值，查询出大于该哈希值的服务节点的子序列，如果子序列为空返回原来哈希环的第一个元素，否则，返回子序列的第一个元素即可。</p>\n<p>主要实现代码如下 (文末有完整代码，注释真的多！)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedMapConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SortedMap&lt;Integer, ServerNode&gt; hashCircle = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">        hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">(<span class=\"keyword\">int</span> virtualNumber, HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">(<span class=\"keyword\">int</span> virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode serverNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现虚拟节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            serverNode.setVirtualNodeId(i);</span><br><span class=\"line\">            hashCircle.put(<span class=\"keyword\">this</span>.hashHandle.hash(serverNode), serverNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashCircle.remove(hashHandle.hash(node));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash = hash(clientNode);</span><br><span class=\"line\">        <span class=\"comment\">// 获取大于客户端哈希值的子序列</span></span><br><span class=\"line\">        SortedMap&lt;Integer, ServerNode&gt; subMap = hashCircle.tailMap(hash);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subMap.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子序列为空，获取哈希环的第一个节点</span></span><br><span class=\"line\">            Integer key = hashCircle.firstKey();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hashCircle.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子序列不为空，获取子序列的第一个节点</span></span><br><span class=\"line\">            Integer key = subMap.firstKey();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subMap.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"keyword\">this</span>.hashCircle.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">process</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirstNode(clientNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\">最后，我们测试一下,一致性哈希算法的结果:</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        testSortListConsistentHash();</span><br><span class=\"line\">        testSortedMapConsistentHash();</span><br><span class=\"line\">        testTraverseArrayConsistentHash();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用遍历的方式来实现一致性hash算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testTraverseArrayConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConsistentHash sortedMapConsistentHash = <span class=\"keyword\">new</span> TraverseArrayConsistentHash();</span><br><span class=\"line\">        testConsistentHashCommonPart(sortedMapConsistentHash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用SortMap实现的一致性哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSortedMapConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConsistentHash sortedMapConsistentHash = <span class=\"keyword\">new</span> SortedMapConsistentHash(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testConsistentHashCommonPart(sortedMapConsistentHash);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用数组和排序方式实现的 一致性哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSortListConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SortListConsistentHash sortListConsistentHashMap = <span class=\"keyword\">new</span> SortListConsistentHash();</span><br><span class=\"line\">        testConsistentHashCommonPart(sortListConsistentHashMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试 consistentHash 算法，公共代码部分</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> consistentHash 一致性哈希实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testConsistentHashCommonPart</span><span class=\"params\">(ConsistentHash consistentHash)</span> </span>&#123;</span><br><span class=\"line\">        Stream.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.1&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain1.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.2&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain2.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.3&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain3.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.4&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain4.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.5&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain5.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.6&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain6.com&quot;</span>)</span><br><span class=\"line\">        ).forEach(consistentHash::add);</span><br><span class=\"line\">        String s1 = UUID.randomUUID().toString();</span><br><span class=\"line\">        ServerNode serverNode1 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(s1));</span><br><span class=\"line\">        out.println(serverNode1);</span><br><span class=\"line\">        ServerNode serverNode1_1 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(s1));</span><br><span class=\"line\">        out.println(serverNode1_1);</span><br><span class=\"line\">        ServerNode serverNode1_2 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(UUID.randomUUID().toString()));</span><br><span class=\"line\">        out.println(serverNode1_2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试完成之后，我还对各种方案就进行了性能相关的简单测试，硬件: windows 8 核 16G,i7.<br>\n 测试代码就不贴出来了，查看原文去看吧。</p>\n<p>总结如下：</p>\n<p>在节点数 小于 10000 的场景下： 数组遍历 &gt; SortedMap &gt; 排序。 即：方案 2 &gt; 方案 3 &gt; 方案 1。<br>\n在服务端节点数 大于 10000 的场景下： SortedMap &gt; 数组变量 &gt; 排序。即： 方案 3 &gt; 方案 2 &gt; 方案 1.</p>\n<h1 id=\"附录\"><a class=\"markdownIt-Anchor\" href=\"#附录\">#</a> 附录</h1>\n<div class=\"links\"><div class=\"item\" title=\"fangxiaobai\" style=\"--block-color:#e0b971;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2NvZGVfcmVwby90cmVlL21hc3Rlci8wM18lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTclOUIlQjglRTUlODUlQjMvJUU0JUI4JTgwJUU4JTg3JUI0JUU2JTgwJUE3JUU1JTkzJTg4JUU1JUI4JThDJUU3JUFFJTk3JUU2JUIzJTk1L2NvbnNpc3RlbnRfaGFzaC9zcmM=\" data-background-image=\"https://avatars.githubusercontent.com/u/22616214?v=4\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2NvZGVfcmVwby90cmVlL21hc3Rlci8wM18lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTclOUIlQjglRTUlODUlQjMvJUU0JUI4JTgwJUU4JTg3JUI0JUU2JTgwJUE3JUU1JTkzJTg4JUU1JUI4JThDJUU3JUFFJTk3JUU2JUIzJTk1L2NvbnNpc3RlbnRfaGFzaC9zcmM=\">代码仓库 - 一致性Hash算法的实现</span>\n          <p class=\"desc\">欢迎star!! 期待你的加入~</p>\n          </div></div></div>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "哈希算法"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
            "title": "排序算法",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<h2 id=\"排序算法开篇\"><a class=\"markdownIt-Anchor\" href=\"#排序算法开篇\">#</a> 排序算法开篇</h2>\n<p>排序算法有很多，比如常见的 冒泡排序，插入排序，选择排序，归并排序，快速排序，计数排序，基数排序，桶排序，还有不常见的猴子排序，睡眠排序，面条排序等。</p>\n<p>其中，冒泡排序，插入排序，选择排序 的时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<p>快排，归并排序 的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>桶排序，计数排序，基数排序的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"排序算法好坏的评估\"><a class=\"markdownIt-Anchor\" href=\"#排序算法好坏的评估\">#</a> 排序算法好坏的评估</h2>\n<ul>\n<li>\n<p>最好情况，最坏情况，平均情况的时间复杂度<br>\n我们要知道排序算法在不同数据下的性能表现。</p>\n</li>\n<li>\n<p>时间复杂度的系数，常数，低阶<br>\n时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候，会忽略系数，常数，低阶。但是我排序的时候，涉及到的数据是很小规模的，所以我们需要考虑下系数，常数，低阶。</p>\n</li>\n<li>\n<p>比较次数和交换 (移动) 次数<br>\n在基于比较的排序算法的执行过程中，最多的会涉及两种操作，元素比较大小和元素交换或移动.</p>\n</li>\n<li>\n<p>内存消耗<br>\n即空间复杂度。</p>\n</li>\n<li>\n<p>排序算法的稳定性<br>\n稳定性是指：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。<br>\n这样的排序算法有什么好处呢？</p>\n<p>假设有这样一个需求，对一些学生的成绩进行排序。按照总成绩从大到小的顺序进行排列。总成绩相等的按照数学成绩从大到小的顺序进行排列。这时，我们就可以使用稳定的排序算法。先按照数学成绩从大到小的顺序进行排列，这样保证了数学成绩是有序的，然后我们再对总成绩进行排序，这样就满足了整体需求了.</p>\n</li>\n</ul>\n<h2 id=\"排序算法实现\"><a class=\"markdownIt-Anchor\" href=\"#排序算法实现\">#</a> 排序算法实现</h2>\n<h3 id=\"交换思想排序\"><a class=\"markdownIt-Anchor\" href=\"#交换思想排序\">#</a> 交换思想排序</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"><label for=\"cbx_0\"> 👉 <a href=\"/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/\">冒泡排序</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\"><label for=\"cbx_1\"> 👉 <a href=\"/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/\">选择排序</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" disabled=\"true\"><label for=\"cbx_2\"> 插入排序</label></li>\n</ul>\n<h3 id=\"分治思想排序\"><a class=\"markdownIt-Anchor\" href=\"#分治思想排序\">#</a> 分治思想排序</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\"><label for=\"cbx_3\"> 👉 <a href=\"/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/\">归并排序</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\"><label for=\"cbx_4\"> 👉 <a href=\"/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/\">快速排序</a></label></li>\n</ul>\n<h3 id=\"线性排序\"><a class=\"markdownIt-Anchor\" href=\"#线性排序\">#</a> 线性排序</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" disabled=\"true\"><label for=\"cbx_5\"> 👉 <a href=\"/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E6%A1%B6%E6%8E%92%E5%BA%8F/\">桶排序 (Bubble Sort)</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_6\" disabled=\"true\"><label for=\"cbx_6\"> 计数排序 (Counting Sort)</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_7\" disabled=\"true\"><label for=\"cbx_7\"> 基数排序 (Radix Sort)</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_8\" disabled=\"true\"><label for=\"cbx_8\"> 堆排序</label></li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/",
            "title": "归并排序",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<p>将数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排好序的两部分合并在一起，这样整个数组就是有序的了。</p>\n<p>归并体现的思想就是 <strong>分治思想</strong> 分而治之，将一个大问题分解成小的问题来解决。小问题解决了，大问题也就解决了.</p>\n<p>这种分治的算法，一般都是递归的方式来求解。我们也尝试着写一个递归方式的归并排序。</p>\n<p>写递归的程序，最重要的就是写 <strong>递推表达式</strong>和<strong>查找临界条件</strong></p>\n<p>根据归并排序的思想我们可写出这样的递推公式:</p>\n<p>假设:  <code>low</code>  为待排序数组的最小的索引.  <code>high</code>  为待排序数组的最大索引.  <code>mid</code>  为  <code>(high+low)/2</code> <br>\n 那么:  <code>merge_sort(low,high) = merge(merge_sort(low,mid),merge_sort(mid+1,high))</code></p>\n<p>对某个数组 从下标  <code>low</code>  到  <code>high</code>  的排序，转换成了子问题 从 <code>low</code>  到  <code>mid</code>  的排序 和 从 <code>mid+1</code>  到 <code>high</code>  的排序。当这两个子问题排好序之后，再将两个有序的子数组合并在一起，这样下标从  <code>low</code>  到  <code>high</code>  之间的数据也就都是排好序的了。</p>\n<p>还有一个问题：终止条件是什么？终止条件就是 子问题中的  <code>low &gt;= high</code> , 这个时候，我们就可以终止递归了。</p>\n<h5 id=\"归并排序逻辑图\"><a class=\"markdownIt-Anchor\" href=\"#归并排序逻辑图\">#</a> 归并排序逻辑图</h5>\n<p>来一张归并排序过程的示意图吧</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F03-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序03-归并排序01\"></p>\n<h5 id=\"归并排序算法实现\"><a class=\"markdownIt-Anchor\" href=\"#归并排序算法实现\">#</a> 归并排序算法实现</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high, <span class=\"keyword\">int</span> mid)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp_arr_length = high - low + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t[temp_arr_length];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 判断大小</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt;= mid &amp;&amp; j &lt;= high;) &#123;</span><br><span class=\"line\">        t[m++] = a[i] &lt; a[j] ? a[i++] : a[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断分组数量不相等时的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt;= high) &#123;</span><br><span class=\"line\">        t[m++] = a[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断分组数量不相等时的情况   </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= mid) &#123;</span><br><span class=\"line\">        t[m++] = a[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将中间表的数据赋值给原始的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">        a[low + i] = t[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &gt;= high) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (low + high) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 归</span></span><br><span class=\"line\">    merge_sort(a, low, mid);</span><br><span class=\"line\">    merge_sort(a, mid + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    <span class=\"comment\">// 并</span></span><br><span class=\"line\">    merge(a, low, high, mid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"归并排序性能评估\"><a class=\"markdownIt-Anchor\" href=\"#归并排序性能评估\">#</a> 归并排序性能评估</h5>\n<ul>\n<li>归并排序是一个稳定的排序算法</li>\n<li>归并排序的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>归并排序的空间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<h5 id=\"归并排序时间复杂度的推算\"><a class=\"markdownIt-Anchor\" href=\"#归并排序时间复杂度的推算\">#</a> 归并排序时间复杂度的推算</h5>\n<p>归并排序这种实现方式的时间复杂度的推算，也就是对递归的时间复杂度的推算。</p>\n<p><strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式</strong></p>\n<p>递归的主要特征就是:<br>\n 一个问题 a, 可以拆分为多个子问题 b,c, 那么求解 a 问题就转换成了求解子问题 b,c。b 和 c 解决之后，我们就把 b,c 的结果合并成 a 的结果.</p>\n<p>那 我们假设 求解 a 问题的时间是 T (a), 求解问题 b,c 的时间为 T (b),T©, 那么我就可以得到这样的递推公式:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">T(a) = T(b) + T(c) + K\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span></p>\n<p>其中， <code>K</code>  是解决完子问题 <code>b</code> , <code>c</code>  之后，合并为 a 问题所需要的时间。 对于归并排序来讲， <code>K</code>  就是  <code>merge</code>  所需要的时间了.</p>\n<h5 id=\"那我们来详细的分析下归并排序时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#那我们来详细的分析下归并排序时间复杂度\">#</a> 那我们来详细的分析下归并排序时间复杂度:</h5>\n<p>假设:<br>\n 对 n 个元素，进行归并排序的时间为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br>\n 那么:<br>\n 分解成两个子数组排序的时间都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(n/2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span><br>\n merge 函数合并两个有序子数组的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>套用前面的公式:</p>\n<p>当 <code>n=1</code>  时: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">T(n) = C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, 常量级的执行时间.<br>\n 当 <code>n&gt;1</code>  时: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">T(n)=2*T(n/2)+n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.24999999999999992em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mn>4</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>4</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mn>8</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>8</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>16</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>=</mo><mn>16</mn><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>16</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>4</mn><mo>∗</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mfrac><mi>n</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo stretchy=\"false\">)</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>n</mi><mo separator=\"true\">;</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\nT(n) &amp;= 2*T(n/2)+n\\\\\n    &amp;= 2 * (2 * T(n/4) + n/2) + n = 4 * T(n/4) + 2 * n \\\\\n    &amp;= 4 * (2 * T(n/8) + n/4) + n = 8 * T(n/8) + 3 * n \\\\\n    &amp;= 8 * (2 * T(n/16) + n/8) + n = 16 * T(n/16) = 4 * n \\\\\n    &amp;= ....\\\\\n    &amp;= 2^k * T(\\frac{n}{2^k}) + k * n;\n\\end{aligned}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:9.593560000000004em;vertical-align:-4.546780000000002em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:5.046780000000001em;\"><span style=\"top:-7.314340000000001em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span><span style=\"top:-5.8143400000000005em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:-4.31434em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:-2.8143399999999996em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:-1.3143399999999996em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:0.4532200000000014em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:4.546780000000002em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:5.046780000000001em;\"><span style=\"top:-7.314340000000001em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-5.8143400000000005em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-4.31434em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">8</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">8</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.8143399999999996em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">8</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-1.3143399999999996em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span></span></span><span style=\"top:0.4532200000000014em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">;</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:4.546780000000002em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 就是分裂的次数。拆分子问题的次数.</p>\n<p>当 n=1, 则 k=0. , 即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mfrac><mi>n</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(1) = T(\\frac{n}{2^k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1074199999999998em;vertical-align:-0.3574199999999999em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.64258em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7820285714285713em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3574199999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span>, ==&gt; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{2^k}=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0528119999999999em;vertical-align:-0.3574199999999999em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.64258em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7820285714285713em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3574199999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, 那么 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">k=log_2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span></span></span></span></p>\n<p>将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 代入公式</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.24999999999999992em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><msup><mn>2</mn><mi>k</mi></msup><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mfrac><mi>n</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo stretchy=\"false\">)</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow></msup><mo>∗</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mfrac><mi>n</mi><msup><mn>2</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow></msup></mfrac><mo stretchy=\"false\">)</mo><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>∗</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mi>C</mi><mo separator=\"true\">⋅</mo><mi>n</mi><mo>+</mo><mi>n</mi><mo separator=\"true\">⋅</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n&amp; 2^k * T(\\frac{n}{2^k}) + k * n \\\\\n&amp;= 2^{log_2n} * T(\\frac{n}{2^{log_2n}}) + log_2n * n \\\\\n&amp;= C·n + n·log_2n\n\\end{aligned}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:5.68712em;vertical-align:-2.5935599999999996em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.09356em;\"><span style=\"top:-5.09356em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:-3.0000000000000004em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span><span style=\"top:-1.1740000000000008em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5935599999999996em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.09356em;\"><span style=\"top:-5.09356em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-3.0000000000000004em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-1.1740000000000008em;\"><span class=\"pstrut\" style=\"height:3.1075600000000003em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">⋅</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">⋅</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5935599999999996em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>使用大<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi></mrow><annotation encoding=\"application/x-tex\">O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> 表示法: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>归并排序的执行效率和要排序的原始数据的有序程度无关，所以不管最好情况和最坏情况下都是，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "冒泡排序",
                "分治思想排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "title": "选择排序",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<h2 id=\"基本思想\"><a class=\"markdownIt-Anchor\" href=\"#基本思想\">#</a> 基本思想</h2>\n<p>以第一个元素为基准，与后面的元素进行对比。选择最值 (最大值 / 最小值) 与当前位置进行交换。对每个元素都为基准比较，这就是排序过程了.</p>\n<h2 id=\"实现过程\"><a class=\"markdownIt-Anchor\" href=\"#实现过程\">#</a> 实现过程</h2>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序01-选择排序01.png\"></p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">select_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min_value_index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// select the min value index and record it</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[min_value_index] &gt; a[j]) &#123;</span><br><span class=\"line\">                min_value_index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min_value_index != i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = a[min_value_index];</span><br><span class=\"line\">            a[min_value_index] = a[i];</span><br><span class=\"line\">            a[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"comment\">// print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"排序算法的评估\"><a class=\"markdownIt-Anchor\" href=\"#排序算法的评估\">#</a> 排序算法的评估</h2>\n<ul>\n<li>基于比较，交换的排序算法.</li>\n<li>空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, 是一种原地排序算法.</li>\n<li>最好情况，最坏情况，平均情况，的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</li>\n<li><strong>是不是</strong>稳定的排序算法？<br>\n 主要取决于:   <code>if (a[min_value_index] &gt; a[j]) &#123;min_value_index = j;&#125;</code> <br>\n 如果是   <code>a[min_value_index] &gt;= a[j]</code>  就是不稳定的排序算法.</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "交换排序",
                "选择排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/recursion/%E7%AE%97%E6%B3%9501-%E9%80%92%E5%BD%92/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/recursion/%E7%AE%97%E6%B3%9501-%E9%80%92%E5%BD%92/",
            "title": "递归",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<p>数据结构与算法 这一个模块 有两个最难的知识点，一个就是 递归，另一个就是 动态规划</p>\n<p>我们今天来学习下递归这种实现方式。</p>\n<p>个人认为，递归不是一种算法，就是一种语法。所以我就称它为一类问题的解决方法.</p>\n<h2 id=\"何为递归\"><a class=\"markdownIt-Anchor\" href=\"#何为递归\">#</a> 何为递归？</h2>\n<p>递归，去的过程叫递，回来的过程叫归。凡是递归类的问题，都能总结出一个递归公式.<br>\n 比如: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(n+1) = f(n) + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, 我们用代码实现就是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n==<span class=\"number\">1</span>?<span class=\"number\">1</span>:f(n-<span class=\"number\">1</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断是否可用递归\"><a class=\"markdownIt-Anchor\" href=\"#判断是否可用递归\">#</a> 判断是否可用递归</h2>\n<p>要想使用递归来解决问题，要满足三个条件:</p>\n<ul>\n<li>一个问题的解可以分解为几个问题的解。</li>\n<li>这个问题和分解之后的问题，除了树据规模不一样，求解思路一模一样.</li>\n<li>存在递归终止条件。比如上例子中的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(n)=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ul>\n<h2 id=\"如何编写递归\"><a class=\"markdownIt-Anchor\" href=\"#如何编写递归\">#</a> 如何编写递归</h2>\n<h3 id=\"找出递推公式\"><a class=\"markdownIt-Anchor\" href=\"#找出递推公式\">#</a> 找出递推公式！</h3>\n<p>递归写法的话，最重要的就是写出递推公式，其次就是，找到终止条件.</p>\n<p>举个例子:</p>\n<p>人民币的组合方式.</p>\n<p>假设我有人民币 100 元，50 元，20 元，10 元，5 元，1 元的币种若干张，我想用这些花掉 70 元，我可以怎么花？</p>\n<p>这个问题就可以转换成了，70 元有多少中组合方式 (A) -&gt; 69 元有多少中组合方式 (B) + 65 元有几种组合方式 © + 60 元有几种组合方式 (D) + 50 元有几种组合方式 (E) + 20 元有几种组合方式 (F)。</p>\n<p>也就是说，我们把一个问题 A 分解成了若干子问题 B,C,D,E,F. 我们解决了子问题 B,C,D,E,F。 那么对应的 A 问题，也就解决了。而且，在这问题里，我们只要关心 A 与其子问题的关系即可，不用关系其他的子问题与子问题的关系。屏蔽掉递归细节。</p>\n<h2 id=\"递归实现方案的注意点\"><a class=\"markdownIt-Anchor\" href=\"#递归实现方案的注意点\">#</a> 递归实现方案的注意点</h2>\n<ul>\n<li>如果递归深度比较大的话，就会出现堆栈溢出的异常。</li>\n<li>递归的时候，要避免重复计算.<br>\n 这个的话，举个例子，就会很清晰了。斐波那契数列的计算.</li>\n</ul>\n<p>斐波那契数列就是 当前项等于前两项之和.</p>\n<p>以 fib (6) 为例，即求第 6 个数的数值。</p>\n<p>如下图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib.png\" alt=\"算法01-动态规划01-fib.png\"></p>\n<p>我们会发现: fib (4),fib (3),fib (2) 都是重复计算的。</p>\n<p>具体的解决方式呢，在 算法【动态规划】文章里，也有说过。</p>\n<p>加入一个数据，来记录就行了.<br>\n<img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib02.png\" alt=\"算法01-动态规划01-fib02.png\"> 其中虚线边框的就不用再计算了。</p>\n<ul>\n<li>一定要明确终止条件。不然就是死循环！</li>\n</ul>\n<p>好了，以上就是递归的介绍。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "递归"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/",
            "title": "哈希算法",
            "date_published": "2021-09-01T04:17:55.000Z",
            "content_html": "<h2 id=\"哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法\">#</a> 哈希算法</h2>\n<p>哈希算法，又称为：散列函数，散列算法。</p>\n<p>哈希算法是指将任意长度的二进制值串映射为固定长度的二进制串的这一规则。</p>\n<p>举个例子:  <code>Jdk</code>  的 <code>HashMap</code>  中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看似实现非常简单，但是设计一个优秀的哈希算法却不是简单的事情。优秀的 Hash 算法有什么要求？</p>\n<ul>\n<li>从 Hash 值不能反向推导出原始数据，所以哈希算法也叫单向哈希算法。</li>\n<li>对输入数据敏感，修改了原始数据中的一个 bit，最后得到的哈希值也大不相同。</li>\n<li>哈希冲突 (也叫哈希碰撞) 的概率要很小，对于不同的原始数据，哈希值相同的概率非常小。</li>\n<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>\n</ul>\n<p>我们再来看一个哈希算法的例子: MD5 () 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MD5Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class=\"line\">        System.out.println(md5(<span class=\"string\">&quot;123456789&quot;</span>)); <span class=\"comment\">// 25f9e794323b453885f5181f1b624d0b</span></span><br><span class=\"line\">        System.out.println(md5(<span class=\"string\">&quot;123456788&quot;</span>)); <span class=\"comment\">// f5f091a697cd91c4170cda38e81f4b1a</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String input)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class=\"line\">        MessageDigest md5 = MessageDigest.getInstance(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">        md5.update(input.getBytes());</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] digest = md5.digest();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">1</span>, digest).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从哈希后的串反推出原始字符串是非常困难的。在第二个字符串仅仅是将 9 改成了 8，但是 Hash 后的值是完全不一样的。<br>\n对于任何一种哈希算法我们都只能尽量的减少其冲突的概率，理论上是不可能做到完全不冲突的。在组合数学中有一个著名的理论就是：<span class=\"label success\">抽屉原理，也叫鸽巢原理。如果有 10 个鸽巢，但是有 11 只鸽子，那么肯定会有一个鸽巢中的鸽子数量多于一个。也就是肯定会有一个鸽巢里有两只鸽子</span>。同理而言，不管我们对什么样的数据进行哈希运算，得出的哈希值的长度是固定的，但是要哈希运算的原始数据确实无穷无尽的。以 MD5 算法为例。我们生成了 32 位的 16 进制数的字符串，那么我们生成串的可能性为 16^32 种。如果我们是第 16^32 + 1 个数据进行哈希运算肯定就会产生 哈希冲突。</p>\n<p>但是：我们可以轻易的得出这样一个结论:</p>\n<p><b>哈希值越长的哈希算法，散列冲突的概率越低</b></p>\n<p>那么哈希算法，主要应用在哪些方面呢？</p>\n<h2 id=\"哈希算法的应用\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法的应用\">#</a> 哈希算法的应用</h2>\n<h3 id=\"安全加密\"><a class=\"markdownIt-Anchor\" href=\"#安全加密\">#</a> 安全加密</h3>\n<p>上面我们提到了 MD5 算法，这个是老生常谈的加密算法了，据说已经被破解了。</p>\n<ul>\n<li>MD5 算法 : message digest Algorithm MD5 消息摘要算法。</li>\n<li>SHA 算法 : Secure Hash Algorithm 安全散列算法</li>\n<li>DES 算法 : data Encryption Standard 数据加密标准</li>\n<li>AES 算法 : Advanced Encryption Standard 高级加密标准。</li>\n</ul>\n<p>对用于加密的哈希算法，有两个特别重要的要求: 1. 很难通过 Hash 值推导出原始的字符串。2. 散列冲突的概率要很小。</p>\n<h3 id=\"唯一标识\"><a class=\"markdownIt-Anchor\" href=\"#唯一标识\">#</a> 唯一标识</h3>\n<ul>\n<li>md5: 例如：我们可以把每个图片的唯一标识，图片的路径都存储到散列表中，要查看什么图片的时候可以根据唯一标识去查到对应的图片。</li>\n</ul>\n<h3 id=\"数据校验\"><a class=\"markdownIt-Anchor\" href=\"#数据校验\">#</a> 数据校验</h3>\n<ul>\n<li>我们常说的，检验一个文件是否被修改过，要检验下 md5 值。我们可以通过对比，来校验数据的完整性和正确性。</li>\n</ul>\n<h3 id=\"散列函数\"><a class=\"markdownIt-Anchor\" href=\"#散列函数\">#</a> 散列函数</h3>\n<ul>\n<li>Java 中 HashMap 等用来计算哈希值。对散列的平均性和哈希算法的执行效率要求较高。</li>\n</ul>\n<h3 id=\"负载均衡\"><a class=\"markdownIt-Anchor\" href=\"#负载均衡\">#</a> 负载均衡</h3>\n<ul>\n<li>负载均衡算法，有很多，比如轮询算法，随机算法，加权轮询算法。</li>\n</ul>\n<h3 id=\"数据分片\"><a class=\"markdownIt-Anchor\" href=\"#数据分片\">#</a> 数据分片</h3>\n<ul>\n<li>典型的数据库的分库分表等海量数据的查询场景</li>\n</ul>\n<h3 id=\"分布式存储\"><a class=\"markdownIt-Anchor\" href=\"#分布式存储\">#</a> 分布式存储</h3>\n<ul>\n<li>这种的就是对海量数据的存储场景。比如分布式缓存 (Redis)，如何判断该条数据分配在哪台 Redis 中。</li>\n</ul>\n<p><b>哈希算法的几种使用场景，介绍完毕，我们重新来看看这种 Hash 算法在应用中有什么缺陷</b></p>\n<h2 id=\"一致性哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希算法\">#</a> 一致性哈希算法</h2>\n<p>在负载均衡，数据分片，分布式存储三种场景中，都有一个明显的特点就是，通过分布式集群的方式来对海量数据进行处理。</p>\n<p>这时，假设在集群中突然一台机器宕机，被迫下线。这时会出现什么问题呢？</p>\n<p>我再来详细的描述下这个场景。</p>\n<p>以分布式缓存为例：</p>\n<p>假设我们使用 Redis 集群做图片资源的缓存，Redis 的 key 是图片的名称，value 是对应服务器的路径。如果数据是 1000w，那么我们用 5 台服务器进行缓存，每台服务器大于 200w 数据，并且是都是主从的架构。<br>\n如下图：</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash1.png\" alt=\"\"></p>\n<p>很简单的存储方式： 我们对没他图片的名称进行哈希运算，并对得出的哈希值和 5 进行取模运算，得到这个图片资源所在的服务器，去获取数据。<br>\n比如： hash (2020053000001.png) % 5 = 3，表示位于第 4 台服务器上。</p>\n<p><b>很不幸！！！，突然有台机器宕机了，并且这台机器被踢下线了，集群中机器由 5 台 变成了 4 台 (减)</b></p>\n<p>那么这时会有什么问题呢？ 我们会发现所有的图片资源都无法命中缓存资源了。这时就出现所谓的 “缓存雪崩”。</p>\n<p>为什么呢？本来 hash (2020053000001.png) % 5 = 3，由于集群中只有 4 台机器了，那么 hash (2020053000001.png) % 4 = 3 就一定不会是 3 了吧！</p>\n<p>这时候你就说了，我们还是对 5 取模不就行了？这样至少其他 4 台缓存服务器还可以正常提供服务。但是这样所有命中宕机服务器的缓存都会打到数据库，这样还是有可能直接导致数据库宕机的！</p>\n<p>怎么办呢？</p>\n<p><b>一波不平，一波又起！随着访问量的增大，缓存服务器不堪重负！缓存服务器要从 5 台增加到 8 台！(增)</b></p>\n<p>同样的问题： hash (2020053000001.png) % 5 = 3 ，但是 hash (2020053000001.png) % 8 = ?? , 有一次 “雪崩！”</p>\n<p>怎么办呢？</p>\n<p><b>第三波！经过长时间的监控，发现缓存服务器的压力主要集中在晚上的 7:00 - 10:00 之间，其他时间段的压力就很小！(假)</b></p>\n<p>要求实现可以动态的扩张和缩小集群的数量。</p>\n<p>怎么办呢？</p>\n<p><b>重要嘉宾： 一致性哈希算法</b></p>\n<p>什么是一致性哈希算法呢？</p>\n<p>刚才在第一波的时候，说过我们可以对 5 取模啊。这个思路是可以的，但是不能根据集群中服务器数量来进行取模运算，而是要对一个固定大的数来取模运算（2^32=4294947297（最大的非符号整形数））。 那哈希值对应的位置上没有机器怎么办？我来解释下，一致性哈希算法的整体逻辑：</p>\n<p>一致性哈希算法是将整个哈希值空间组织成一个虚拟的圆环。而且这个哈希值空间的大小为  <code>[0, 2^32-1]</code> , 如下图。</p>\n<p>从 0 开始，顺时针计数，直到 2^32-1, 这 2^32 个点组成的圆环称为 Hash 环。</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash2.png\" alt=\"哈希图\"></p>\n<p>还是以上面的场景， 5 台服务器随机分布在环上，如下图，</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash3.png\" alt=\"哈希图\"></p>\n<p>常量 MAX_VALUE = 2 ^ 32;</p>\n<ul>\n<li>假设图片资源: hash (20200530004562.png) = 4；如果第 4 个位置上正好有一台服务器，就直接将这个条数据缓存到该台服务器上。</li>\n<li>假设图片资源：hash (20200530015456.png) = 46581；在第 46581 上并没有服务器，那么以顺时针的方向，进行遍历，直到遇到第一台服务器 58941，缓存到该台服务器 58941 上。</li>\n</ul>\n<p>如下图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash4.png\" alt=\"哈希图\"></p>\n<p>我们再来看看我们的三波:</p>\n<ul>\n<li><b>突然有一台机器宕机！</b></li>\n</ul>\n<p>假设 65594 这台机器宕机，那么就无法查询缓存在 65594 这台机器上的数据，程序会顺时针方向进行查找，找到 73214 这台机器，获取缓存为空，查询数据库后将数据缓存到 73214 这台机器上。</p>\n<ul>\n<li><b>新增机器到集群中</b></li>\n</ul>\n<p>假设 在集群节点号 73214 和 138956 之间插入一台机器 100354 。那么原来 hash 在 (73214,100354] 之前的数据，就不会缓存到 138956 节点了，</p>\n<ul>\n<li><b>动态</b></li>\n</ul>\n<p>在新增和删除完成之后，动态，理论上也是 OK 的。具体实现的话，就是监控访问流量，根据流量阈值设置动态的扩展和 “踢下线机器”(将机器给其他业务用)。</p>\n<h3 id=\"一致性哈希缺点\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希缺点\">#</a> 一致性哈希缺点</h3>\n<h4 id=\"数据倾斜\"><a class=\"markdownIt-Anchor\" href=\"#数据倾斜\">#</a> 数据倾斜</h4>\n<p>一致性哈希算法，当在服务器节点数量太少的时候，容易出现分配不均而导致数据倾斜。比如，我们有三台服务器，如下图分布:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash5.png\" alt=\"哈希图\"></p>\n<p>假设大量数据哈希后的值在 [C,MaxValue] 之间，那么所有的数据都会散列到第 1 个节点上。</p>\n<p>这种问题，怎么解决呢？</p>\n<p><b>虚拟节点</b></p>\n<p>假设我们有 5 台服务器节点，防止各节点分布不均匀的问题，我们可以一台服务其进行多次哈希运算，从而虚拟出个节点。</p>\n<p>假设我们原来对服务器 1 的 IP (192.168.0.1) 进行哈希，我们使用虚拟节点的方式进行哈希的时候，我们可以对（192.168.0.1#1），（192.168.0.1#2），（192.168.0.1#3），（192.168.0.1#4）。这样 5 台机器，就可以有 20 个节点。从而加大了哈希后分布的随机性。解决了服务节点少时数据倾斜的问题。实际应用中，至少要大于 32 。</p>\n<p>好了，关于一致性哈希的相关内容，本篇文章就介绍到这里。</p>\n<p><b>下一篇文章《一致性 Hash 算法的实现》请期待 </b></p>\n<p>如果有什么问题，欢迎你私信我，我们一起交流哇。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "哈希算法"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/dynamicPlan/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/dynamicPlan/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "动态规划",
            "date_published": "2021-09-01T04:13:55.000Z",
            "content_html": "<p>👉 <span class=\"label success\">动态规划其实就是动态递推</span>👈</p>\n<h2 id=\"要点\"><a class=\"markdownIt-Anchor\" href=\"#要点\">#</a> 要点</h2>\n<ul>\n<li>递归 + 记忆化 -&gt; 递推 (自下而上的递推)</li>\n<li>状态的定义，opt [n],dp [n],fib [n]</li>\n<li>状态转移方程 (dp 方程)， opt [n]=best_of (opt [n-1],opt [n-2])</li>\n<li>最优子结构</li>\n</ul>\n<h2 id=\"例子\"><a class=\"markdownIt-Anchor\" href=\"#例子\">#</a> 例子</h2>\n<h3 id=\"斐波那契数列\"><a class=\"markdownIt-Anchor\" href=\"#斐波那契数列\">#</a> 斐波那契数列</h3>\n<p>我们先使用递归的方式，我们实现斐波那契数列.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fib1(6)=%d\\n&quot;</span>, fib1(<span class=\"number\">6</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fib2(6)=%d\\n&quot;</span>, fib2(<span class=\"number\">6</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 斐波那契数列实现方案一</span></span><br><span class=\"line\"><span class=\"comment\"> * @param n 第n个数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return n个数的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib1(n - <span class=\"number\">1</span>) + fib1(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 斐波那契数列实现方案二</span></span><br><span class=\"line\"><span class=\"comment\"> * @param n 第n个数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return n个数的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib2</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib1(n - <span class=\"number\">1</span>) + fib1(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// return n&lt;=1?1:fib1(n - 1) + fib1(n - 2);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib.png\" alt=\"算法01-动态规划01-fib.png\"><br>\n 此时的时间复杂度为 O (2^n). 如上图，最后的结果是每个节点是累加起来，那么有多少个节点呢？2^n 个节点。<br>\n根据这张图，我们可以发现，个别 &quot;节点&quot; 出现了重复的情况，这个时候我们就用到了记忆化的方式进行优化。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib3</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fib3(6)=%d\\n&quot;</span>, fib3(<span class=\"number\">6</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 斐波那契数列实现方案三</span></span><br><span class=\"line\"><span class=\"comment\"> * @param n  第n个数</span></span><br><span class=\"line\"><span class=\"comment\"> * @return n个数的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mem[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib3</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mem[n]) &#123;</span><br><span class=\"line\">        mem[n] = fib1(n - <span class=\"number\">1</span>) + fib1(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mem[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就省去了个别节点的计算过程了。如下图<br>\n<img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib02.png\" alt=\"算法01-动态规划01-fib02.png\"> 其中虚线边框的就不用再计算了。</p>\n<p>这样的话，我们把时间复杂度优化到了 O (n).</p>\n<p>然后我们就可以发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fib(n) = fib(n-1) + fib(n-2);</span><br></pre></td></tr></table></figure>\n<p>这个就是我们的状态转移方程 (dp 方程)。<br>\n比较的简单的 fib，一般我们就成为这个为递推公式。</p>\n<h3 id=\"计算路线\"><a class=\"markdownIt-Anchor\" href=\"#计算路线\">#</a> 计算路线</h3>\n<h4 id=\"例题描述\"><a class=\"markdownIt-Anchor\" href=\"#例题描述\">#</a> 例题描述</h4>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9202-%E8%AE%A1%E7%AE%97%E8%B7%AF%E5%BE%84.png\" alt=\"算法01-动态规划02-计算路径.png\"></p>\n<p>只能横着走或者竖着走，假设有一个人总 start 处，走到 end 处，一共有多少条路线？</p>\n<h4 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\">#</a> 分析</h4>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9202-%E8%AE%A1%E7%AE%97%E8%B7%AF%E5%BE%8402.png\" alt=\"算法02-动态规划03-计算路径02.png\"></p>\n<p>从 start 到 end 的所有路线，等于 B 到 end 路线加上 A 到 end 的路线。因为 start 要到 end，要么到 A, 从 A 走到 end, 要么到 B，从 B 走到 end。那么同理 B 到 end 就等于 C 到 end 的路线到 E 到 end 的路线。D 到 end 等于 C 到 end 的路线加上 D 到 end 的路线.<br>\n 这是我们可以得出如下的推导公式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">path(start,end)=path(A,end) + path(B,end)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>同理:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>D</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>p</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">path(A,end)=path(D,end) + path(C,end) \\\\ path(B,end) = path(E,end) + path(C,end)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>一直到最下面的一行，最下面的这一行的每个点到 end 的路线只有一条，所以每个都是 1, 同样的最右侧的一列，每个都是 1. 如下图.<br>\n<img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9202-%E8%AE%A1%E7%AE%97%E8%B7%AF%E5%BE%8403.png\" alt=\"算法01-动态规划02-计算路径03.png\"><br>\n 经过上面的分析，F 到 end 有几条路线呢？两条。由于 G 右侧是黑色的不能通过，所以 G 只有 1 条，H 就有 2 条，就有 3 条，K 有 3 条，L 有 1 条。所以有了下面的这张图，图中的数字就是路线数.<br>\n<img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9202-%E8%AE%A1%E7%AE%97%E8%B7%AF%E5%BE%8404.png\" alt=\"算法01-动态规划02-计算路径04.png\"></p>\n<p>根据以上的推论我们尝试写出这样的代码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPaths</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid,<span class=\"keyword\">int</span> row,<span class=\"keyword\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!validSquare(grid,row,col))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isEnd(grid,row,col))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> countPaths(grid,row+<span class=\"number\">1</span>,col) + countPaths(grid,row,col+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我根据推论可以得出状态转移方程:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> a[i,j] == <span class=\"string\">&#x27;白色&#x27;</span>:</span><br><span class=\"line\">   opt[i,j] = opt[i+<span class=\"number\">1</span>,j] + opt[i,j+<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   opt[i,j] = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"程序实现\"><a class=\"markdownIt-Anchor\" href=\"#程序实现\">#</a> 程序实现</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> paths[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=m;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        paths[i][n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j =n; j&gt;<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">        paths[m][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m<span class=\"number\">-1</span>; i &gt; <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span> ; j--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            paths[i][j] = paths[i+<span class=\"number\">1</span>][j] + paths[i][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> paths[<span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dp-vs-回溯-vs-贪心\"><a class=\"markdownIt-Anchor\" href=\"#dp-vs-回溯-vs-贪心\">#</a> DP vs 回溯 vs 贪心</h2>\n<ul>\n<li>回溯 (递归) - 重复计算</li>\n<li>贪心 - 永远局部最优</li>\n<li>DP - 记录局部最优子结构 / 多种记录值。(集两者之大成)</li>\n</ul>\n<p>三者并没有明显的界限。贪心不是局部最优的时候，回溯避免了重复计算之后，就是了动态规划了。</p>\n<h2 id=\"例题\"><a class=\"markdownIt-Anchor\" href=\"#例题\">#</a> 例题</h2>\n<h3 id=\"爬楼梯\"><a class=\"markdownIt-Anchor\" href=\"#爬楼梯\">#</a> 爬楼梯</h3>\n<h4 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h4>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>\n注意：给定 n 是一个正整数</p>\n<h4 id=\"解析\"><a class=\"markdownIt-Anchor\" href=\"#解析\">#</a> 解析</h4>\n<p>如下面的图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9203-%E7%88%AC%E6%A5%BC%E6%A2%AF01.png\" alt=\"算法01-动态规划03-爬楼梯01.png\"></p>\n<p>因为我们只有两种走法，要么跨一个台阶，要么跨两个台阶。那么如图中我们爬到第 10 层台阶的走法就等于第 9 (10-1) 层台阶的走法和第 8 (10-2) 层台阶的走法的和。即 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mn>10</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mn>9</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mn>8</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">stairs(10)=stairs(9)+stairs(8)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord\">9</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord\">8</span><span class=\"mclose\">)</span></span></span></span>, 那么我们爬第一层台阶是 1 种走法，第二层台阶就是 2 种走法。所以我们就可以得出我们的递推公式：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">stairs(n) = stairs(n-1) + stairs(n-2)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>我们可以得出，这就是斐波那契数列。</p>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "动态规划",
                "数据结构与算法"
            ]
        }
    ]
}