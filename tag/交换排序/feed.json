{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"交换排序\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
            "title": "冒泡排序",
            "date_published": "2021-09-01T04:47:55.000Z",
            "content_html": "<h2 id=\"基本思想\"><a class=\"markdownIt-Anchor\" href=\"#基本思想\">#</a> 基本思想</h2>\n<p>每次都操作两个相邻的数据。每次冒泡操作都对相邻的两个数据进行比较，看是否满足大小关系要求，如果不满足，就进行互换。每次冒泡都会冒出一个最小 / 大值，并移动到它应该在的位置。重复 n 次，就完成了对 n 个数据的排序工作.</p>\n<h2 id=\"排序逻辑图\"><a class=\"markdownIt-Anchor\" href=\"#排序逻辑图\">#</a> 排序逻辑图</h2>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序01-冒泡法排序01\"></p>\n<p>这里在详细的写一下第一次排序的过程：</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F02.png\" alt=\"算法01-排序01-冒泡法排序02.png\"></p>\n<p>按照以上逻辑的代码实现</p>\n<h2 id=\"算法实现\"><a class=\"markdownIt-Anchor\" href=\"#算法实现\">#</a> 算法实现</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; length-i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j - <span class=\"number\">1</span>] &gt; a[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j - <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">                a[j] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种实现，在这种情景下，就会浪费时间。</p>\n<p>如果原始数组为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[5,0,1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>排序过程如下:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F03.png\" alt=\"算法01-排序01-冒泡法排序03.png\"></p>\n<p>可以发现，在完成第一趟排序的时候，实际上已经是正确的排序结果了。我们可以采用下面的方式进行优化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">bubble_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; length - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[j - <span class=\"number\">1</span>] &gt; a[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                a[j - <span class=\"number\">1</span>] = a[j];</span><br><span class=\"line\">                a[j] = temp;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出:</p>\n<ul>\n<li>冒泡排序是基于比较，交换的排序算法。</li>\n<li>冒泡排序使用的空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, 是一个原地排序算法。</li>\n<li>以上代码实现的冒泡算法是稳定的排序算法.  <code>if(a[i]&lt;=a[j])</code>  就是一个不稳定的排序算法了.</li>\n<li>冒泡算法最好情况下的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, 最坏情况下的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. 那平均情况下的时间复杂度怎么计算呢？</li>\n</ul>\n<h2 id=\"计算平均情况下的时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#计算平均情况下的时间复杂度\">#</a> 计算平均情况下的时间复杂度</h2>\n<p>这里，我们引入三个概念</p>\n<ul>\n<li>有序元素对：如果  <code>i&lt;j</code>  , 并且  <code>a[i]&lt;a[j]</code> , 那么这个一对儿数就是有序的。</li>\n<li>逆序元素对：如果  <code>i&lt;j</code>  , 并且  <code>a[i]&gt;a[j]</code> , 那么这个一对儿数就是逆序的。</li>\n<li>有序度：数组中具有有序关系的元素对的个数.</li>\n<li>满有序度：完全有序的数列。</li>\n</ul>\n<p>其中  <code>满有序度</code>  =  <code>有序度</code>  +  <code>逆序度</code> 。</p>\n<p>举个例子:</p>\n<p><strong> <code>[4,5,6,3,2,1]</code> </strong></p>\n<p>有序度为 3, 也称为 <em>原始有序度</em>, 分别为:  <code>(4,5)</code>   <code>(4,6)</code>   <code>(5,6)</code></p>\n<p>满有序度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">\\frac {n*(n-1)}{2}=15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">∗</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">5</span></span></span></span></p>\n<p>冒泡排序中包含两个操作原子，比较和交换。没交换一次，有序度就会加 1. 所以，交换次数，就是逆有序度。 那么， <code>逆有序度 = 满有序度 - 初始有序度</code> 。也就是: 15 - 3 = 12. 需要进行 12 次操作。</p>\n<p>平均情况下，要进行<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>4</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac {n*(n-1)}{4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">∗</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 次操作。比较操作肯定要比交换操作多，而最坏情况下的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 所以平均情况下的时间复杂度就是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "冒泡排序",
                "交换排序"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
            "title": "选择排序",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<h2 id=\"基本思想\"><a class=\"markdownIt-Anchor\" href=\"#基本思想\">#</a> 基本思想</h2>\n<p>以第一个元素为基准，与后面的元素进行对比。选择最值 (最大值 / 最小值) 与当前位置进行交换。对每个元素都为基准比较，这就是排序过程了.</p>\n<h2 id=\"实现过程\"><a class=\"markdownIt-Anchor\" href=\"#实现过程\">#</a> 实现过程</h2>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E6%8E%92%E5%BA%8F01-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F01.png\" alt=\"算法01-排序01-选择排序01.png\"></p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">select_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min_value_index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// select the min value index and record it</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[min_value_index] &gt; a[j]) &#123;</span><br><span class=\"line\">                min_value_index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (min_value_index != i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = a[min_value_index];</span><br><span class=\"line\">            a[min_value_index] = a[i];</span><br><span class=\"line\">            a[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"comment\">// print(a, length);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"排序算法的评估\"><a class=\"markdownIt-Anchor\" href=\"#排序算法的评估\">#</a> 排序算法的评估</h2>\n<ul>\n<li>基于比较，交换的排序算法.</li>\n<li>空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, 是一种原地排序算法.</li>\n<li>最好情况，最坏情况，平均情况，的时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</li>\n<li><strong>是不是</strong>稳定的排序算法？<br>\n 主要取决于:   <code>if (a[min_value_index] &gt; a[j]) &#123;min_value_index = j;&#125;</code> <br>\n 如果是   <code>a[min_value_index] &gt;= a[j]</code>  就是不稳定的排序算法.</li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "排序",
                "交换排序",
                "选择排序"
            ]
        }
    ]
}