{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"rocketmq\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2022/07/09/rocketMQ/3-08-save-msg-detail/",
            "url": "https://fangjiaxiaobai.github.io/2022/07/09/rocketMQ/3-08-save-msg-detail/",
            "title": "RocketMQ 消息刷盘过程详解",
            "date_published": "2022-07-09T10:18:00.000Z",
            "content_html": "<p>在 <a href=\"./2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF.md\">RocketMQ 架构设计之消息</a> 这篇文章中，我们学习了 消息发送到消费 的整体流程。这篇文章，我们一起来看看  <code>MappedFile</code>  的实现细节.</p>\n<h2 id=\"引言\"><a class=\"markdownIt-Anchor\" href=\"#引言\">#</a> 引言</h2>\n<p>我们都知道的是  <code>RocketMQ消</code> 息都是持久化到磁盘上的，消息的读取和写入也都是会从磁盘上进行 <code>IO</code>  的。可是磁盘的性能不禁另 CPU 啧啧撇嘴。 <code>RocketMQ</code>  是如何实现消息的高性能 <code>IO</code>  的呢？</p>\n<p>答案就是  <code>MappedFile</code>  这个  <code>643</code>  行的 <code>java</code>  文件中。</p>\n<h2 id=\"rokcetmq-的-mappedfile\"><a class=\"markdownIt-Anchor\" href=\"#rokcetmq-的-mappedfile\">#</a>  <code>RokcetMQ</code>  的  <code>MappedFile</code></h2>\n<p>我们知道的是  <code>MappedFile</code>  是  <code>RocketMQ</code>  真实消息文件在内存中的映射。主要是通过  <code>java NIO</code>  技术来实现。</p>\n<p>我们还是从源码入手，按照  <code>MappedFile</code>  的初始化，提交消息 (消息写入物理内存)，刷盘 的顺序去学习。</p>\n<h2 id=\"初始化\"><a class=\"markdownIt-Anchor\" href=\"#初始化\">#</a> 初始化</h2>\n<p>在  <code>Broker</code>  的初始化过程中， <code>Broker</code>  通过  <code>AllocateMappedFileService</code>  完成了  <code>MappedFile</code>  的 初始化过程。其主要的实现就是在  <code>mmapOperation</code>  方法中。主要的职责有: 1、创建  <code>MappedFile</code>  实例  2、对 <code>MappedFile</code>  进行预热。</p>\n<h3 id=\"创建-mappedfile实例\"><a class=\"markdownIt-Anchor\" href=\"#创建-mappedfile实例\">#</a> 创建  <code>MappedFile</code>  实例</h3>\n<p>根据 消息的刷盘方式 初始化  <code>MappedFile</code>  实例的不同的字段。 如下图。</p>\n<p><img data-src=\"/images/rocketmq/3-08-01.png\" alt=\"\"></p>\n<h3 id=\"预热-mappedfile\"><a class=\"markdownIt-Anchor\" href=\"#预热-mappedfile\">#</a> 预热  <code>MappedFile</code></h3>\n<p><code>MappedFile</code>  预热的条件：实际的消息文件大小超过配置的大小 (默认 <code>1G</code> ) 并且 配置允许 <code>MappedFile</code>  预热。<br>\n <code>MappedFile</code>  预热的作用是：将 存在在磁盘上的消息预先加载到页缓存中 ( <code>Page Cache</code> ), 这也就是所谓的预热，省去了现用现加载的时间。</p>\n<p>预热的主要代码，我贴在下面</p>\n<p><img data-src=\"/images/rocketmq/3-08-03.png\" alt=\"\"></p>\n<p>注意看下注释的内容。乍一看好像没有什么奇怪。</p>\n<p>我先补充一下关于操作系统中存储的小知识点:</p>\n<h4 id=\"页\"><a class=\"markdownIt-Anchor\" href=\"#页\">#</a> 页</h4>\n<p>页是操作系统虚拟内存中空间划分的单位。是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 <code>512B~8KB</code> 。</p>\n<h4 id=\"页缓存page-cache\"><a class=\"markdownIt-Anchor\" href=\"#页缓存page-cache\">#</a> 页缓存 (Page Cache)</h4>\n<p>为了提升对文件的读写效率， <code>Linux</code>  内核会以页大小（ <code>4KB</code> ）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文件中的数据块进行绑定。在 <code>Linux</code>  系统中写入数据的时候并不会直接写到硬盘上，而是会先写到 <code>Page Cache</code>  中，并打上 <code>dirty</code>  标识，由内核线程 <code>flusher</code>  定期将被打上 <code>dirty</code>  的页发送给 <code>IO</code>  调度层，最后由 <code>IO</code>  调度决定何时落地到磁盘中，而 <code>Linux</code>  一般会把还没有使用的内存全拿来给 <code>Page Cache</code>  使用。而读的过程也是类似，会先到 <code>Page Cache</code>  中寻找是否有数据，有的话直接返回，如果没有才会到磁盘中去读取并写入 <code>Page Cache</code>  然后再次读取 <code>Page Cache</code>  并返回。而且读的这个过程中操作系统也会有一个预读的操作，你的每一次读取操作系统都会帮你预读出后面一部分数据，而且当你一直在使用预读数据的时候，系统会帮你预读出更多的数据 (最大到 <code>128K</code> )。</p>\n<p><code>page cache</code>  的作用主要是将磁盘中文件缓存到内存，并集中管理，便于回收利用。</p>\n<p>了解了 页和页缓存 之后，就应该可以知道了  <code>RocketMQ</code>  为什么会在  <code>MappedByteBuffer</code>  的每个  <code>pageSize</code>  大小的位置 (也就是一个页) 写入一个 <code>0</code>  了。其实就是 把磁盘上的数据写到  <code>PageCache</code>  中，也就达到预热的效果。</p>\n<p>还有一个   <code>mlock</code>  方法，这个方法的作用是什么呢？</p>\n<p>该方法主要是实现文件预热后，防止把预热过的文件被操作系统调到 <code>swap</code>  空间中。当程序再次读取交换出去的数据的时候会产生缺页异常。 这里也有一个关于操作系统的知识点.</p>\n<h4 id=\"page-fault\"><a class=\"markdownIt-Anchor\" href=\"#page-fault\">#</a> Page Fault</h4>\n<p><code>CPU</code>  通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、 <code>IO</code>  设备等等，但从 <code>CPU</code>  发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由内存管理单元 ( <code>MMU</code> ) 将虚拟地址转换成物理地址再从地址总线上发出，内存管理单元上的这种虚拟地址和物理地址的转换关系是需要创建的，并且内存管理单元还可以设置这个物理页是否可以进行写操作，当没有创建一个虚拟地址到物理地址的映射，或者创建了这样的映射但那个物理页不可写的时候，内存管理单元将会通知 <code>CPU</code>  产生了一个缺页异常。产生了  <code>Page Fault</code>  之后会交给 <code>PageFaultHandler</code>  处理，这里不详细介绍了。导致用户进程产生异常，无法正常工作。</p>\n<p>而 <b> <code>mlock</code>  就是为了阻止出现  <code>pageFault</code>  异常</b></p>\n<h4 id=\"内存管理机制页框回收机制\"><a class=\"markdownIt-Anchor\" href=\"#内存管理机制页框回收机制\">#</a> 内存管理机制：页框回收机制</h4>\n<p>系统中初识化了很多页缓存，但是这些页长时间没有使用， <code>linux</code>  会有一个 页框的回收机制，将  <code>page cache</code>  中数据标识 “可回收”。 在回收之前，操作系统就会把  <code>Page cache</code>  中的内容复制到  <code>swap cache</code>  中 (这个操作也叫做  <code>swap out</code> ), 如果进程要访问 当前页的时候，就会出现  <code>page Fault</code> . 然后 根据  <code>swap cache</code>  内存地址把内存拷贝到新的  <code>PageCache</code>  中 (这个操作叫做  <code>swap in</code> ).</p>\n<h3 id=\"总结预热mappedfile\"><a class=\"markdownIt-Anchor\" href=\"#总结预热mappedfile\">#</a> 总结：预热 <code>MappedFile</code></h3>\n<p>预热时已经已经建立了  <code>MappedByteBuffer</code>  和物理内存的地址映射，但是还没有把消息加载进内存，所谓的预热是为了把消息读取到操作系统的物理内存中。并且使用  <code>mlock</code>  把锁定内存，防止消息被操作系统回收。</p>\n<h2 id=\"消息写入物理内存\"><a class=\"markdownIt-Anchor\" href=\"#消息写入物理内存\">#</a> 消息写入物理内存</h2>\n<p>这篇文章<a href=\"./2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF.md\">《RocketMQ 架构设计之消息》</a>我们介绍了消息写入的大致过程:  <code>Broker</code>  的  <code>Netty Server</code>  接收到  <code>Producer</code>  发送来的消息，通过  <code>SendMessageProcessor</code>  进行处理，然后  <code>DefaultMessageStore</code>  把消息交给  <code>CommitLog</code>  进行写消息和刷盘.</p>\n<p>我们都知道的是  <code>CommitLog</code>  表示的是  <code>RocketMQ</code>  的消息文件。它提供了写入消息和读取消息的功能。我们就从  <code>CommitLog</code> . <code>asyncPutMessage</code>  来看消息的写入过程。</p>\n<p><code>asyncPutMessage</code>  这个方法 实现了两个功能:</p>\n<ul>\n<li>通过  <code>ByteBuffer</code>  写入消息。</li>\n<li>提交刷盘请求。</li>\n</ul>\n<p><img data-src=\"/images/rocketmq/3-08-04.png\" alt=\"\"></p>\n<p>上图源码中可以看到  <code>CommitLog</code>  调用了  <code>MappedFile</code>  把消息写入文件，真实去写入者是  <code>ByteBuffer.put()</code>  方法把消息写到了物理内存中.</p>\n<p>注意，这个 <code>ByteBuffer</code>  非常的有意思.</p>\n<p>当 刷盘方式是 同步刷盘的时候，使用的是： <code>this.mappedByteBuffer.slice()</code>  , 这个  <code>mappedByteBuffer</code>  对象是有 <code>FileChannel.map()</code>  方法生成。<br>\n当刷盘方式是 异步刷盘的时候，则是使用  <code>DirectByteBuffer </code> 进行写入的。</p>\n<p>这两者有什么区别呢？本质上其实没有什么区别！！</p>\n<p><code>FileChannel.map()</code>  出来的  <code>MappedByteBuffer</code>  类型是一个抽象类，本质上还是通过  <code>DirectByteBuffer</code>  进行构建出来的。</p>\n<p><img data-src=\"/images/rocketmq/3-08-05.png\" alt=\"\"></p>\n<p>这样， <code>RocketMQ</code>  就把消息写入到了物理内存中.</p>\n<p>什么时候把消息写到磁盘上的呢？</p>\n<p>我们读写的数据都是从  <code>pageCache</code>  中读写的，并不会直接读写磁盘。</p>\n<p>操作系统中提供了两种方式来实现  <code>pageCache</code>  和 磁盘的数据一致性。</p>\n<ul>\n<li><code>Write Through</code> （写穿）：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；</li>\n<li><code>Write back</code> （写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的  <code>Linux</code>  一致性方案.</li>\n<li></li>\n</ul>\n<p>所以，我们接下来看  <code>RocketMQ</code>  是如何确保消息落盘的。</p>\n<h2 id=\"消息刷盘\"><a class=\"markdownIt-Anchor\" href=\"#消息刷盘\">#</a> 消息刷盘</h2>\n<p><code>RocketMQ</code>  有三种刷盘方式。两种刷盘的实现。</p>\n<p><img data-src=\"/images/rocketmq/3-08-06.png\" alt=\"\"></p>\n<p>分别是  <code>GroupCommitService</code>  (同步刷盘),  <code>FlushRealTimeService</code>  (异步刷盘),  <code>CommitRealTimeService</code>  (异步刷盘 + 缓冲区). 这三个类有一个共同的父类:</p>\n<p><img data-src=\"/images/rocketmq/3-08-07.png\" alt=\"\"></p>\n<p>我们详细的去看一下同步刷盘的过程。因为异步刷盘和同步刷盘的 <code>flush</code>  过程是一样的.</p>\n<h3 id=\"同步刷盘\"><a class=\"markdownIt-Anchor\" href=\"#同步刷盘\">#</a> 同步刷盘</h3>\n<p>在消息启动的时候，如果配置了 使用同步刷盘方式的话， <code>Broker</code>  会启动  <code>GroupCommitService</code>  和  <code>CommitRealTimeService</code>  (这个是异步刷盘并且配置内存池的时候使用的刷盘方式，不管配置什么方式的时候都会创建，在启用 <code>isTransientStorePoolEnable</code>  的时候才会  <code>start()</code>  ).</p>\n<p><code>GroupCommitService</code>  在启动之后，会每  <code>10ms</code>  执行一次刷盘操作。</p>\n<p>我们从  <code>CommitLog</code>  添加完消息提交刷盘请求开始，详细分析整个过程.</p>\n<p>如下图。</p>\n<p><img data-src=\"/images/rocketmq/3-08-08.png\" alt=\"\"></p>\n<p><code>CommitLog</code>  提交一个 刷盘请求，这时根据配置 是否等待消息写入完成 来执行刷盘操作.</p>\n<ul>\n<li>如果不等待消息写入完成，则唤醒  <code>GroupCommitService</code> , 直接返回写入成功，这时 线程是否执行是由 <code>JVM</code>  决定的，所以并不确定线程立刻就执行了。</li>\n<li>如果等待消息写入完成，即第二步，则会放入一个  <code>GroupCommitRequest</code>  同步刷盘请求。实际上是把 这个  <code>Request</code>  放到  <code>GroupCommitService</code>  的  <code>LinkedList</code>  中，为了线程安全和提高效率，使用了两个  <code>LinkedList</code> , 分别是  <code>write</code>  和  <code>read</code> . 当执行刷盘操作的时候，会将  <code>write</code>  和  <code>read</code>  互换。每次都会读取  <code>read</code>  队列中的  <code>Request</code>  进行刷盘。这一步是在  <code>waitForRunning</code>  方法中执行的，见如图第 <code>5-7</code>  步。<br>\n接下来就是刷盘操作了，调用  <code>mappedFileQueue.flush(0)</code>  操作完成刷盘动作。然后，返回  <code>CompleteFuture</code>  如图中第 9 步。 当需要等待消息写入完成的时候， <code>CommitLog</code>  添加消息是在一直等待的。如下图.</li>\n</ul>\n<p><img data-src=\"/images/rocketmq/3-08-09.png\" alt=\"\"></p>\n<p>那接下来，我就详细的来看下  <code>mappedFileQueue</code>  其实是  <code>MappedFile</code>  的刷盘过程.</p>\n<h4 id=\"mappedfilequeueflush\"><a class=\"markdownIt-Anchor\" href=\"#mappedfilequeueflush\">#</a> MappedFileQueue.flush</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 刷盘</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> flushLeastPages 最后一页</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">flush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// flushWhere. 应该刷新数据end的位置。</span></span><br><span class=\"line\">    MappedFile mappedFile = <span class=\"keyword\">this</span>.findMappedFileByOffset(<span class=\"keyword\">this</span>.flushedWhere, <span class=\"keyword\">this</span>.flushedWhere == <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class=\"line\">        <span class=\"comment\">// 使用 MappedFile 进行刷盘。返回 MappedFile 中 已被刷新到磁盘的数据的偏移量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class=\"line\">        <span class=\"comment\">// 在整个MappedFileQueue中的偏移量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class=\"line\">        result = where == <span class=\"keyword\">this</span>.flushedWhere;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.flushedWhere = where;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == flushLeastPages) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 刷新之前，最新一条消息的存储时间戳</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取到当前需要写入的 <code>MappedFile</code> . 然后通过 <code>MappedFile</code>  写入 &quot;磁盘&quot;。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 刷盘。 把写入MappedFile 的数据，写入磁盘。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The current flushed position</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">flush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hold()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> value = getReadPosition();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 只有在异步刷盘+缓存区方式的时候，才初始化 writeBuffter</span></span><br><span class=\"line\">                    <span class=\"comment\">//We only append data to fileChannel or mappedByteBuffer, never both.</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (writeBuffer != <span class=\"keyword\">null</span> || <span class=\"keyword\">this</span>.fileChannel.position() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>.fileChannel.force(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 不管什么刷盘方式，都会初始化mappedByteBuffer.</span></span><br><span class=\"line\">                        <span class=\"comment\">// 同步刷盘和异步刷盘方式都是使用 mappedByteBuffer 进行刷盘</span></span><br><span class=\"line\">                        <span class=\"keyword\">this</span>.mappedByteBuffer.force();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;Error occurred when force data to disk.&quot;</span>, e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.flushedPosition.set(value);</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.release();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;in flush, hold failed, flush offset = &quot;</span> + <span class=\"keyword\">this</span>.flushedPosition.get());</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.flushedPosition.set(getReadPosition());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getFlushedPosition();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步刷盘\"><a class=\"markdownIt-Anchor\" href=\"#异步刷盘\">#</a> 异步刷盘</h3>\n<p>看完同步刷盘的流程之后，异步刷盘就简单很多了。<br>\n异步刷盘仍然是使用  <code>mappedFileQueue.flush()</code>  进行刷盘的</p>\n<p>实现逻辑如下图 (代码有精简):</p>\n<p><img data-src=\"/images/rocketmq/3-08-10.png\" alt=\"\"></p>\n<p>可以看到，异步刷盘的线程在执行的时候，会通过  <code>Thread.sleep()</code>  进行线程等待 或者 通过  <code>CountDownLatch2</code>  进行等待的。需要注意的是:  <code>CountDownLatch2</code>  是  <code>RocketMQ</code>  实现的一个类，作用同 <code>CountDownLatch</code>  一样。</p>\n<p>而且在 消息进行刷盘的时候， 只需要将  <code>FlushRealTimeService</code>  线程  <code>wakeup()</code>  就好了。</p>\n<p><img data-src=\"/images/rocketmq/3-08-11.png\" alt=\"\"></p>\n<p>此时的  <code>flushCommitLogService</code>  是  <code>FlushRealTimeService</code>  的实例。</p>\n<p>异步刷盘的时机:</p>\n<ul>\n<li>判断是否超过 <code>10s</code>  没有刷盘了，如果超过则强制刷盘。</li>\n<li>等待 <code>flush</code>  间隔，默认 <code>500ms</code></li>\n<li>通过 <code>MappedFile</code>  刷盘</li>\n<li>超过 <code>500ms</code>  的刷盘日志</li>\n<li><code>Broker</code>  正常挺值钱，把内存 <code>page</code>  中的数据刷盘。</li>\n</ul>\n<p>和同步刷盘相比，异步刷盘提高了 <code>IO</code>  性能。</p>\n<h3 id=\"异步刷盘缓冲区\"><a class=\"markdownIt-Anchor\" href=\"#异步刷盘缓冲区\">#</a> 异步刷盘 + 缓冲区</h3>\n<p>我们先看一下执行的流程。</p>\n<p><img data-src=\"/images/rocketmq/3-08-12.png\" alt=\"\"></p>\n<p>然后如果是 <code>CountDownLatch2</code>  结束，执行线程的话，就会执行下面的逻辑:</p>\n<p><img data-src=\"/images/rocketmq/3-08-13.png\" alt=\"\"></p>\n<p>判断是否有新的数据提交， 如果有，则唤醒异步刷盘方式。没有则等待。</p>\n<p><code>waitForRunning</code>  方法的逻辑是：</p>\n<p><img data-src=\"/images/rocketmq/3-08-14.png\" alt=\"\"></p>\n<p>可以看到 是通过线程等待的方式，等待时间间隔完成。</p>\n<p>开启缓冲区后的刷盘策略:</p>\n<ul>\n<li>判断是否超过 <code>200</code>  毫秒没提交，需要强制提交</li>\n<li>提交到 <code>MappedFile</code> ，此时还未刷盘</li>\n<li>然后唤醒刷盘线程</li>\n<li>在 <code>Broker</code>  正常停止前，提交内存 <code>page</code>  中的数据</li>\n</ul>\n<p><code>RocketMQ</code>  申请一块和 <code>CommitLog</code>  文件大小相同的堆外内存在做缓冲区，数据会先写入缓冲池，提交线程  <code>commitRealTimeService</code>  每隔  <code>500ms</code>  尝试提交到  <code>FileChannel</code>  中进行刷盘，最后使用  <code>FlushRealTimeService</code>  来完成。<br>\n使用了缓冲区的目的是 多条数据合并写入，提高 <code>IO</code>  性能.</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p><code>RocketMQ</code>  使用  <code>FileChannel</code>  和  <code>MappedByteBuffer</code>  完成了消息的落盘。提供了三种持久化策略：</p>\n<ul>\n<li>同步刷盘：使用  <code>GroupCommitService</code>  线程，通过  <code>MappedByteBuffer</code>  的  <code>force</code>  方法将消息写入文件中，写入完成后才会返回  <code>ACK</code> .</li>\n<li>异步刷盘：消息写入  <code>pageCache</code>  之后，就立即返回  <code>ACK</code> . 使用  <code>FlushRealTimeService</code>  线程 通过  <code>FileChannel</code>  的  <code>force</code>  方法确保将消息写入文件.</li>\n<li>异步刷盘 + 开启缓冲区:  <code>RocketMQ</code>  申请一块直接内存用作数据缓冲区，消息先写入缓冲区，然后由  <code>CommitRealTimeService</code>  线程定时将缓冲区数据写入  <code>FileChannel</code>  ，再唤醒  <code>FlushRealTimeService</code>  将  <code>FileChannel</code>  缓冲区数据强制刷新到磁盘。</li>\n</ul>\n<p>回答一下文章开头的问题:<br>\n <code>RocketMQ</code>  是如何提高 数据读写的性能的呢？<br>\n <code>RocketMQ</code>  的大致做法是，将数据文件映射到 <code>OS</code>  的虚拟内存中（通过 <code>JDK</code>   <code>NIO</code>  的 <code>MappedByteBuffer</code> ），写消息的时候首先写入  <code>PageCache</code>  ，并通过异步刷盘的方式将消息批量的做持久化（同时也支持同步刷盘）；订阅消费消息时（对 <code>CommitLog</code>  操作是随机读取），由于 <code>PageCache</code>  的局部性热点原理且整体情况下还是从旧到新的有序读，因此大部分情况下消息还是可以直接从 <code>Page Cache</code> （ <code>cache hit</code> ）中读取，不会产生太多的缺页（ <code>Page Fault</code> ）中断而从磁盘读取。当然， <code>PageCache</code>  机制也不是完全无缺点的，当遇到 <code>OS</code>  进行脏页回写，内存回收，内存 <code>swap</code>  等情况时，就会引起较大的消息读写延迟。对于这些情况，  <code>RocketMQ</code>  采用了多种优化技术，比如内存预分配，文件预热，  <code>mlock</code>  系统调用等，来保证在最大可能地发挥  <code>PageCache</code>  机制优点的同时，尽可能地减少其缺点带来的消息读写延迟.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2022/05/16/rocketMQ/3-02-reliabllity-msg/",
            "url": "https://fangjiaxiaobai.github.io/2022/05/16/rocketMQ/3-02-reliabllity-msg/",
            "title": "RocketMQ 消息可靠性实现原理",
            "date_published": "2022-05-16T10:18:00.000Z",
            "content_html": "<p>常用的绝大多数消息队列，如  <code>RocketMQ</code> 、 <code>RabbitMQ</code>  等在消息传输上都只能保证<b>至少传输成功一次 ( <code>At least once</code> )</b>, 但是<b>不能保证只传输成功一次 ( <code>Exactly once</code> )</b>, 重复发送.</p>\n<h2 id=\"生产者保证消息可靠性\"><a class=\"markdownIt-Anchor\" href=\"#生产者保证消息可靠性\">#</a> 生产者保证消息可靠性</h2>\n<h3 id=\"消息发送方式\"><a class=\"markdownIt-Anchor\" href=\"#消息发送方式\">#</a> 消息发送方式</h3>\n<p>在之前的文章<a href=\"./2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF.md\">架构设计之消息</a> 中，我们知道了 生产者生产消息有三种方式:</p>\n<ul>\n<li>同步发送。 发送线程同步等待，通过同步检查 <code>Brocker</code>  返回的状态来判断消息是否持久化成功。从而保证消息的可靠性.</li>\n<li>异步发送。 发送线程异步等待，可以通过传入的回调函数来判断消息持久化状态。根据状态来判断是否需要重试消息，从而保证消息的可靠性.</li>\n<li><code>one way</code>  方式。 这种方式不能保证消息的可靠性。发送端发送完成之后，调用该发送接口后立刻返回，并不返回发送的结果。</li>\n</ul>\n<p>除了同步发送和异步发送这两种方式来保证消息可靠性之外.</p>\n<h3 id=\"重试机制\"><a class=\"markdownIt-Anchor\" href=\"#重试机制\">#</a> 重试机制</h3>\n<p>在发送消息的过程中， <code>Producer</code>  还有 消息发送的重试机制来<b>提高消息的可靠性</b>.</p>\n<p>如果 broker 只有一个节点，则 broker 宕机了，即使 producer 有重试机制，也没用，因此利用多主模式，当某台 broker 宕机了，换一台 broker 进行投递。</p>\n<p>当发送端需要发送消息时，如果发送端中缓存了 <code>topic</code>  的路由信息，并包含了消息队列，则直接返回该路由信息，如果没有缓存或没有消息队列，则向 <code>NameServer</code>  查询该 <code>topic</code>  的路由信息，查询到路由消息之后，采用指定的队列选择策略选择相应的 <code>queue</code>  发送消息，默认是采用轮询策略，发送成功则返回，收到异常则根据相应的策略进行重试，可以根据发送端感知到的 <code>Broker</code>  的时延、上次发送失败的 <code>Broker</code>  信息和发送端配置的是否重试不同 <code>Broker</code>  的参数以及发送端设置的最大超时时间等等策略来灵活地实现不同等级的消息发送可靠性保证。重试策略可以有效的保证消息发送成功的概率，最终提高消息发送的可靠性。</p>\n<p>总结两点:</p>\n<ul>\n<li><code>Producer</code>  选择一个  <code>MessageQueue</code>  发送消息时。默认轮询方式选择 <code>MessageQueue</code> ， 如果启用  <code>Broker</code>  端的故障延迟机制，则会判断  <code>MessageQueue</code>  的 <code>Broker</code>  是否可用，才发送消息到该  <code>Message</code>  中。</li>\n<li><code>Producer</code>  在使用 Sync 方式发送消息时会重新 <code>N</code>  次，  <code>N</code>  可由  <code>Producer</code>  端的配置决定的。</li>\n</ul>\n<h3 id=\"发送消息的返回状态\"><a class=\"markdownIt-Anchor\" href=\"#发送消息的返回状态\">#</a> 发送消息的返回状态</h3>\n<p>这里再补充一点， 同步方式发送成功，发送的状态是由  <code>SendStatus</code>  这个枚举类决定的.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SendStatus</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 发送成功</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SEND_OK,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 刷盘超时</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FLUSH_DISK_TIMEOUT,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 同步从节点超时</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FLUSH_SLAVE_TIMEOUT,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从节点 不可用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SLAVE_NOT_AVAILABLE,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>SEND_OK</code> : 表示消息发送成功。但是这个并不代表它是可靠的。 要确保消息不丢失，还需要启动同步  <code>Master</code>  服务器 或者同步刷盘， 即  <code>SYNC_MASTER</code>  和  <code>SYNC_FLUSH</code></li>\n<li><code>FLUSH_DISK_TIMEOUT</code> : 消息发送成功，但是刷盘超时。 此时消息已经进去了内存 ( <code>MessageQueue</code> ) 中，这种情况下，只有服务器宕机，消息才会丢失。</li>\n<li><code>FLUSH_SLAVE_TIMEOUT</code> : 消息发送成功，但是同步到  <code>SLAVE</code>  时超时。同样的。此时消息已经进去了内存 ( <code>MessageQueue</code> ) 中，这种情况下，只有服务器宕机，消息才会丢失。</li>\n<li><code>SLAVE_NOT_AVAILABLE</code> : 消息发送成功，但是没有  <code>SLAVE</code>  机器可用。</li>\n</ul>\n<p><code>FLUSH_DISK_TIMEOUT</code> ,  <code>FLUSH_SLAVE_TIMEOUT</code> ,  <code>SLAVE_NOT_AVAILABLE</code>  都是 <code>Broker</code>  端异常导致的不正常的情况。</p>\n<h2 id=\"broker的消息可靠性\"><a class=\"markdownIt-Anchor\" href=\"#broker的消息可靠性\">#</a> Broker 的消息可靠性</h2>\n<p>我们知道了 当消息发送成功，写入了  <code>MessageQueue</code>  但是没有持久到磁盘上的时候，就会造成消息的丢失。<br>\n在 官方的文档中， 提及到了 五种因为 <code>Broker</code>  端异常导致的消息可能会丢失的情况:</p>\n<ul>\n<li><code>Broker</code>  非正常关闭</li>\n<li><code>Broker</code>  异常 <code>Crash</code></li>\n<li><code>OS Crash</code></li>\n<li>机器掉电，但是能立即恢复供电情况</li>\n<li>机器无法开机（可能是 <code>cpu</code> 、主板、内存等关键设备损坏）</li>\n<li>磁盘设备损坏</li>\n</ul>\n<p>其中  <code>1-4</code>  属于硬件资源可立即恢复情况， <code>RocketMQ</code>  在这四种情况下能保证消息不丢 (同步刷盘)，或者丢失少量数据（异步刷盘）。<br>\n <code>5-6</code>  属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。 <code>RocketMQ</code>  在这两种情况下，通过异步复制，可保证 <code>99%</code>  的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与 Money 相关的应用。注： <code>RocketMQ</code>  从 <code>3.0</code>  版本开始支持同步双写。</p>\n<p>可以看出 Broker 端的消息可靠性主要通过 <b>单机情况下的刷盘策略</b> 和 <b>主从之间数据复制</b> 来保证的。</p>\n<h3 id=\"刷盘策略\"><a class=\"markdownIt-Anchor\" href=\"#刷盘策略\">#</a> 刷盘策略</h3>\n<p>在一个节点中，一条消息会从 Producer 发送给  <code>Broker</code>  ，  <code>Broker</code>  端把消息存储到  <code>MessageQueue</code>  中，也就是 内存中， 在  <code>RocketMQ</code>  的源码里才能出消息内容的结构是  <code>MappedFile</code>  , 然后通过 刷盘机制 (同步刷盘，异步刷盘) 写入到物理磁盘上。完成消息的持久化。</p>\n<p><img data-src=\"./images/3-03-01.png\" alt=\"\"></p>\n<p>在源码中 刷盘的线程 由  <code>FlushCommitLogService</code>  类表示。 这个类有三个子类:</p>\n<ul>\n<li><code>FlushRealTimeService</code> : 当配置为异步刷盘策略 并且没有开启  <code>TransientStorePool</code>  的时候，  <code>Broker</code>  会运行一个服务  <code>FlushRealTimeService</code>  用来刷新缓冲区的消息内容到磁盘，这个服务使用一个独立的线程来做刷盘这件事情，默认情况下每隔  <code>500ms</code>  来检查一次是否需要刷盘。</li>\n<li><code>CommitRealTimeService</code> : 异步刷盘且开启  <code>TransientStorePool</code>  ，使用  <code>CommitRealService</code>  。</li>\n<li><code>GroupCommitService</code> : 同步刷盘使用  <code>GroupCommitService</code>  .</li>\n</ul>\n<blockquote>\n<p><code>TransientStorePool</code>  是短暂的消息存储池。这里直接开辟默认 <code>5</code>  个 <code>1G</code>  的直接内存 <code>ByteBuffer</code> ，用来临时存储消息。它还引入了内存锁的机制，避免直接内存的数据被替换到系统中的 <code>Swap</code>  分区中，提高系统存储性能，使 <code>RocketMQ</code>  消息低延迟、高吞吐量。</p>\n</blockquote>\n<h4 id=\"同步刷盘\"><a class=\"markdownIt-Anchor\" href=\"#同步刷盘\">#</a> 同步刷盘</h4>\n<p><code>RocketMQ</code>  使用  <code>GroupCommitService</code>  这个对象来实现 同步刷盘。</p>\n<p>消息写入内存的  <code>PageCache</code>  后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。这种方式可以保证数据绝对安全，但是吞吐量不大。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Broker 不关闭时。</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 等待 10 毫秒</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">10</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 执行一次刷盘</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.doCommit();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">&quot; service has exception. &quot;</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 正常情况下shutdown，等待10ms 请求到来，然后flush到磁盘。</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      CommitLog.log.warn(<span class=\"string\">&quot;GroupCommitService Exception, &quot;</span>, e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.swapRequests();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.doCommit();</span><br><span class=\"line\"></span><br><span class=\"line\">  CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">&quot; service end&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中看出，当 <code>Broker</code>  正常关闭的时候，还是等待 <code>10ms</code>  的，等待这 <code>10ms</code>  内的请求。 处理完请求，将数据保存到磁盘上才会关闭线程。 细节满满。</p>\n<h4 id=\"异步刷盘\"><a class=\"markdownIt-Anchor\" href=\"#异步刷盘\">#</a> 异步刷盘</h4>\n<p>消息写入到内存的  <code>PageCache</code>  中，就立刻给客户端返回写操作成功，当  <code>PageCache</code>  中的消息积累到一定的量时，触发一次写操作，或者定时等策略将  <code>PageCache</code>  中的消息写入到磁盘中。这种方式吞吐量大，性能高，但是  <code>PageCache</code>  中的数据可能丢失，不能保证数据绝对的安全。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 省略部分代码...</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// flushCommitLogTimed 是否定时刷新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flushCommitLogTimed) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// interval为配置的是啊金</span></span><br><span class=\"line\">                Thread.sleep(interval);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.waitForRunning(interval);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 刷盘、 flushPhysicQueueLeastPages  每次刷新的页数。</span></span><br><span class=\"line\">            CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class=\"line\">            <span class=\"keyword\">long</span> storeTimestamp = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (storeTimestamp &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置检查点</span></span><br><span class=\"line\">                CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">&quot; service has exception. &quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.printFlushProgress();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 正常关闭时，保证在退出之前全部刷新到磁盘</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class=\"line\">        result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主从同步\"><a class=\"markdownIt-Anchor\" href=\"#主从同步\">#</a> 主从同步</h3>\n<p>在集群环境中， 如果一个  <code>Broker</code>  有  <code>master</code>  和  <code>slave</code>  时，就需要将  <code>master</code>  上的消息复制到  <code>slave</code>  上，复制的方式有两种:</p>\n<ul>\n<li>同步复制:  <code>master</code>  和  <code>slave</code>  均写成功，才返回客户端成功。  <code>master</code>  挂了以后可以保证数据不丢失。但是数据同步复制会增加数据延迟风险，降低吞吐量。简单说一下，同步复制其实是 在 CommitLog 将消息 刷盘之后，同步的方式将消息同步给  <code>Slave</code>  节点.</li>\n<li>异步复制:  <code>master</code>  写成功，返回客户端成功。 拥有较低的延迟和较高的吞吐量，但是当  <code>master</code>  出现故障后，有可能造成数据丢失。 异步复制的方式，其实是  <code>Slave</code>  节点中会启动一个  <code>HAService</code>  线程，定时的去同步 Master 节点的数据，延时大概在毫秒级。</li>\n</ul>\n<p>后面我们会有一篇文章专门介绍  <code>RocketMQ</code>  主从复制的实现细节。这里就不多做介绍了。</p>\n<h2 id=\"消费者的消息可靠性\"><a class=\"markdownIt-Anchor\" href=\"#消费者的消息可靠性\">#</a> 消费者的消息可靠性</h2>\n<p><code>RocketMQ</code>  在消费端 实现了  <code>At least Once</code>  机制，来保证消息的可靠性消费.</p>\n<p>什么是  <code>at lease once</code>  呢？</p>\n<p><code>consumer</code>  会把消息先 <code>pull</code>  到本地，消费完成之后，才向  <code>Broker</code>  端发送  <code>ack</code>  .</p>\n<p><code>RocketMQ</code>  有三种措施来实现可靠性.</p>\n<h3 id=\"消费重试\"><a class=\"markdownIt-Anchor\" href=\"#消费重试\">#</a> 消费重试</h3>\n<p>消费者从  <code>RocketMQ</code>  拉取到消息之后，需要返回消费成功来表示业务方正常消费完成。因此只有返回 CONSUME_SUCCESS 才算消费完成，如果返回  <code>CONSUME_LATER</code>  则会按照不同的  <code>messageDelayLevel</code>  时间进行再次消费，时间分级从秒到小时，最长时间为 2 个小时后再次进行消费重试，如果消费满  <code>16</code>  次之后还是未能消费成功，则不再重试，会将消息发送到死信队列，从而保证消息存储的可靠性。<br>\n这一措施主要是通过 延时消息队列来实现。</p>\n<h3 id=\"死信队列\"><a class=\"markdownIt-Anchor\" href=\"#死信队列\">#</a> 死信队列</h3>\n<p>未能成功消费的消息，消息队列并不会立刻将消息丢弃，而是将消息发送到死信队列，其名称是在原队列名称前加 <code>%DLQ%</code> ，如果消息最终进入了死信队列，则可以通过 <code>RocketMQ</code>  提供的相关接口从死信队列获取到相应的消息，保证了消息消费的可靠性。</p>\n<h3 id=\"消息回溯\"><a class=\"markdownIt-Anchor\" href=\"#消息回溯\">#</a> 消息回溯</h3>\n<p>回溯消费是指  <code>Consumer</code>  已经消费成功的消息，或者之前消费业务逻辑有问题，现在需要重新消费。要支持此功能，则  <code>Broker</code>  存储端在向  <code>Consumer</code>  消费端投递成功消息后，消息仍然需要保留。重新消费一般是按照时间维度，例如由于  <code>Consumer</code>  系统故障，恢复后需要重新消费 <code>1</code>  小时前的数据。 <code>RocketMQ Broker</code>  提供了一种机制，可以按照时间维度来回退消费进度，这样就可以保证只要发送成功的消息，只要消息没有过期，消息始终是可以消费到的。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2022/01/02/rocketMQ/3-01-RocketMQ-Transaction-msg/",
            "url": "https://fangjiaxiaobai.github.io/2022/01/02/rocketMQ/3-01-RocketMQ-Transaction-msg/",
            "title": "RocketMQ事务实现原理",
            "date_published": "2022-01-02T10:18:00.000Z",
            "content_html": "<p>最近有点浮躁，玩了一个周，没有写文章了。今天继续搞 <code>RocketMQ</code>  的事务实现。</p>\n<h2 id=\"往期文章\"><a class=\"markdownIt-Anchor\" href=\"#往期文章\">#</a> 往期文章</h2>\n<ul>\n<li><a href=\"/2021/09/03/rocketMQ/1-03-RocketMQ%E6%90%AD%E5%BB%BA/\">RocketMQ 搭建</a></li>\n<li><a href=\"/2021/09/28/rocketMQ/2-01-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%90%AF%E5%8A%A8/\">RocketMQ 架构设计之启动</a></li>\n<li><a href=\"/2021/09/28/rocketMQ/2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF/\">RocketMQ 架构设计之消息</a></li>\n</ul>\n<h2 id=\"分布式事务\"><a class=\"markdownIt-Anchor\" href=\"#分布式事务\">#</a> 分布式事务</h2>\n<p>分布式事务，是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。当然，分布式事务也是一个老生常谈的话题，尤其是面试中。常用的分布式事务解决方案有很多，比如：两阶段提交， <code>TCC</code> ， <code>SAGA</code>  等等。</p>\n<p>本篇文章，我主要看看  <code>RocketMQ</code>  的事务实现。</p>\n<h2 id=\"从一个例子开始\"><a class=\"markdownIt-Anchor\" href=\"#从一个例子开始\">#</a> 从一个例子开始</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事务消息的监听器。</span></span><br><span class=\"line\">TransactionListener transactionListener = <span class=\"keyword\">new</span> TransactionListenerImpl();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个 事务消息生产者</span></span><br><span class=\"line\">TransactionMQProducer producer = <span class=\"keyword\">new</span> TransactionMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">producer.setTransactionListener(transactionListener);</span><br><span class=\"line\">producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Message msg =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest1234&quot;</span>, <span class=\"string\">&quot;tag&quot;</span>, <span class=\"string\">&quot;KEY&quot;</span> + i,</span><br><span class=\"line\">            (<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class=\"line\">    <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">    SendResult sendResult = producer.sendMessageInTransaction(msg, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000L</span> * <span class=\"number\">60</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">producer.shutdown();</span><br></pre></td></tr></table></figure>\n<p>这里我们介绍下事务消息的常用的 <code>API</code>  吧。</p>\n<ul>\n<li><code>producer.setTransactionListener()</code> . 设置检测事务消息的回调。当定时任务执行检测到有事务消息时就会调用  <code>checkLocalTransaction</code>  方法。</li>\n<li><code>producer.setExecutorService(ExecutorService executorService)</code> : 设置检查事务的线程池。默认使用: <code>ThreadPoolExecutor</code> , 每分钟执行一次。</li>\n<li><code>producer.sendMessageInTransaction(final Message msg, final Object arg)</code> : 发送事务消息。</li>\n</ul>\n<p>从上面的这个案例来看， 发送事务消息 和 普通消息的发送并没有什么太大的不同，只是需要创建  <code>TransactionMQProducer</code>  和 使用  <code>sendMessageInTransaction</code>  发送消息就可以了。</p>\n<p>其中 <code>TransactionMQProducer</code>  继承了 <code>DefaultMQProducer</code> , 这个并不陌生了，我们在<a href=\"/2021/09/28/rocketMQ/2-01-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%90%AF%E5%8A%A8/\"> RocketMQ 架构设计之启动</a>这篇文章中，已经看过很多次了。而在启动时，案例中的 <code>producer.start();</code>  就是直接调用父类 <code>DefaultMQProducer</code>  的  <code>start()</code>  方法， <code>DefaultMQProducer</code>  会通过  <code>defaultMQProducerImpl.start()</code>  完成整个生产者部分的启动。这里就不多赘述了。</p>\n<p>我们来看最精彩的发送消息的过程.</p>\n<p><code>producer.sendMessageInTransaction(msg, null)</code></p>\n<p>我们一路追踪  <code>sendMessageInTransaction</code>  方法，很容易就看到了： <code>DefaultMQProducerImpl#sendMessageInTransaction</code></p>\n<p>这个方法主要有两个部分，如下图：</p>\n<p><img data-src=\"/images/rocketmq/3-01-01.png\" alt=\"\"></p>\n<p>第一部分：发送带有 事务标识 ( <code>TRAN_MSG</code> ) 的消息.<br>\n 第二部分：结束事务。 主要有提交  <code>offset</code> , 和 同步给  <code>Broker</code>  是  <code>commit</code>  还是  <code>rollback</code> .</p>\n<p><b>所以， <code>RocketMQ</code>  使用的分布式事务方案是：二阶段提交 (XA) </b></p>\n<h3 id=\"事务消息生产过程\"><a class=\"markdownIt-Anchor\" href=\"#事务消息生产过程\">#</a> 事务消息生产过程</h3>\n<p>发送消息的过程，在上篇文章中我们也已经说过了: <a href=\"/2021/09/28/rocketMQ/2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF/\">RocketMQ 系列 - 架构设计之消息</a>。 可以总结为 <code>3</code>  步，根据  <code>topic</code>  获取路由元数据， 选择适合的  <code>MessageQueue</code>  进行存储， 将  <code>Message</code>  通过  <code>Netty</code>  发送给  <code>Broker</code> .</p>\n<p>特别需要注意的时候，在发送事务消息的时候，会给消息添加事务标志。  <code>MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</code>  这里是干什么用的呢？接着往下看</p>\n<p><img data-src=\"/images/rocketmq/3-01-02.png\" alt=\"\"></p>\n<p><code>TransactionalMessageService</code>  和  <code>MessageStore</code>  这两种存储方式有什么不同呢？</p>\n<p>其实存储并没有什么不同，而是存储的消息是不一样的，我们继续往下看：</p>\n<p><img data-src=\"/images/rocketmq/3-01-03.png\" alt=\"\"></p>\n<p><code>TransactionalMessageService</code>   使用的存储和 普通消息都是一样的，都是在启动时候创建的  <code>MessageStore</code> . 不同的是，事务消息存储的 经过   <code>parseHalfMessageInner</code>  处理之后的 消息.</p>\n<p><img data-src=\"/images/rocketmq/3-01-04.png\" alt=\"\"></p>\n<p>可以看到，处理之后消息， <code>topic</code>  和  <code>queueId</code>  都被设置成了默认的   <code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code>  和 0。</p>\n<p><b>所以：事务消息会被存储到 默认的  <code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code>  中，并根据是否为延迟消息和延迟的等级存储到不同的  <code>MessageQueue</code>  中。</b></p>\n<p>开源 <code>RocketMQ</code>  支持延迟消息，但是不支持秒级精度。默认支持 <code>18</code>  个 <code>level</code>  的延迟消息，这是通过 <code>broker</code>  端的 <code>messageDelayLevel</code>  配置项确定的.</p>\n<p>具体延迟队列的实现，我们会在下一篇文章中详细的分析一下  <code>RocketMQ</code>  延时消息队列的实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure>\n<p>看完了，事务的第一个阶段，发送事务消息。 接下来，我们继续看第二个阶段。</p>\n<h3 id=\"结束事务-commit-or-callback\"><a class=\"markdownIt-Anchor\" href=\"#结束事务-commit-or-callback\">#</a> 结束事务: commit or callback.</h3>\n<p>结束事务主要是做两件事情:</p>\n<ul>\n<li>提交消息的偏移量</li>\n<li>发送提交事务还是回滚事务。</li>\n</ul>\n<p>实现逻辑如下图:</p>\n<p><img data-src=\"/images/rocketmq/3-01-05.png\" alt=\"\"></p>\n<p>主要的流程就是：封装 <code>RequestHeader</code> , 会设置 事务 <code>id</code> , 事务的状态。 然后设置本次请求的 <code>RequestCode</code>  为  <code>END_TRANSACTION(37)</code> .</p>\n<p>在  <code>Broker</code>  端 接收到对应的请求之后，会根据 事务的状态执行提交事务或者回滚操作。如右上图。</p>\n<p>我们从两方面来分析一下：</p>\n<h4 id=\"提交事务\"><a class=\"markdownIt-Anchor\" href=\"#提交事务\">#</a> 提交事务</h4>\n<p><img data-src=\"/images/rocketmq/3-01-06.png\" alt=\"\"></p>\n<p>可以看到 根据  <code>offset</code>  查到了消息，然后根据消息的状态封装成  <code>MessageExtBrokerInner</code>  对象。通过通过 <code>sendFianlMessage</code>  方法完成将消息写入到 消息原来的队列中 (不是默认的事务队列了). 最后删除  <code>prepare</code>  消息。如上图。</p>\n<h3 id=\"回滚事务\"><a class=\"markdownIt-Anchor\" href=\"#回滚事务\">#</a> 回滚事务</h3>\n<p><img data-src=\"/images/rocketmq/3-01-07.png\" alt=\"\"></p>\n<p>回滚事务就比较简单了，检查消息的状态，查看直接删除掉  <code>prepare</code>  消息就 OK 了。</p>\n<p>以上就是 整个事务消息的生产过程了。</p>\n<h3 id=\"事务回查\"><a class=\"markdownIt-Anchor\" href=\"#事务回查\">#</a> 事务回查</h3>\n<p>我们在介绍  <code>TranscationMQProducer</code>  的 <code>api</code>  时候，有一个  <code>setExecutorService(ExecutorService executorService)</code>  方法。 方法的作用是：设置检查事务的线程池。 这个线程池的作用就是 事务回查。</p>\n<p><img data-src=\"/images/rocketmq/3-01-08.png\" alt=\"\"></p>\n<p>我们追踪这个方法的调用方，可以发现，调用是  <code>NettyServer</code>  调用的，那是谁请求的呢？我们跟踪这个请求码发现在 Broker2Client 的类中发现了这个 请求码。 跟踪这个方法，查看其调用方，最终终于在  <code>TransactionalMessageCheckService</code>  发现了新大陆。<br>\n当我看到  <code>public class TransactionalMessageCheckService extends ServiceThread</code>  的时候，我就不禁想起了， Broker 在启动的时候会初始化事务，这是会创建一个  <code>TransactionalMessageCheckService</code>  对象.</p>\n<p>我们从  <code>Broker</code>  端开始还原一下这个事务回查的场景。</p>\n<p>在 Broker 端进行启动时会初识化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化事务逻辑</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialTransaction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transactionalMessageService = ServiceProvider.loadClass(ServiceProvider.TRANSACTION_SERVICE_ID, TransactionalMessageService.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.transactionalMessageService) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.transactionalMessageService = <span class=\"keyword\">new</span> TransactionalMessageServiceImpl(<span class=\"keyword\">new</span> TransactionalMessageBridge(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.getMessageStore()));</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;Load default transaction message hook service: &#123;&#125;&quot;</span>, TransactionalMessageServiceImpl.class.getSimpleName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Broker 检查事务状态的listner.。 Producer 写入 half 消息，但是没有收到 finalMessage .回调。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transactionalMessageCheckListener = ServiceProvider.loadClass(ServiceProvider.TRANSACTION_LISTENER_ID, AbstractTransactionalMessageCheckListener.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.transactionalMessageCheckListener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.transactionalMessageCheckListener = <span class=\"keyword\">new</span> DefaultTransactionalMessageCheckListener();</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;Load default discard message hook service: &#123;&#125;&quot;</span>, DefaultTransactionalMessageCheckListener.class.getSimpleName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transactionalMessageCheckListener.setBrokerController(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Broker 检查事务状态的线程。 Producer 写入 half 消息，但是没有收到 finalMessage.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.transactionalMessageCheckService = <span class=\"keyword\">new</span> TransactionalMessageCheckService(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里初始化了  <code>transactionalMessageCheckService</code>  和  <code>transactionalMessageCheckListener</code> . 然后在  <code>start</code>  方法中通过  <code>startProcessorByHa</code>  启动了  <code>transactionalMessageCheckService</code>  线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Broker的容灾处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class=\"line\">    startProcessorByHa(messageStoreConfig.getBrokerRole());</span><br><span class=\"line\">    handleSlaveSynchronize(messageStoreConfig.getBrokerRole());</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.registerBrokerAll(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样  <code>transactionalMessageCheckService</code>  就启动起来了。运行代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Start transaction check service thread!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 限制只有一个本类可以运行，最终会调用 onWaitEnd()</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.waitForRunning(checkInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;End transaction check service thread!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onWaitEnd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class=\"line\">    <span class=\"comment\">// 回查的最大次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Begin to check prepare message, begin time:&#123;&#125;&quot;</span>, begin);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 开始回查</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class=\"keyword\">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;End to check prepare message, consumed time:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在回查的过程中，  <code>RocketMQ</code>  会获取 事务 Topic 下的所有 MessageQueue.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 事务topic中下的所有MessageQueue.</span></span><br><span class=\"line\">String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class=\"line\">Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (msgQueues == <span class=\"keyword\">null</span> || msgQueues.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    log.warn(<span class=\"string\">&quot;The queue of topic is empty :&quot;</span> + topic);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后遍历所有的  <code>MessageQueue</code> ，按个处理所有队列里的待回查的消息。怎么判断消息需要回查呢？前面说过了，通过 <code>Op队列</code> 判断，因此还需要定位到 <code>HalfQueue</code>  对应的 <code>OpQueue</code> ，以及它们的 <code>ConsumeQueue</code>  偏移量， 获取到  <code>halfMessage</code> , 然后判断是否需要检测事务状态，如果需要检测则会调用  <code>AbstractTransactionalMessageCheckListener</code>  的  <code>resolveHalfMsg</code>  方法，即会发送 检测的请求 给  <code>Producer</code> .</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);</span><br></pre></td></tr></table></figure>\n<p><code>checkProducerTransactionState</code>  方法的实现则是： 向 Producer 端发送 请求码为 39 ( <code>RequestCode.CHECK_TRANSACTION_STATE</code> ) 的请求.</p>\n<p>如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RemotingCommand request =</span><br><span class=\"line\">    RemotingCommand.createRequestCommand(RequestCode.CHECK_TRANSACTION_STATE, requestHeader);</span><br><span class=\"line\">request.setBody(MessageDecoder.encode(messageExt, <span class=\"keyword\">false</span>));</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.brokerController.getRemotingServer().invokeOneway(channel, request, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    log.error(<span class=\"string\">&quot;Check transaction failed because invoke producer exception. group=&#123;&#125;, msgId=&#123;&#125;, error=&#123;&#125;&quot;</span>,</span><br><span class=\"line\">            group, messageExt.getMsgId(), e.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就触发了  <code>Producer</code>  的 事务回查。我们接着看、</p>\n<p>在  <code>ClientRemotingProcessor</code>  中可以看到  <code>CHECK_TRANSACTION_STATE</code>  的处理方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查事务状态</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> RequestCode.CHECK_TRANSACTION_STATE:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.checkTransactionState(ctx, request);</span><br></pre></td></tr></table></figure>\n<p>然后获取到  <code>Producer</code>  实例，通过  <code>producer</code>  开始回查事务.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询到对应的 Producer实例</span></span><br><span class=\"line\">MQProducerInner producer = <span class=\"keyword\">this</span>.mqClientFactory.selectProducer(group);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (producer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String addr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());</span><br><span class=\"line\">    <span class=\"comment\">// 开始回查。</span></span><br><span class=\"line\">    producer.checkTransactionState(addr, messageExt, requestHeader);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;checkTransactionState, pick producer by group[&#123;&#125;] failed&quot;</span>, group);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续跟踪这个  <code>checkTransactionState</code>  便看到了我们一开始说的这个事务回查了。</p>\n<p><img data-src=\"/images/rocketmq/3-01-08.png\" alt=\"\"></p>\n<p>其中  <code>checkExecutor</code>  就是一个线程池了，我们重点来看 回查的任务，即 图中的  <code>Runnable</code>  的实现。</p>\n<p>首先会 获取消息的事务状态，然后将消息的事务状态发送给 Broker。 这样就完成了 事务回查。</p>\n<p>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable request = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String brokerAddr = addr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageExt message = msg;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader checkRequestHeader = header;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String group = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.checkListener();</span><br><span class=\"line\">        TransactionListener transactionListener = getCheckListener();</span><br><span class=\"line\">        <span class=\"comment\">// 1、查看 消息事务的状态</span></span><br><span class=\"line\">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class=\"line\">        Throwable exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (transactionCheckListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            localTransactionState = transactionCheckListener.checkLocalTransactionState(message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (transactionListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;Used new check API in transaction message&quot;</span>);</span><br><span class=\"line\">            localTransactionState = transactionListener.checkLocalTransaction(message);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2、处理消息事务, 把事务的状态发送给 Broker。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.processTransactionState(localTransactionState, group, exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 处理消息事务。</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * 将消息事务的状态发送给 Broker</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> localTransactionState</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> producerGroup</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> exception</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processTransactionState</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">final</span> String producerGroup,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">final</span> Throwable exception)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 封装RequestHeader</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> EndTransactionRequestHeader thisHeader = <span class=\"keyword\">new</span> EndTransactionRequestHeader();</span><br><span class=\"line\">        thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());</span><br><span class=\"line\">        thisHeader.setProducerGroup(producerGroup);</span><br><span class=\"line\">        thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());</span><br><span class=\"line\">        thisHeader.swetFromTransactionCheck(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueKey == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            uniqueKey = message.getMsgId();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thisHeader.setMsgId(uniqueKey);</span><br><span class=\"line\">        thisHeader.setTransactionId(checkRequestHeader.getTransactionId());</span><br><span class=\"line\">        <span class=\"comment\">// 设置 事务的状态.</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (localTransactionState) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> COMMIT_MESSAGE:</span><br><span class=\"line\">                thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> ROLLBACK_MESSAGE:</span><br><span class=\"line\">                thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;when broker check, client rollback this transaction, &#123;&#125;&quot;</span>, thisHeader);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> UNKNOW:</span><br><span class=\"line\">                thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;when broker check, client does not know this transaction state, &#123;&#125;&quot;</span>, thisHeader);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        doExecuteEndTransactionHook(msg, uniqueKey, brokerAddr, localTransactionState, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向Broker端发送请求。</span></span><br><span class=\"line\">        DefaultMQProducerImpl.<span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, <span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上就是整个事务回查的过程了。这里我再来梳理一下执行的时序图。</p>\n<p><img data-src=\"/images/rocketmq/3-01-09.png\" alt=\"\"></p>\n<p>最后我们想一下，为什么 事务回查呢？<br>\n <code>Half</code>  消息写入成功，可能因为网络，服务重启等等原因没有收到 <code>Producer</code>  的事务状态请求，这是， <code>Broker</code>  就会主动放弃事务回查给 <code>Producer</code> . 来决定该事务消息是提交还是回滚。为了避免消息被无限次的回查，RocketMQ 通过 transactionCheckMax 属性设置消息回查的最大次数，默认是 15 次。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<ul>\n<li><code>RocketMQ</code>  的事务消息是使用 二阶段提交 ( <code>XA</code> ) 的这种分布式事务解决方案。</li>\n<li><code>RocketMQ</code>  第一阶段会发送带有 事务标志的消息给 <code>Broker</code> .  <code>Broker</code>  会把消息存储到固定的 Topic 中，并根据延迟级别存储到不同的 <code>queue</code>  中。</li>\n<li><code>RocketMQ</code>  第二阶段是结束事务，会提交 <code>offset</code> , 根据消息的事务状态提交或者回滚事务。</li>\n</ul>\n<p><code>RocketMQ</code>  通过改写  <code>Topic</code>  和  <code>queueId</code>  ，将消息暂时存储到的一个对 <code>Consumer</code>  不可见的队列中，然后等待 <code>Producer</code>  执行本地事务，提交事务装填后再决定将 <code>Half</code>  消息 <code>commit</code>  或者  <code>rollback</code> .</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/28/rocketMQ/2-02-RocketMQ-Arch-Message/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/28/rocketMQ/2-02-RocketMQ-Arch-Message/",
            "title": "RocketMQ系列-架构设计之消息",
            "date_published": "2021-09-28T11:26:00.000Z",
            "content_html": "<p>上一篇文章<a href=\"/2021/09/28/rocketMQ/2-01-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%90%AF%E5%8A%A8/\"> RocketMQ 架构设计之启动过程解析</a> 分析了  <code>NameServer</code> ,  <code>Broker</code> ,  <code>Producer</code> ,  <code>Consumer</code>  四个部分的启动过程，这边文章我们分析 <b>消息的收发过程</b>.</p>\n<h2 id=\"生产者发送消息过程解析\"><a class=\"markdownIt-Anchor\" href=\"#生产者发送消息过程解析\">#</a> 生产者发送消息过程解析</h2>\n<p>我们还是看上篇文章中的例子:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用GroupName初始化Producer</span></span><br><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定NameSrv的地址: 也可以通过环境变量NAMESRV_ADDR来指定，则不需要下面这一行。</span></span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;name-server1-ip:9876;name-server2-ip:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 启动实例</span></span><br><span class=\"line\">producer.start();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建消息实例,指定 topic, tag, message body.</span></span><br><span class=\"line\">    Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span> <span class=\"comment\">/* Topic */</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;TagA&quot;</span> <span class=\"comment\">/* Tag */</span>,</span><br><span class=\"line\">        (<span class=\"string\">&quot;Hello RocketMQ !!&quot;</span>).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class=\"comment\">/* Message body */</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">// 发送消息给Broker</span></span><br><span class=\"line\">    SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 关闭生产者</span></span><br><span class=\"line\">producer.shutdown();</span><br></pre></td></tr></table></figure>\n<p>在上一篇文中，我们是看到了  <code>producer.start();</code> , 现在我们接着来看  <code>producer.send(msg);</code>  的过程。上一篇文章中，有简单的介绍过消息的发送分为三步：</p>\n<ul>\n<li>获取  <code>topic</code>  的元数据信息，包括：路由信息，是否为有序队列， <code>MessageQueue</code>  列表，消息会发送的队列的索引。</li>\n<li>选择  <code>MessageQueue</code></li>\n<li>发送消息</li>\n</ul>\n<p>具体实现的代码在  <code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendDefaultImpl</code>  方法中。</p>\n<p>在消息的发送过程中，首先会校验当前 <code>Producer</code>  的运行状态，然后判断消息的 <code>group</code> , <code>topic</code>  等等是否为空。 合法之后，会获取 <code>topic</code>  的 <code>MessageQueue</code>  列表。从 <code>messageQueue</code>  列表中查找出一个发送的 <code>messageQueue</code> . 通过什么的机制选取 <code>MessageQueue</code>  呢？这里会涉及到一个  <code>Broker</code>  的延迟容错机制，下面我们会详解的介绍这个机制。当消息第一次过来的时候，会通过 <code>Random</code>  随机选择一个 <code>messageQueue</code> ，进行发送，如果发送失败，会将该 <code>messageQueue</code>  隔离起来，重试的时候，不会给这个  <code>messageQueue</code>  投递消息。选择出来了 <code>MessageQueue</code>  之后，进行发送消息，发送消息首先会根据 <code>BrokerName</code>  获取 <code>broker</code>  的地址，执行几个  <code>RpcHook</code> , 然后封装请求头，根据我们发送方式的不同，会选择对应的请求命令 ( <code>Send_Message</code> , <code>Send_Reply_Message</code> , <code>Send_Reply_Message_V2</code>  等等) 发送，消息发送完成之后，会更新 <code>Producer</code>  端的  <code>broker容错表</code> 。这样消息就发送出去了。</p>\n<h3 id=\"延迟容错机制\"><a class=\"markdownIt-Anchor\" href=\"#延迟容错机制\">#</a> 延迟容错机制</h3>\n<p><code>RocketMQ</code>  发送消息的时候，由于  <code>nameServer</code>  检测  <code>Broker</code>  是否存活是有延迟的，在 选择消息队列的时候，也可能遇到宕机的 <code>Broker</code> , 因网络问题发送失败的不时会发生，因次  <code>RocketMQ</code>  实现这种 高可用的设计方案。</p>\n<p>到底是怎么回事儿呢？</p>\n<p>我们从代码中看看端倪。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%99.png\" alt=\"\"></p>\n<p>文中图片我标注了两处代码</p>\n<h4 id=\"重试\"><a class=\"markdownIt-Anchor\" href=\"#重试\">#</a> 重试</h4>\n<p>当消息是 同步方式发送的时候，根据配置的属性进行重试，默认为 3 次。 如果是单向方式或者异步的方式进行发送时，则就会发送一次，不会重试。 可以看到确实可以从一定程度上提高消息发送成功的几率，但是，如果是 <code>broker</code>  宕机，重试只会增加时长。</p>\n<p>先不急着解决，我们看一下消息第一次发送是怎样的过程。 图中 2 处，会根据  <code>topicPublishInfo</code>  取出一个 <code>MessageQueue</code> 。 跟进代码：</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%992.png\" alt=\"\"></p>\n<p>然后接着进入代码</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%993.png\" alt=\"\"></p>\n<p>我们先假设  <code>sendLatencyFaultEnable = false</code> . 我们再看一下具体实现:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%994.png\" alt=\"\"></p>\n<p>其中  <code>sendWhichQueue</code>  字段就是上一次消息发送的 <code>MessageQueue List</code>  的下标。</p>\n<p>最后就是根据  <code>selectOneMessage()</code>  方法通过轮询的方式来选 <code>MessageQueue</code>  了。第一次是通过随机的方式来选出第一个  <code>MessageQueue</code>  的，重试的都是 轮询的去取了。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%995.png\" alt=\"\"></p>\n<p>那当:  <code>sendLatencyFaultEnable = true</code>  的时候呢？</p>\n<p><code>sendLatencyFaultEnable</code>  是什么意思呢？ 它表示是否启用  <code>Broker</code>  故障延迟机制。 看下图中的代码，我们假设 启用了  <code>Broker</code>  故障延迟机制。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%996.png\" alt=\"\"></p>\n<p>图中标注的部分上面的逻辑 和刚才 选择 <code>MessageQueue的</code> 机制是一样的。 那奥秘肯定是在下面的代码中了 (图中框选的部分)</p>\n<p><code>latencyFaultTolerance</code>  是什么呢？ <code>latencyFaultTolerance</code>  是一个接口，直译就是：延迟容错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 延迟容错</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LatencyFaultTolerance</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 更新失败的Broker。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name                 brokerName</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> currentLatency       本次消息发送的时长</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> notAvailableDuration 规避broker的时长</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> T name, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> notAvailableDuration)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断Broker是否可以用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name broker的名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从Broker故障列表中移除</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 弹出最后一个 Broker</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">pickOneAtLeast</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看一下  <code>latencyFaultTolerance.isAvailable(mq.getBrokerName())</code>  的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// faultItemTable 是一个 ConcurrentHashMap</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> FaultItem faultItem = <span class=\"keyword\">this</span>.faultItemTable.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (faultItem != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断该Broker(messageQueue)是否在规避时间内。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> faultItem.isAvailable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>faultItem.isAvailable()</code>  的实现如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (System.currentTimeMillis() - startTimestamp) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这两段代码中可以看出，判断  <code>Broker</code>  是否可用的判断依据就是：当前时间是否大于  <code>startTimeStamp</code> 。  <code>startTimeStamp</code>  标识 该 <code>Broker</code>  可以开始使用的时间。</p>\n<p>看到这里，一头雾水。  分区容错到底是什么东西呢？</p>\n<p>我们返回上一层，从框选的下面接着看：</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%996.png\" alt=\"\"></p>\n<p>如果还没有选出一个可用  <code>MessageQueue</code> ，则会中 故障的 <code>Broker</code>  列表中选出一个 <code>Broker</code> ，判断这个 broker 是否有 <code>MessageQueue</code> ，如果有则随机 (轮询) 的选一个，如果没有则从故障的 <code>Broker</code>  列表中移除一个，使用默认的机制选择一个 <code>MessageQueue</code>  投送消息。</p>\n<p>选择出来 <code>MessageQueue</code>  之后，就会发送消息了。</p>\n<p>发送完消息 还进行了一个操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 更新topic的一个MessageQueue 是否可用</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>这是干什么呢？ 我们直译过来 更新故障 (错误) 的条目。去看一下代码实现:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%997.png\" alt=\"\"></p>\n<p>可以看到最终是调用了  <code>MqFaultStrategty</code>  的  <code>updateFaultItem()</code>  方法。 这个方法中执行了两个方法， <code>computeNotAvailableDuration</code>  计算不可用的时长， 和   <code>latencyFaultTolerance</code>  的 <code>updateFaultItem</code>  方法。</p>\n<p>上图中贴出了  <code>computeNotAvailableDuration</code>  方法的实现。方法中使用了两个数组  <code>latencyMax</code>  和  <code>notAvailableDuration</code>  , 这两个数组就是延迟机制的核心了。数组的定义如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 延迟机制 - 本次消息发送时长区间，用于映射计算出需要规避Broker的时长。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] latencyMax = &#123;<span class=\"number\">50L</span>, <span class=\"number\">100L</span>, <span class=\"number\">550L</span>, <span class=\"number\">1000L</span>, <span class=\"number\">2000L</span>, <span class=\"number\">3000L</span>, <span class=\"number\">15000L</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 延迟机制 - 规避Broker的时长</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] notAvailableDuration = &#123;<span class=\"number\">0L</span>, <span class=\"number\">0L</span>, <span class=\"number\">30000L</span>, <span class=\"number\">60000L</span>, <span class=\"number\">120000L</span>, <span class=\"number\">180000L</span>, <span class=\"number\">600000L</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>方法中的形参  <code>currentlatency</code>  为本次消息发送的延迟时间。</p>\n<p>调用 <code>computeNotAvailableDuration</code>  方法的实参  <code>isolation</code>  表示该 <code>Broker</code>  是否需要规避。如果消息发送成功， <code>isolation</code>  就是 <code>false</code> , 反之，就是代表 <code>Broker</code>  需要被规避。从  <code>computeNotAvailableDuration</code>  方法的实现可以看出：其会根据 本校消息发送的延迟时间 从  <code>latencyMax</code>  数组尾部找到第一个 比  <code>currentlatency</code>  小的数组下标 <code>i</code> ，没有则返回 <code>0</code> ， 将  <code>notAvailableDuration[i]</code>  进行返回。 当 <code>isolation=true</code>  的时候，就会默认有 <code>10</code>  分钟的规避时长，反之，规避时长就会消息发送的延时是多少了。</p>\n<p>我们接着看  <code>latencyFaultTolerance</code>  的 <code>updateFaultItem</code>  方法</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-%20broker%E5%AE%B9%E9%94%998.png\" alt=\"\"></p>\n<p>图中对代码进行注释，不过多解释了。其中  <code>FaultItem</code>  是 存储故障 <code>broker</code>  的类，可以称为 失败条目，每个 <code>FaultItem</code>  存储了 <code>broker</code>  的名称，消息发送延迟的时长，故障规避结束的开始时间。</p>\n<p>那么更新这两个字段的值有什么作用呢？不知你是否有印象，刚才说有一头雾水的地方。</p>\n<p>在选择 <code>MessageQueue</code>  的时候，会判断 <code>messageQueue</code>  是否可用，调用了 故障容器接口的  <code>isAvalilable</code>  方法，方法就是根据  <code>startTimestamp</code>  来进行判断改队列是否可用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (System.currentTimeMillis() - startTimestamp) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果当前的系统时间大于故障规避开始时间，说明 <code>broker</code>  可以加入轮询的队伍里。</p>\n<p>以上就是 生产者发送消息 整个过程了。</p>\n<h3 id=\"生产者总结\"><a class=\"markdownIt-Anchor\" href=\"#生产者总结\">#</a> 生产者总结</h3>\n<p>我们知道了 生产者发送消息，三步完成，1. 获取 <code>topic</code>  的元数据信息，比如路由信息， <code>MessageQueue</code>  队列列表等， 2. 选择合适的 <code>MessageQueue</code> ，我们也着重介绍了  <code>Broker</code>  的故障延迟机制，这也是 <code>RocketMQ</code>  实现高可用的方式之一。 3. 发送消息，这里我们并没有过多的介绍，使用 <code>nettyClient</code>  将  <code>Message</code>  发送过  <code>Broker</code>  端。</p>\n<h2 id=\"broker-存储消息\"><a class=\"markdownIt-Anchor\" href=\"#broker-存储消息\">#</a> Broker 存储消息</h2>\n<p>上面我们分析了生产者发送消息的整体过程，尤其着重的分析了 生产者选择 <code>MessageQueue</code>  时候的容错机制。生产者会把消息发送给 <code>Broker</code> ，进行存储，存储是一个怎样的流程呢？</p>\n<p>我直接进入主题，从  <code>SendMessageProcessor</code>  说起。</p>\n<p>为什么上来就说 这个类呢？上篇文章中，我们分析了 <code>Broker</code>  的启动过程中，可以知道的  <code>Broker</code>  启动了 <code>NettyServer</code>  等待生产者，消费者发送来请求。这个  <code>SendMessageProcessor</code>  就是 <code>Broker</code>  接受生产者发送消息的处理器。</p>\n<p>具体的代码在  <code>org.apache.rocketmq.broker.BrokerController#registerProcessor</code>  中。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF1.png\" alt=\"\"></p>\n<p>根据之前的内容，我们已知 发送的消息有 事务消息，批量消息，单条的普通消息三种类型，并且  <code>RocketMQ</code>  支持同步存储和异步存储两种方式。所以 肯定是 <code>Broker</code>  端提供了这六种消息的存储方式。</p>\n<p>实际上，也确实支持了这 6 种方式。我们先从  <code>SendMessageProcessor</code>  的类继承关系来看一下  <code>Broker</code>  是如何进行消息存储，我也会按照这样的思路来行文。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF2.png\" alt=\"\"></p>\n<h3 id=\"接收同步消息\"><a class=\"markdownIt-Anchor\" href=\"#接收同步消息\">#</a> 接收同步消息</h3>\n<p>同步消息处理的本质上还是异步的处理方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response = asyncProcessRequest(ctx, request).get();</span><br></pre></td></tr></table></figure>\n<p>接着往下看</p>\n<h3 id=\"异步消息处理\"><a class=\"markdownIt-Anchor\" href=\"#异步消息处理\">#</a> 异步消息处理</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;RemotingCommand&gt; <span class=\"title\">asyncProcessRequest</span><span class=\"params\">(ChannelHandlerContext ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SendMessageContext mqtraceContext;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (request.getCode()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费者发送回来的消息(可能是消费失败之后的?)</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.asyncConsumerSendMsgBack(ctx, request);</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"comment\">// 处理生产者发送来的消息</span></span><br><span class=\"line\">                SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (requestHeader == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class=\"line\">                <span class=\"comment\">// 消息发送前的钩子。在消息发送之前，执行一些操作。</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (requestHeader.isBatch()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果是批量消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 不是批量消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到， <code>Broker</code>  不仅处理来自 生产者发送来的消息，还需要处理 消费者 消费失败重试的消息。消费者重试的消息这部分比较复杂，我们后面再分析。我们先看处理生产者发送来的消息这部分。</p>\n<p>代码中显示，会判断消息的类型，是否是批量消息，分别调用不同的方法，进行存储。如下图。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF3.png\" alt=\"\"></p>\n<p>上图中不是完整的代码，我删除了一些不重要的代码，可以看出来，不管是批量消息还是单条消息 (除事务消息) 都是交给了  <code>MessageStore</code>  进行存储的。 当然，事务消息是交给了  <code>TransactionalMessageService</code>  进行存储的，这个内容我们在分析 <code>RocketMQ</code>  事务消息的时候，会着重的分析，本文中就不做分析了。</p>\n<p>继续跟进代码</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF4.png\" alt=\"\"></p>\n<p><code>MessageStore</code>  只是对消息 和  <code>Broker</code>  进行了简单的校验，并没有真正的去存储消息。 而是把消息交给了  <code>commitLog</code>  进行存储消息。</p>\n<p>我们以单条消息为例，来看一下  <code>commitLog</code>  将消息存储到文件中的具体流程。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF5.png\" alt=\"\"></p>\n<p>如上图中，  <code>commitLog</code>  收到消息，首先会选择一个 <code>MappedFile</code> , 这个  <code>MappedFile</code>  代表 磁盘上的物理文件在内容中的映射。指代  <code>$HOME/store/commitlog</code>  目录下的文件。也代表了消息要写入的文件。  <code>MappedFile</code>  会把消息写到缓冲区中 (即右上图)， 消息顺利写完之后，就触发刷盘动作，刷盘有两种方式： 同步写盘和异步刷盘。 同步写盘是指等待  <code>FlushCommitLogService</code>  把消息真正写到物理磁盘上，然后再返回。异步刷盘是指 唤醒  <code>FlushCommitLogService</code>  执行的线程，不等待其是否真正把消息写入了物理磁盘中。 最后，会把消息同步到其他的副本服务中。</p>\n<h3 id=\"存储消息流程总结\"><a class=\"markdownIt-Anchor\" href=\"#存储消息流程总结\">#</a> 存储消息流程总结</h3>\n<p><code>Broker</code>  收到生产者发送的消息，会由  <code>SendMessageProcessor</code>  进行接收，然后会根据消息的类型单条消息，批量消息，还是事务消息，分别进行不同的处理。当然也会区分异步存储还是同步的存储消息。方法实现上本质还是调用 异步的方法来实现的， <code>SendMessageProcessor</code>  会把消息转交给  <code>CommitLog</code>  进行校验，会检查当前 <code>Broker</code>  和当前消息的状态，然后交给 <code>MappedFile</code>  真正的存储消息， <code>MappedFile</code>  表示存储消息的物理文件在内存中的映射，首先会把消息的内容写到缓冲区中，然后调用刷盘的方式 (同步写盘或者异步刷盘) 将消息真正的写到物理磁盘上。然后，将消息同步给其他副本。</p>\n<h3 id=\"再探讨一点细节\"><a class=\"markdownIt-Anchor\" href=\"#再探讨一点细节\">#</a> 再探讨一点细节</h3>\n<h4 id=\"获取mappedfile\"><a class=\"markdownIt-Anchor\" href=\"#获取mappedfile\">#</a> 获取 MappedFile</h4>\n<p>在 Broker 将消息写入 MappedFile 之前，就需要需要获取到一个 MappedFile 进行写入。如何获取的呢？</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF6.png\" alt=\"\"></p>\n<p>在 asyncPutMessages 方法中，有两处获取 MappedFile 的代码。</p>\n<p>第一处代码，倒是没有复杂的逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MappedFile <span class=\"title\">getLastMappedFile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MappedFile mappedFileLast = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mappedFileLast = <span class=\"keyword\">this</span>.mappedFiles.get(<span class=\"keyword\">this</span>.mappedFiles.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//continue;</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;getLastMappedFile has exception.&quot;</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mappedFileLast;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二处代码，稍有猫腻。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MappedFile <span class=\"title\">getLastMappedFile</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startOffset)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getLastMappedFile(startOffset, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF7.png\" alt=\"\"></p>\n<p>创建文件的代码和执行过程如上图所示，代码有删减。</p>\n<p>解释一下猫腻：创建  <code>MappedFile</code>  的时候，一次会创建两个 <code>MappedFile</code> , 这样下次就可以直接通过 一处的代码获取到  <code>MappedFile</code> ，而不用再去创建  <code>MappedFile</code>  了。 由于 真实的创建 <code>MappedFile</code>  是由 后台  <code>AllocateMappedFileService</code>  线程来创建的，所以也不会浪费时间。</p>\n<p>代码显示，会把  <code>AllocateRequest</code>  分别放到  <code>requestTable</code>  和  <code>requestQueue</code>  中。  <code>AllocateRequest</code>  是 创建  <code>MappedFile</code>  文件请求，  <code>requesetTable</code>  是一个  <code>concurrentHashMap</code>  ,  <code>key</code>  是文件的路径， <code>Value</code>  是  <code>AllocateRequest</code> 。 存储了 路径和 <code>AllocateRequest</code>  的映射关系。  <code>requestQueue</code> ，是请求的队列， <code>PriorityBlockingQueue</code> ，后台 <code>AllocateMappedFileService</code>  线程会 <code>requestQueue</code>  取出一个请求，分配的时候有两种策略，一种是使用 <code>Mmap</code>  的方式来构建 <code>MappedFile</code>  实例，另外一种是从 <code>TransientStorePool</code>  堆外内存池中获取相应的 <code>DirectByteBuffer</code>  来构建 <code>MappedFile</code> .</p>\n<h2 id=\"consumer-消费消息\"><a class=\"markdownIt-Anchor\" href=\"#consumer-消费消息\">#</a> Consumer 消费消息</h2>\n<p>在上一篇文章中，我们介绍了 消费者有两种实现:  <code>DefaultLitePullConsumerImpl</code>  和  <code>DefaultMQPushConsumerImpl</code> . 我们先暂时抛开这两种具体的实现方式。 从稍微高一点的角度来看一下消息者消费消息的逻辑。从 <b>消费者注册</b>, <b>负载均衡</b>，<b>拉取消息</b>，<b>消费消息</b> 这个思路来行文。</p>\n<h3 id=\"消息者注册\"><a class=\"markdownIt-Anchor\" href=\"#消息者注册\">#</a> 消息者注册</h3>\n<p>消费者启动后，每隔 <code>10ms</code>  会从  <code>NameServer</code>  查询一次用户订阅的所有话题路由信息.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 每10ms从NameServer拉取一下 TopicRouteInfo*/</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            MQClientInstance.<span class=\"keyword\">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">10</span>, <span class=\"keyword\">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>\n<p>更新 <code>topic</code>  路由信息在上篇文中已经介绍过了，这里就不详细的去介绍了，只是简单的串一下消息者消费消息的流程。</p>\n<p>除此之外，还有一下操作：</p>\n<ul>\n<li>每秒发送一次心跳检测.</li>\n<li>每 10s 持久化一次  <code>Consumer</code>  的 <code>offset</code> . 说到这类， 在启动的时候也会加载指定目录下的  <code>consumeOffset</code> .</li>\n<li>每分钟 扫描  <code>consumerTable</code>  自动调整线程池大小</li>\n</ul>\n<h3 id=\"消费者负载均衡\"><a class=\"markdownIt-Anchor\" href=\"#消费者负载均衡\">#</a> 消费者负载均衡</h3>\n<p>在消费者启动过程中，会启动  <code>RebalenceService</code> . 看名字就知道这是一个负载均衡服务。 什么作用呢？在任何一个消费者 启动，关闭，重置消费偏移 的时候，都会触发这个这个服务的重平衡操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本机 启动时=&gt;其他的消费者会受到 consumerIds发生变更的请求。</span></span><br><span class=\"line\"><span class=\"comment\">/** 5.启动负载均衡服务 org.apache.rocketmq.client.impl.factory.MQClientInstance#start*/</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.rebalanceService.start();</span><br><span class=\"line\"><span class=\"comment\">// 其他的消息者启动或者关闭时,即 consumerId 发生变动的时候 org.apache.rocketmq.client.impl.ClientRemotingProcessor#processRequest</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> RequestCode.NOTIFY_CONSUMER_IDS_CHANGED:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.notifyConsumerIdsChanged(ctx, request);</span><br><span class=\"line\"><span class=\"comment\">// 控制端 重置消费偏移量时 org.apache.rocketmq.client.impl.ClientRemotingProcessor#processRequest</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> RequestCode.RESET_CONSUMER_CLIENT_OFFSET:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.resetOffset(ctx, request);</span><br></pre></td></tr></table></figure>\n<p>重平衡操作发生了什么？</p>\n<p>我们都知道 在 <code>Broker</code>  端管理消息的最小单位是 <code>MessageQueue</code>  , 而不是  <code>topic</code> 。比如 当你发送了  <code>10</code>  条相同话题的消息，这  <code>10</code>  条话题可能存储在了不同  <code>Broker</code>  服务器的不同队列中。所以 当我们讨论消息队列负载均衡的时候，就是在讨论服务器端的所有队列如何给所有消费者消费的问题。在  <code>RocketMQ</code>  中，客户端有两种消费模式，一种是<b>广播模式</b>，另外一种是<b>集群模式</b>。</p>\n<p>我们现在假设总共有两台  <code>Broker</code>  服务器，假设用户使用  <code>Producer</code>  已经发送了  <code>8</code>  条消息，这  <code>8</code>  条消息现在均衡的分布在两台 Broker 服务器的  <code>8</code>  个队列中，每个队列中有一个消息。现在有  <code>3</code>  台消费者都订阅了  <code>Test</code>  话题的消费者实例，我们来看在不同消费模式下，不同的消费者会收到哪几条消息。</p>\n<h4 id=\"广播模式\"><a class=\"markdownIt-Anchor\" href=\"#广播模式\">#</a> 广播模式</h4>\n<p>这种方式下，每台消费者都会收到 <code>8</code>  条消息。所以，在广播的模式下，重平衡操作执行如下所示:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消费者的模式: 广播还是集群模式</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (messageModel) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 广播方式。</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> BROADCASTING: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// topicSubscribeInfoTable: 存储topic 对应的 MessageQueue 列表.</span></span><br><span class=\"line\">        Set&lt;MessageQueue&gt; mqSet = <span class=\"keyword\">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mqSet != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 更新 消费者消费订阅表。返回是否发生了变动。</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (changed) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果发生了变动，则根据不同的消费消费方式处理：</span></span><br><span class=\"line\">                <span class=\"comment\">// push,则需要通知给Broker，更新各个消费者的订阅关系。</span></span><br><span class=\"line\">                <span class=\"comment\">// pull,则会通知消费者，执行消费逻辑。</span></span><br><span class=\"line\">                <span class=\"keyword\">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, consumerGroup, topic, mqSet, mqSet);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ....:</span><br><span class=\"line\">    <span class=\"comment\">// 省略..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上面代码中的注释， 主要注意的是，广播模式下， <code>messageQueue</code>  发生变动，需要根据不同的消费方式 ( <code>pull</code> / <code>push</code> ), 执行不同的逻辑。</p>\n<ul>\n<li><code>push</code>  方式：会更新消息消费订阅表的版本，然后会通知 <code>Broker</code> ，触发 <code>consumerId</code>  变动。</li>\n<li><code>pull</code>  方式：会重新 <code>pull</code>  消息，执行 <code>pullTask</code> .</li>\n</ul>\n<h4 id=\"集群模式\"><a class=\"markdownIt-Anchor\" href=\"#集群模式\">#</a> 集群模式</h4>\n<p>集群模式是指所有的消息队列会按照某种分配策略来分给不同的消费者客户端。</p>\n<p>集群方式，不就是多个消费者协同的消费一个 <code>topic</code>  的数据吗，也就是说多个消费者协同的订阅 <code>topic</code>  下的多个消息队列 ( <code>MessageQueue</code> ). 那就需要一种策略去分配多个 <code>MessageQueue</code>  给每个消费者。</p>\n<p><code>RocktMQ</code>  提供了六种 <code>MessageQueue</code>  的消费策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当前消费者 需要消费哪几个消息队列中消息的分配策略。</span></span><br><span class=\"line\">AllocateMessageQueueStrategy strategy = <span class=\"keyword\">this</span>.allocateMessageQueueStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;MessageQueue&gt; allocateResult = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mqAll:当前topic和group下的消费队列列表.   cidAll: 所有消费队列的id.</span></span><br><span class=\"line\">    <span class=\"comment\">// 两者一一对应。</span></span><br><span class=\"line\">    allocateResult = strategy.allocate(<span class=\"keyword\">this</span>.consumerGroup, <span class=\"keyword\">this</span>.mQClientFactory.getClientId(),</span><br><span class=\"line\">        mqAll, cidAll);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Throwable e)&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>根据分配策略分配好自己要订阅的 <code>MessageQueue</code>  之后，就会 更新消费者消费订阅表。然后需要根据不同的消费方式 ( <code>pull</code> / <code>push</code> ), 执行不同的逻辑。</p>\n<ul>\n<li><code>push</code>  方式：会更新消息消费订阅表的版本，然后会通知 <code>Broker</code> ，触发 <code>consumerId</code>  变动。</li>\n<li><code>pull</code>  方式：会重新 <code>pull</code>  消息，执行 <code>pullTask</code> .</li>\n</ul>\n<p>我们就一起看下  <code>AllocateMessageQueueStrategy</code>  的六种实现。</p>\n<h5 id=\"平均哈希队列算法allocatemessagequeueaveragely\"><a class=\"markdownIt-Anchor\" href=\"#平均哈希队列算法allocatemessagequeueaveragely\">#</a> 平均哈希队列算法 (AllocateMessageQueueAveragely)</h5>\n<p>这种策略比较简单。举个例子来说明:</p>\n<p>假设有 <code>5</code>  个 <code>mq</code> ,  <code>3</code>  个消费者，那么消费者 <code>id</code>  为 <code>1</code>  的 <code>C1</code>  会订阅 <code>mq1,mq2</code> .   <code>C2=&gt;mq3,mq4</code> .   <code>C3=&gt;mq5</code> .<br>\n 假设有 <code>5</code>  个 <code>mq</code> ,  <code>6</code>  个消费者，那么订阅关系则为:  <code>C1=&gt;mq1</code> , <code>C2=&gt;mq2</code> , <code>C3=&gt;mq3</code> , <code>C4=&gt;mq4</code> , <code>C5=&gt;mq5</code> , <code>C6=&gt;[]</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cidAll: 消费者id列表</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID);</span><br><span class=\"line\"><span class=\"comment\">// mqAll: 消息队列的列表</span></span><br><span class=\"line\"><span class=\"comment\">// mod: 表示 有多个队列无法平均分配。</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4 &lt;= 5 ? 1 : (4 &gt; 0 &amp;&amp; 1 &lt; 4 ? 4 / 5 + 1 : 4 / 5)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> averageSize;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mqAll.size() &lt;= cidAll.size()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 队列比消费者少，每个消费者最大消费1个队列。</span></span><br><span class=\"line\">    averageSize = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不能平均分, 并且消费者的id比余数小。那么该消费者要多消费一个MessageQueue.</span></span><br><span class=\"line\">        averageSize = mqAll.size() / cidAll.size() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正好平均分 或者 当前消费者的id大于mod, 那么该消费者就平均分.</span></span><br><span class=\"line\">        <span class=\"comment\">// 会有两种情况: 1、mq有5个,consumer有5个， cid=5,则每个消费者都正好订阅一个mq</span></span><br><span class=\"line\">        <span class=\"comment\">// 2、mq有5个，consumer有6个,cid=6, 则该消费者不会订阅mq</span></span><br><span class=\"line\">        averageSize = mqAll.size() / cidAll.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//        int averageSize =</span></span><br><span class=\"line\"><span class=\"comment\">//            mqAll.size() &lt;= cidAll.size() ? 1 : (mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span></span><br><span class=\"line\"><span class=\"comment\">//                + 1 : mqAll.size() / cidAll.size());</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 订阅mq 的起始 索引. 比如5个mq，3个consumer, 那么,c1=&gt;m1,m2; c2=&gt;m3,m4; c3=&gt;m5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> startIndex = (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class=\"line\"><span class=\"keyword\">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; range; i++) &#123;</span><br><span class=\"line\">    result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n<h5 id=\"循环平均哈希队列算法allocatemessagequeueaveragelybycircle\"><a class=\"markdownIt-Anchor\" href=\"#循环平均哈希队列算法allocatemessagequeueaveragelybycircle\">#</a> 循环平均哈希队列算法 (AllocateMessageQueueAveragelyByCircle)</h5>\n<p>这种实现页是很简单的实现。举例来说明，不过多介绍了。</p>\n<p>假设有 <code>5</code>  个 <code>mq</code> ,  <code>3</code>  个消费者，那么订阅关系则为:<br>\n <code>C1=&gt;mq1,mq4</code> .<br>\n <code>C2=&gt;mq2,mq5</code> .<br>\n <code>C3=&gt;mq3</code> .</p>\n<p>假设有 <code>5</code>  个 <code>mq</code> ,  <code>6</code>  个消费者，那么订阅关系则为:  <code>C1=&gt;mq1</code> , <code>C2=&gt;mq2</code> , <code>C3=&gt;mq3</code> , <code>C4=&gt;mq4</code> , <code>C5=&gt;mq5</code> , <code>C6=&gt;[]</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index: 表示第index个消费者</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = index; i &lt; mqAll.size(); i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环分配给消费者。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i % cidAll.size() == index) &#123;</span><br><span class=\"line\">        result.add(mqAll.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"一致性哈希队列算法allocatemessagequeueconsistenthash\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希队列算法allocatemessagequeueconsistenthash\">#</a> 一致性哈希队列算法 (AllocateMessageQueueConsistentHash)</h5>\n<p>这个算法实现起来比较复杂，涉及到了一个分布式算法，一致性哈希算法。</p>\n<p>具体的算法实现内容可以参考: <a href=\"/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/\">哈希算法</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 哈希环的节点</span></span><br><span class=\"line\">Collection&lt;ClientNode&gt; cidNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String cid : cidAll) &#123;</span><br><span class=\"line\">    cidNodes.add(<span class=\"keyword\">new</span> ClientNode(cid));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一致性哈希的Router</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ConsistentHashRouter&lt;ClientNode&gt; router;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (customHashFunction != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    router = <span class=\"keyword\">new</span> ConsistentHashRouter&lt;&gt;(cidNodes, virtualNodeCnt, customHashFunction);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    router = <span class=\"keyword\">new</span> ConsistentHashRouter&lt;&gt;(cidNodes, virtualNodeCnt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将MQf通过Router分配给消费者</span></span><br><span class=\"line\">List&lt;MessageQueue&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class=\"line\">    ClientNode clientNode = router.routeNode(mq.toString());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clientNode != <span class=\"keyword\">null</span> &amp;&amp; currentCID.equals(clientNode.getKey())) &#123;</span><br><span class=\"line\">        results.add(mq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> results;</span><br></pre></td></tr></table></figure>\n<p>这种算法的好处也特别明显：当有消费者加入或者退出的时候，不会移动跨节点的 <code>MQ</code>  分配情况。</p>\n<h5 id=\"通过配置的属性分配队列allocatemessagequeuebyconfig\"><a class=\"markdownIt-Anchor\" href=\"#通过配置的属性分配队列allocatemessagequeuebyconfig\">#</a> 通过配置的属性分配队列 (AllocateMessageQueueByConfig)</h5>\n<p>这种算法就是 根据配置的 <code>MQ</code> , 进行消费。</p>\n<p>通过  <code>set</code>  方法设置该消费者要消费的 <code>MQ</code> ,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMessageQueueList</span><span class=\"params\">(List&lt;MessageQueue&gt; messageQueueList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.messageQueueList = messageQueueList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分配方法则，直接将  <code>messageQueueList</code>  返回即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.messageQueueList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"机房hash队列算法allocatemessagequeuebymachineroom\"><a class=\"markdownIt-Anchor\" href=\"#机房hash队列算法allocatemessagequeuebymachineroom\">#</a> 机房 Hash 队列算法 (AllocateMessageQueueByMachineRoom)</h5>\n<p>这个算法 和 循环平均哈希队列算法 是一样的。只不过是根据  <code>brokerName</code>  进行 <code>Hash</code>  计算的。</p>\n<p>举个例子来说:</p>\n<p>假设 5 个 <code>mq</code>  ( <code>fxb-test01@fxb.com</code> , <code>fxb-test02@fxb.com</code> , <code>fxb-test03@fxb.com</code> , <code>fxb-test04@fxb.com</code> , <code>fxb-test05@fxb.com</code> ),3 个消费者。则订阅关系如下:<br>\n <code>C1=&gt;mq1,mq4</code> .<br>\n <code>C2=&gt;mq2,mq5</code> .<br>\n <code>C3=&gt;mq3</code> .</p>\n<p>代码实现如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;MessageQueue&gt; premqAll = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class=\"line\">    String[] temp = mq.getBrokerName().split(<span class=\"string\">&quot;@&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp.length == <span class=\"number\">2</span> &amp;&amp; consumeridcs.contains(temp[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">        premqAll.add(mq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mod = premqAll.size() / cidAll.size();</span><br><span class=\"line\"><span class=\"keyword\">int</span> rem = premqAll.size() % cidAll.size();</span><br><span class=\"line\"><span class=\"keyword\">int</span> startIndex = mod * currentIndex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> endIndex = startIndex + mod;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class=\"line\">    result.add(premqAll.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rem &gt; currentIndex) &#123;</span><br><span class=\"line\">    result.add(premqAll.get(currentIndex + mod * cidAll.size()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n<h5 id=\"基于机房远近优先allocatemachineroomnearby\"><a class=\"markdownIt-Anchor\" href=\"#基于机房远近优先allocatemachineroomnearby\">#</a> 基于机房远近优先 (AllocateMachineRoomNearby)</h5>\n<p>这种算法会根据消费者的命名来区分。比如相同机房的消费者有相同的命名格式: <code>beijing-mxy-001</code> , <code>beijing-mxy-002...</code>  ，那么这类的消费者和 <code>MQ</code>  会被认为属于同一个机房。<b>在同一个机房内的 <code>MQ</code>  会优先被本机房的消费者进行消费</b> 如果本机房内没有存活的消费者，那该机房中的 <code>MQ</code>  会被所有的消费者所共享。  至于某一个消费者会订阅哪个 <code>MQ</code> ，则由具体指定的分配策略来分配。具体如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  根据机房分组 broker,</span></span><br><span class=\"line\">Map&lt;String<span class=\"comment\">/*machine room */</span>, List&lt;MessageQueue&gt;&gt; mr2Mq = <span class=\"keyword\">new</span> TreeMap&lt;String, List&lt;MessageQueue&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class=\"line\">    String brokerMachineRoom = machineRoomResolver.brokerDeployIn(mq);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isNoneEmpty(brokerMachineRoom)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mr2Mq.get(brokerMachineRoom) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mr2Mq.put(brokerMachineRoom, <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mr2Mq.get(brokerMachineRoom).add(mq);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Machine room is null for mq &quot;</span> + mq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据机房分组consumer</span></span><br><span class=\"line\">Map&lt;String<span class=\"comment\">/*machine room */</span>, List&lt;String<span class=\"comment\">/*clientId*/</span>&gt;&gt; mr2c = <span class=\"keyword\">new</span> TreeMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String cid : cidAll) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据cid判断出所属的机房==&gt; 相同机房的消费需要有相同的命名格式.</span></span><br><span class=\"line\">    String consumerMachineRoom = machineRoomResolver.consumerDeployIn(cid);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isNoneEmpty(consumerMachineRoom)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mr2c.get(consumerMachineRoom) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mr2c.put(consumerMachineRoom, <span class=\"keyword\">new</span> ArrayList&lt;String&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mr2c.get(consumerMachineRoom).add(cid);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Machine room is null for consumer id &quot;</span> + cid);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;MessageQueue&gt; allocateResults = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算当前consumer可以消费的MQ. 当前机房有多个消费者的时候，则使用真正分配策略(其他的分配策略)进行分配。</span></span><br><span class=\"line\"><span class=\"comment\">// 1.allocate the mq that deploy in the same machine room with the current consumer</span></span><br><span class=\"line\">String currentMachineRoom = machineRoomResolver.consumerDeployIn(currentCID);</span><br><span class=\"line\">List&lt;MessageQueue&gt; mqInThisMachineRoom = mr2Mq.remove(currentMachineRoom);</span><br><span class=\"line\">List&lt;String&gt; consumerInThisMachineRoom = mr2c.get(currentMachineRoom);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mqInThisMachineRoom != <span class=\"keyword\">null</span> &amp;&amp; !mqInThisMachineRoom.isEmpty()) &#123;</span><br><span class=\"line\">    allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, mqInThisMachineRoom, consumerInThisMachineRoom));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.allocate the rest mq to each machine room if there are no consumer alive in that machine room</span></span><br><span class=\"line\"><span class=\"comment\">// 如果当前机房没有存活的消费者，那么当前机房的MQ会被所有的消费者共享。根据真实的分配策略进行分配</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String machineRoom : mr2Mq.keySet()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mr2c.containsKey(machineRoom)) &#123; <span class=\"comment\">// no alive consumer in the corresponding machine room, so all consumers share these queues</span></span><br><span class=\"line\">        allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, mr2Mq.get(machineRoom), cidAll));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> allocateResults;</span><br></pre></td></tr></table></figure>\n<p>以上就是 <code>RocketMQ</code>  使用的负载均衡的内容了，当然，我们也可以自定义 分配策略。只需要实现  <code>AllocateMessageQueueStrategy</code>  , 在创建消费者实例的时候使用就好了。</p>\n<h3 id=\"拉取消息\"><a class=\"markdownIt-Anchor\" href=\"#拉取消息\">#</a> 拉取消息</h3>\n<p>我们知道的是， RocketMQ 支持两种消费者类型，一种是推送方式的，一种是主动拉取消息。</p>\n<p>这里我们先从拉取消息说起。  你懂的，我们是要讲的是:  <code>DefaultLitePullConsumer</code> .</p>\n<h4 id=\"defaultlitepullconsumer\"><a class=\"markdownIt-Anchor\" href=\"#defaultlitepullconsumer\">#</a> DefaultLitePullConsumer</h4>\n<p><code>DefaultLitePullConsumer</code> ，会为每个  <code>messageQueue</code>  创建一个 <code>PullTaskImpl</code> .  它会定时的从  <code>Broker</code>  端拉取消息。然后封装成  <code>PullRequest</code> , 放到  <code>consumeRequestCache</code>  这个阻塞队列中， 然 后  <code>DefaultLitePullConsumer</code>  会调用 <code>poll</code>  方法，获取 List<MessageExt>, 这样就算是消费完成了。</p>\n<p>是客户端 定时任务主动想 <code>Broker</code>  端发送请求，拉取消息。</p>\n<p>而 推的方式，就不是这么简单了。</p>\n<h4 id=\"defaultmqpushconsumer\"><a class=\"markdownIt-Anchor\" href=\"#defaultmqpushconsumer\">#</a> DefaultMQPushConsumer</h4>\n<p>这还是要从 <code>Broker</code>  端存储完消息之后说起，Broker 会运行一个  <code>ReputMessageService</code> . 这是一个线程，有什么作用呢？<br>\n 它是推送消息的线程，负责将写入 <code>CommitLog</code>  的消息推送给对应的消费者。</p>\n<p>这里会有两个问题:</p>\n<ul>\n<li>1、 <code>ReputMessageService</code>  怎么知道要去推送消息给消费者呢</li>\n</ul>\n<p><code>ReputMessageService</code>  每隔 1 秒会检查一下这个  <code>CommitLog</code>  是否有新的数据写入。 <code>ReputMessageService</code>  自身维护了一个偏移量  <code>reputFromOffset</code> ，用以对比和  <code>CommitLog</code>  文件中的消息总偏移量的差距。当这两个偏移量不同的时候，就代表有新的消息到来了。</p>\n<p>如下图:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-03-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF.png\" alt=\"\"></p>\n<ul>\n<li><code>ReputMessageService</code>  是怎样推送消息的</li>\n</ul>\n<p>从上图中可以看见，  <code>ReputMessageService</code>  封装了一个  <code>DispatchRequest</code> ，然后通过  <code>DefaultMessageStore.doDispatch</code>  方法，转发了出去。虽说是转发了出去，但是并非直接发送给了消费者。</p>\n<p>而是转发给了  <code>CommitLogDispatcherBuildConsumeQueue</code> . 它主要是根据这条请求按照不同的队列  <code>ID</code>  创建不同的消费队列文件，并在内存中维护一份消费队列列表。然后将  <code>DispatchRequest</code>  请求中这条消息的消息偏移量、消息大小以及消息在发送时候附带的标签的  <code>Hash</code>  值写入到相应的消费队列文件中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putMessagePositionInfo</span><span class=\"params\">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class=\"line\">    ConsumeQueue cq = <span class=\"keyword\">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class=\"line\">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后台通过 <code>FlushConsumeQueueService</code>  线程来定时的持久化到磁盘中，写文件和  <code>Broker</code>  写入 <code>MappedLogFile</code>  一样。只是位置不同。</p>\n<p>好家伙，到现在还没有给消息推送消息，自己先存起来了。</p>\n<p>而事实上，RocketMQ 并没有实现 Broker 端 发送消息给 消费者。 推模型的消息消费模式，是通过拉模式实现的。</p>\n<p>这里需要区分 广播模式 和 集群模型分开来说了。</p>\n<h5 id=\"广播模式-2\"><a class=\"markdownIt-Anchor\" href=\"#广播模式-2\">#</a> 广播模式</h5>\n<p>每个消费队列的偏移量肯定不能存储在  <code>Broker</code>  服务器端，因为多个消费者对于同一个队列的消费可能不一致，偏移量会互相覆盖掉。因此，在广播模式下，每个客户端的消费偏移量是存储在本地的，然后每隔  <code>5</code>  秒将内存中的  <code>offsetTable</code>  持久化到磁盘中。当首次从服务器获取可消费队列的时候，偏移量是直接从本地文件中读取的。</p>\n<h5 id=\"集群模式-2\"><a class=\"markdownIt-Anchor\" href=\"#集群模式-2\">#</a> 集群模式</h5>\n<p>在集群模式下，由于每个客户端所消费的消息队列不同，所以每个消息队列已经消费到哪里的消费偏移量是记录在  <code>Broker</code>  服务器端的。</p>\n<p>消费者客户端在内存中维护了一个  <code>offsetTable</code>  表，在  <code>Broker</code>  服务器端也维护了一个偏移量表。在消费者客户端， <code>RebalanceService</code>  服务会定时地 (默认 20 秒) 从  <code>Broker</code>  服务器获取当前客户端所需要消费的消息队列，并与当前消费者客户端的消费队列进行对比，看是否有变化。对于每个消费队列，会从  <code>Broker</code>  服务器查询这个队列当前的消费偏移量。然后根据这几个消费队列，创建对应的拉取请求  <code>PullRequest</code>  准备从  <code>Broker</code>  服务器拉取消息。当从  <code>Broker</code>  服务器拉取下来消息以后，只有当用户成功消费的时候，才会更新本地的偏移量表。本地的偏移量表再通过定时服务每隔  <code>5</code>  秒同步到  <code>Broker</code>  服务器端，维护在  <code>Broker</code>  服务器端的偏移量表也会每隔  <code>5</code>  秒钟序列化到磁盘中.</p>\n<p>那么重点来了，创建的 <code>PullRequest</code>  就会被放到  <code>pullRequestQueue</code>  中。</p>\n<h4 id=\"拉取消息-2\"><a class=\"markdownIt-Anchor\" href=\"#拉取消息-2\">#</a> 拉取消息</h4>\n<p>在 消费者启动 一文中，可以知道 消费者启动后，后台会一直运行一个  <code>PullMessageService</code>  线程。它会阻塞的从  <code>pullRequestQueue</code>  中获取  <code>PullRequest</code>  向 <code>Broker</code>  端发送请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 出队</span></span><br><span class=\"line\">            PullRequest pullRequest = <span class=\"keyword\">this</span>.pullRequestQueue.take();</span><br><span class=\"line\">            <span class=\"comment\">// 拉取消息</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.pullMessage(pullRequest);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pullRequestQueue</code>  便是  <code>pull Message Request Queue</code>  了。(拉取消息请求的队列了)</p>\n<p>当真正尝试拉取消息之前，其会检查当前请求的内部缓存的消息数量、消息大小、消息阈值跨度是否超过了某个阈值，如果超过某个阈值，则推迟  <code>50</code>  毫秒重新执行这个请求，当执行完一些必要的检查之后，客户端会将用户指定的过滤信息以及一些其它必要消费字段封装到请求信息体中，然后才开始从  <code>Broker</code>  服务器拉取这个请求从当前偏移量开始的消息，默认一次性最多拉取  <code>32</code>  条，服务器返回的响应会告诉客户端这个队列下次开始拉取时的偏移量。客户端每次都会注册一个  <code>PullCallback</code>  回调，用以接受服务器返回的响应信息，根据响应信息的不同状态信息，然后修正这个请求的偏移量，并进行下次请求。</p>\n<p>对了，都有些什么时候会将  <code>PullRequest</code>  放入  <code>pullRequestQueue</code>  中的呢？</p>\n<ul>\n<li>重平衡的时候\n<ul>\n<li>有消费者加入，发生重平衡</li>\n<li>定时任务，发送重平衡。</li>\n</ul>\n</li>\n<li>消息消费失败，重试。</li>\n<li>启动的时候。</li>\n</ul>\n<p>这些都是会触发拉取消息的。</p>\n<p>最后，终于到最后一步了，消费消息。</p>\n<h4 id=\"消费消息\"><a class=\"markdownIt-Anchor\" href=\"#消费消息\">#</a> 消费消息</h4>\n<p>当把消息放在  <code>PullRequestQueue</code>  这个阻塞队列中之后，后台线程会不断从这个阻塞队列中获取  <code>PullRequest</code> . 如下图代码中所示。拿到了  <code>PullRequest</code>  则会提交了一个  <code>ConsumeRequest</code> . 我想这又被你猜到了。哈哈。这里将  <code>ConsumeRequest</code>   <code>submit</code>  给了一个后台线程  <code>consumeExecutor</code> 。接着往下看吧。该线程会每分钟执行一次。进行消息消费。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF8.png\" alt=\"\"></p>\n<p>依赖于用户指定的消息回调函数的不同，消息的消费分为两种：并发消费和有序消费。</p>\n<p>并发消费没有考虑消息发送的顺序，客户端从服务器获取到消息就会直接回调给用户。而有序消费会考虑每个队列消息发送的顺序，注意此处并不是每个话题消息发送的顺序，一定要记住  <code>RocketMQ</code>  控制消息的最细粒度是消息队列。当我们讲有序消费的时候，就是在说对于某个话题的某个队列，发往这个队列的消息，客户端接受消息的顺序与发送的顺序完全一致。</p>\n<h5 id=\"并发消费\"><a class=\"markdownIt-Anchor\" href=\"#并发消费\">#</a> 并发消费</h5>\n<p>当用户注册消息回调类的时候，如果注册的是  <code>MessageListenerConcurrently</code>  回调类，那么就认为用户不关心消息的顺序问题。我们在上文提到过每个  <code>PullRequest</code>  都关联了一个处理队列  <code>ProcessQueue</code> ，而每个处理队列又都关联了一颗消息树  <code>msgTreeMap</code> 。当客户端拉取到新的消息以后，其先将消息放入到这个请求所关联的处理队列的消息树中，然后提交一个消息消费请求，用以回调用户端的代码消费消息.</p>\n<p>提交给  <code>consumeExecutor</code>  之后，  <code>ConsumeRequest</code>  实现逻辑如下:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF9.png\" alt=\"\"></p>\n<h5 id=\"有序消费\"><a class=\"markdownIt-Anchor\" href=\"#有序消费\">#</a> 有序消费</h5>\n<p><code>RocketMQ</code>  的有序消费主要依靠两把锁，一把是维护在  <code>Broker</code>  端，一把维护在消费者客户端。 <code>Broker</code>  端有一个  <code>RebalanceLockManager</code>  服务，其内部维护了一个  <code>mqLockTable</code>  消息队列锁表:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-02-Broker%E6%B6%88%E6%81%AF10.png\" alt=\"\"></p>\n<p>在有序消费的时候， <code>Broker</code>  需要确保任何一个队列在任何时候都只有一个客户端在消费它，都在被一个客户端所锁定。当客户端在本地根据消息队列构建  <code>PullRequest</code>  之前，会与  <code>Broker</code>  沟通尝试锁定这个队列，另外当进行有序消费的时候，客户端也会周期性地 (默认是  <code>20</code>  秒) 锁定所有当前需要消费的消息队列.</p>\n<p>代码逻辑如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 顺序消费</span></span><br><span class=\"line\"><span class=\"comment\">* 每秒 定时多实例消费的所有队列，上锁成功将 ProcessQueue的lock属性设置为true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123; <span class=\"comment\">/// 只支持集群模式</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.lockMQPeriodically();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span> * <span class=\"number\">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在  <code>Broker</code>  这端，每个客户端所锁定的消息队列对应的锁项  <code>LogEntry</code>  有一个上次锁定时的时间戳，当超过锁的超时时间 (默认是 60 秒) 后，也会判定这个客户端已经不再持有这把锁，以让其他客户端能够有序消费这个队列。</p>\n<p>在前面我们说到过  <code>RebalanceService</code>  均衡服务会定时地依据不同消费者数量分配消费队列。我们假设  <code>Consumer-1</code>  消费者客户端一开始需要消费  <code>3</code>  个消费队列，这个时候又加入了  <code>Consumer-2</code>  消费者客户端，并且分配到了  <code>MessageQueue-2</code>  消费队列。当  <code>Consumer-1</code>  内部的均衡服务检测到当前消费队列需要移除  <code>MessageQueue-2</code>  队列，这个时候，会首先解除  <code>Broker</code>  端的锁，确保新加入的  <code>Consumer-2</code>  消费者客户端能够成功锁住这个队列，以进行有序消费。</p>\n<p>消费者客户端每一次拉取消息请求，如果有发现新的消息，那么都会将这些消息封装为  <code>ConsumeRequest</code>  来喂给消费线程池，等待消费。如果消息特别多，这样一个队列可能有多个消费请求正在等待客户端消费，用户可能会先消费偏移量大的消息，后消费偏移量小的消息。所以消费同一队列的时候，需要一把锁以消费请求顺序化。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeMessageOrderlyService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsumeMessageService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeRequest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ProcessQueue processQueue;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageQueue messageQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumeRequest</span><span class=\"params\">(ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.processQueue = processQueue;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.messageQueue = messageQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> ProcessQueue <span class=\"title\">getProcessQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> processQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">getMessageQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> messageQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class=\"keyword\">this</span>.messageQueue);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (objLock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())|| (<span class=\"keyword\">this</span>.processQueue.isLocked() &amp;&amp; !<span class=\"keyword\">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> continueConsume = <span class=\"keyword\">true</span>; continueConsume; ) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 每次获取消息的数量</span></span><br><span class=\"line\">                        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> consumeBatchSize =</span><br><span class=\"line\">                            ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class=\"line\">                        <span class=\"comment\">// 拿到可以消费的消息列表。默认为 1 条。</span></span><br><span class=\"line\">                        List&lt;MessageExt&gt; msgs = <span class=\"keyword\">this</span>.processQueue.takeMessages(consumeBatchSize);</span><br><span class=\"line\">                        defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!msgs.isEmpty()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">final</span> ConsumeOrderlyContext context = <span class=\"keyword\">new</span> ConsumeOrderlyContext(<span class=\"keyword\">this</span>.messageQueue);</span><br><span class=\"line\">                            ConsumeOrderlyStatus status = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            ConsumeMessageContext consumeMessageContext = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 消费者加锁</span></span><br><span class=\"line\">                                <span class=\"keyword\">this</span>.processQueue.getConsumeLock().lock();</span><br><span class=\"line\">                                <span class=\"comment\">// 回调消费者消息</span></span><br><span class=\"line\">                                status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">this</span>.processQueue.getConsumeLock().unlock();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            continueConsume = ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.processConsumeResult(msgs, status, context, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            continueConsume = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">100</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样消息就消费完了。不得不说，这个消费的整体消费的逻辑是真的复杂。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>我们从生产者发送消息，到  <code>Broker</code>  端存储消息， 再到 消费者消费消息。将整个流程都跑通了。<br>\n每个过程都不是我们想象的那样直接发送消息给 <code>Broker</code> ， <code>Broker</code>  将消息直接写入硬盘， 消费者直接去 <code>Broker</code>  中拉取消息，拉取到之后直接调用客户端进行消费。</p>\n<p>接下来，我们会深入到  <code>RocketMQ</code>  某个特性的具体实现中去。会逐一分析 事务消息，延时消息，消息可靠性措施，载均衡，消息重放，消息过滤等功能的实现。</p>\n<p>下一篇文章：事务消息。请期待～</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/28/rocketMQ/2-01-RocketMQ-Arch-Start/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/28/rocketMQ/2-01-RocketMQ-Arch-Start/",
            "title": "RocketMQ系列-架构设计之启动",
            "date_published": "2021-09-28T02:26:00.000Z",
            "content_html": "<p>之前我们已经学习了 <code>RocketMQ</code>  是由四个部分组成的。这篇文章更加深入的来看看这个四个部分。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"\"></p>\n<h2 id=\"nameserver\"><a class=\"markdownIt-Anchor\" href=\"#nameserver\">#</a>  <code>NameServer</code></h2>\n<p>接下来，我们来看  <code>NameServer</code>  的相关内容，我们都知道  <code>NameServer</code>  是  <code>RocketMQ</code>  的注册中心。那它肯定会有 服务发现，检查检查，路由等等功能， 我们就按照这个思路去看看  <code>NameServer</code>  是如何启动的。</p>\n<h3 id=\"namesrv-的启动过程\"><a class=\"markdownIt-Anchor\" href=\"#namesrv-的启动过程\">#</a>  <code>NameSrv</code>  的启动过程</h3>\n<p>我们在部署  <code>RocketMQ</code>  的时候，使用下面的命令启动了 <code>RocketMQ</code>  的 <code>NameServer</code> .</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>这条命令其实执行的是：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh <span class=\"variable\">$&#123;ROCKETMQ_HOME&#125;</span>/bin/runserver.sh org.apache.rocketmq.namesrv.NamesrvStartup <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n<p>也就说，这条命令执行运行的  <code>NamesrvStartup</code>  类。</p>\n<p><code>NameSrv</code>  的启动其实就两步：</p>\n<ul>\n<li>封装配置参数： 根据命令行参数封装  <code>NameSrvConfig</code>  配置。 可以执行配置文件，会解析配置文件中的相关配置。</li>\n<li>初始化并启动  <code>NamesrvController</code> .\n<ul>\n<li>初始化:\n<ul>\n<li>对  <code>NameSrvController</code>  进行配置，</li>\n<li>创建远程  <code>netty Server</code> ,</li>\n<li>注册  <code>DefaultRequestProcessor</code>  ，处理各种连接请求，</li>\n<li>创建了两个定时任务：每  <code>10s</code>  扫描一次  <code>Broker</code>  列表，移除不存活的  <code>Broker</code>  。每 <code>10s</code>  打印一次配置属性。</li>\n<li>创建配置文件监听器，监听配置文件是否有变化。</li>\n</ul>\n</li>\n<li>启动：\n<ul>\n<li>启动  <code>netty Server</code>  : 实际上启动一个 Netty 服务。</li>\n<li>启动文件监听器。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>在启动过程中， <code>Broker</code>  的健康检测是通过定时任务来实现的。那路由功能是怎么实现的呢？</p>\n<p>这就要看 在  <code>NameServer</code>  中最重要的一个类了：  <code>DefaultRequetProcessor</code>  .  <code>DefaultRequestProcessor</code>  封装了各种连接请求的处理。比如 <code>Broker</code>  的注册，根据 <code>Topic</code>  获取路由信息等等。具体可以参考如下代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(ChannelHandlerContext ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ctx != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;receive request, &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class=\"line\">                request.getCode(),</span><br><span class=\"line\">                RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class=\"line\">                request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (request.getCode()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.PUT_KV_CONFIG:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.putKVConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_KV_CONFIG:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getKVConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.DELETE_KV_CONFIG:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.deleteKVConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.QUERY_DATA_VERSION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queryBrokerTopicConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.REGISTER_BROKER:</span><br><span class=\"line\">            Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.registerBroker(ctx, request);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.UNREGISTER_BROKER:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.unregisterBroker(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_ROUTEINFO_BY_TOPIC:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_BROKER_CLUSTER_INFO:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getBrokerClusterInfo(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.WIPE_WRITE_PERM_OF_BROKER:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.wipeWritePermOfBroker(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getAllTopicListFromNameserver(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.DELETE_TOPIC_IN_NAMESRV:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> deleteTopicInNamesrv(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_KVLIST_BY_NAMESPACE:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getKVListByNamespace(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_TOPICS_BY_CLUSTER:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getTopicsByCluster(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getSystemTopicListFromNs(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_UNIT_TOPIC_LIST:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getUnitTopicList(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getHasUnitSubTopicList(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.UPDATE_NAMESRV_CONFIG:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.updateConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RequestCode.GET_NAMESRV_CONFIG:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getConfig(ctx, request);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码里实现了所有的 <code>Broker</code> ， <code>Producer</code> ， <code>Customer</code>  和 <code>NameServer</code>  交互的处理逻辑，包括路由功能等等。</p>\n<h3 id=\"nameserver的关闭\"><a class=\"markdownIt-Anchor\" href=\"#nameserver的关闭\">#</a>  <code>NameServer</code>  的关闭</h3>\n<p><code>NameServer</code>  的关闭就非常简单了.</p>\n<p><code>NameSrvStartUp</code>  在  <code>initialize</code>  和  <code>start</code>  之间，加入了 一个 关闭事件的监听器.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加关闭的回调。</span></span><br><span class=\"line\">Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> ShutdownHookThread(log, <span class=\"keyword\">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        controller.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>内部是使用  <code>NameSrvController</code>  的 <code>shutdown</code>  方法。<br>\n主要进行：</p>\n<ul>\n<li>关闭 <code>Netty</code>  服务</li>\n<li>关闭线程池</li>\n<li>关闭 <code>scheduledExecutorService</code></li>\n<li>关闭文件监听器</li>\n</ul>\n<h2 id=\"broker\"><a class=\"markdownIt-Anchor\" href=\"#broker\">#</a> Broker</h2>\n<ul>\n<li><code>Broker</code>  的启动过程</li>\n<li><code>Broker</code>  怎么样进行消息存储的</li>\n<li><code>Broker</code>  的内部运行原理是什么样的？</li>\n<li>关闭流程</li>\n</ul>\n<p>在  <code>RocketMQ</code>  的  <code>Broker</code>  这个启动环节下，我们可以直接找到 <a href=\"https://gitee.com/fangjiaxiaobai/source_code_read/blob/master/rocketmq/broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup.java\"> <code>BrokerStartUp.java</code> </a> 这个类。</p>\n<h3 id=\"broker的启动过程\"><a class=\"markdownIt-Anchor\" href=\"#broker的启动过程\">#</a> Broker 的启动过程</h3>\n<p><code>Broker</code>  的启动本质上是启动了 一个 <code>Netty</code>  服务端和一个 <code>Netty</code>  客户端。 使用 <code>Netty</code>  客户端完成向 <code>NameSrv</code>  的注册，心跳检测，等数据交互。 使用 <code>Netty</code>  服务端处理  <code>Producer</code>  发送的消息，并将消息按照不同的消息类型存储下来。</p>\n<p>首先  <code>Broker</code>  依然还是会加载  <code>Broker</code>  的相关配置，包括：a. 命令行中指定的参数，比如 <code>mqbroker</code> ,-c 等， b. <code>-c</code>  指定的文件中的 <code>Broker</code>  属性。然后根据加载的 <code>NettyServerConfig</code>  (启动的 <code>Netty</code>  服务端的配置), <code>NettyClientConfig</code>  (启动的 <code>Netty</code>  客户端的配置),  <code>BrokerConfig</code> ( <code>Broker</code>  的配置),  <code>messageStoreConfig</code>  (存储消息的配置) 创建  <code>BrokerController</code> .  之后及时初始化 <code>BrokerController</code> ，注册 <code>Shutdown</code>  回调。最后启动 <code>BrokerController</code> 。   <code>shutdown</code>  回调其实没有什么可说的。我们再简单的看看初始化过程。</p>\n<h4 id=\"初始化过程\"><a class=\"markdownIt-Anchor\" href=\"#初始化过程\">#</a> 初始化过程</h4>\n<p>初始化过程是一个  <code>&quot;漫长&quot;</code>  的过程。一开始是在去加载一些数据，初始化会去加载 创建的 <code>topic</code>  数据，消息的消费偏移量，广播组，消费过滤数据等的数据，然后创建  <code>MessageStore</code>  对象，作用是存储消息。注意这个  <code>MessageStore</code>  是支持插件的形式扩展的。 如果数据加载成功之后，就会启动  <code>netty</code>  服务端。 代码中 启动了两个 netty 服务端:  <code>remotingServer</code>  和  <code>fastRemotingServer</code> 。然后就是初始化了一些线程池 用于注册 <code>Processor</code> 。 在注册  <code>Processor</code>  的过程中，可以看到  <code>fastRemotingServer</code>  和  <code>remotingServer</code>  除了端口不一样之外，  <code>fastRemotingServer</code>  没有 注册  <code>PullMessageProcessor</code>  . 也就是说  <code>fastRemotingServer</code>  不支持  <code>pullMessage</code>  请求。然后  <code>BrokerController</code>  创建很多的定时任务，比如：定时记录每天的消息数据，定时持久化消费者消息。定时持久化 消费者过滤时的数据情况 等。再就是 更新 <code>Broker</code>  的 <code>NameServer</code>  地址。 最后初始化事务，初始化权限，初始化 <code>RPC</code>  钩子。</p>\n<h4 id=\"启动过程\"><a class=\"markdownIt-Anchor\" href=\"#启动过程\">#</a> 启动过程</h4>\n<p>在完了初识话之后，下一步就是启动了。和 <code>NameServer</code>  一样的流程，先初始化，在 <code>start</code> . 启动过程分为以下几步:</p>\n<ul>\n<li>启动  <code>messageStore</code></li>\n<li>启动  <code>remotingServer</code></li>\n<li>启动  <code>fastRemotingServer</code></li>\n<li>启动文件监听器</li>\n<li>启动  <code>BrokerOutAPI</code>  , 向  <code>NameServer</code>  服务端发送相关请求的连接与断开等，定时扫描 <code>ResponseTable</code>  并触发回调。</li>\n<li>启动 <code>PullRequestHoldService</code> : 存储  <code>pull Message</code>  的请求，并触发执行 <code>pull Message</code> .</li>\n<li>启动定时任务，定时扫描不存活的生产者，消费者，消息过滤服务 (非 <code>tag</code>  过滤)。</li>\n<li>启动消息过滤服务。 消息过滤服务并非是基于 <code>tag</code>  的消息的过滤，而是在 <code>Broker</code>  端提供了一种更加细粒度的消息过滤控制。</li>\n<li><code>Broker</code>  的容灾处理</li>\n<li>定时任务：注册  <code>Broker</code>  到  <code>NameServer</code></li>\n<li>启动 <code>broker</code>  统计，无动作</li>\n<li>清理过期请求。</li>\n</ul>\n<h4 id=\"关闭过程\"><a class=\"markdownIt-Anchor\" href=\"#关闭过程\">#</a> 关闭过程</h4>\n<p>这个关闭流程这里就不多说了，就是把上面启动的过程挨个关闭就好了。具体细节可以参考  <code>org.apache.rocketmq.broker.BrokerController#shutdown()</code>  我们后面也会分析这部分的代码。 除了关闭上面启动的服务之外，在关闭的时候，需要将消息进行持久化。 比如  <code>ConsumerOffset</code> ,  <code>ConsumerFilter</code> , 这也是当服务再次启动时保证消息能够正常被消费的保障。</p>\n<h2 id=\"producer\"><a class=\"markdownIt-Anchor\" href=\"#producer\">#</a> Producer</h2>\n<p>消息发布的角色，支持分布式集群方式部署。 <code>Producer</code>  通过 MQ 的负载均衡模块选择相应的 <code>Broker</code>  集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>\n<blockquote>\n<p>我们从最简单的一个示例来看，生产者的启动流程</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用GroupName初始化Producer</span></span><br><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 指定NameSrv的地址: 也可以通过环境变量NAMESRV_ADDR来指定，则不需要下面这一行。</span></span><br><span class=\"line\">producer.setNamesrvAddr(<span class=\"string\">&quot;name-server1-ip:9876;name-server2-ip:9876&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 启动实例</span></span><br><span class=\"line\">producer.start();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建消息实例,指定 topic, tag, message body.</span></span><br><span class=\"line\">    Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span> <span class=\"comment\">/* Topic */</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;TagA&quot;</span> <span class=\"comment\">/* Tag */</span>,</span><br><span class=\"line\">        (<span class=\"string\">&quot;Hello RocketMQ !!&quot;</span>).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class=\"comment\">/* Message body */</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">// 发送消息给Broker</span></span><br><span class=\"line\">    SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 关闭生产者</span></span><br><span class=\"line\">producer.shutdown();</span><br></pre></td></tr></table></figure>\n<p>关于 生产者角色，我们应该了解什么？或者说，看到上面的代码，你想更深入的知道些什么吗？(我听到了你说，不想…)</p>\n<ul>\n<li>生产者是如何启动？启动过程中生产者都做了哪些事情？</li>\n<li>生产者是如何和 <code>Namesrv</code>  进行交互的？交互是什么信息？生产者是如何和 <code>NameSrv</code>  进行健康检查的？</li>\n<li>生产者是怎么样发送消息的？发送消息的过程是什么样的？</li>\n<li>生产者的关闭流程是什么样的？</li>\n</ul>\n<h3 id=\"生产者启动流程\"><a class=\"markdownIt-Anchor\" href=\"#生产者启动流程\">#</a> 生产者启动流程</h3>\n<h4 id=\"封装生产者的属性\"><a class=\"markdownIt-Anchor\" href=\"#封装生产者的属性\">#</a> 封装生产者的属性</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过  <code>DefaultMQProducer</code>  类创建一个生产者对象。 这个类我们打算发送消息的程序入口。需要注意的是：这个类的实例是<strong>线程安全</strong>的：在配置并启动进程后，该类可以被视为线程安全的，可以在多个线程上下文中使用。</p>\n<p><code>DefaultMQProducer</code>  提供了 <code>5</code>  个构造参数 ( <code>4.9.1</code>  版本，并非在一个构造方式中)。</p>\n<ul>\n<li><code>String namespace</code> : 生产者实例的命名空间。可以理解为 MQ 生产者的名称。</li>\n<li><code>String producerGroup</code> : 生产者组。 生产者组在概念上聚合了完全相同角色的生产者实例。 这对事务消息非常重要。对非事务性消息就没有太大关系了。(=&gt; 小白说：一类生产者。)</li>\n<li><code>RPCHook rpcHook</code> : 每个远程命令执行要执行的 RPC 回调。RPCHook 是一个接口，提供了两个方法 doBeforeRequest 和 doAfterResponse，表示在执行请求之前和接收返回之后分别执行相关逻辑；</li>\n<li><code>boolean enableMsgTrace</code> : 是否开启消息追踪</li>\n<li><code>String customizedTraceTopic</code> : 消息追踪日志使用的队列名字</li>\n<li><code>String nameSrvAddr</code> : 这个字段没有在构造方法中，我们可以手动调用 set 方法进行设置，也可以通过系统变量的形式进行设置。</li>\n</ul>\n<p>生产者在设置完对应的参数之后，就会调用 <code>Start()</code>  方法。  <code>start</code>  方法会设置 <code>group</code> , 然后调用在 构造方法中初始化的  <code>defaultMQProducerImpl</code>  实例。</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-DefaultProducerImpl%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81.png\" alt=\"\"></p>\n<p>如上图</p>\n<ul>\n<li>生产者首先会检查  <code>producerGroup</code>  的合法性。</li>\n<li>然后设置 <code>ProducerGroup</code></li>\n<li>创建  <code>MQClientFactory</code> . 将 <code>producer</code>  注册到 <code>MQClientInstance</code>  中，</li>\n<li>初始化 <code>topicPushlishInfo</code> .  <code>topicPushlishInfo</code>  主要用于存放消息的路由信息。</li>\n<li>然后通过  <code>mQClientFactory.start()</code>  完成启动，这一步骤很重要，我们来看一下里面的具体实现.<br>\n<img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-MQInstance%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81.png\" alt=\"\">\n<ul>\n<li>1. 首先会设置  <code>NameServerAddr</code> 。前面有说过可以通过  <code>DefaultProducer</code>  的 <code>setNameSrvAddr</code>  方法手动设置，也可以通过系统变量的方式进行设置 <code>NameServer</code>  的地址： <code>System.setProperty(&quot;rocketmq.namesrv.domain&quot;, &quot;localhost&quot;);</code></li>\n<li>2. 开启定时任务：总共启动了 <code>5</code>  个定时器任务，分别是：定时更新 <code>NameServerAddr</code>  信息，定时更新 <code>topic</code>  的路由信息，定时清理下线的 <code>broker</code> ，定时持久化 <code>Consumer</code>  的 <code>Offset</code>  信息，定时调整线程池；</li>\n<li>3. <code>pullMessageService</code>  和 <code>rebalanceService</code>  被用在消费端的两个服务类，分别是：从 <code>broker</code>  拉取消息的服务和均衡消息队列服务，负责分配消费者可消费的消息队列</li>\n</ul>\n</li>\n<li>同步的发送心跳给所有的 <code>Broker</code> .</li>\n<li>开启定时任务：定时扫描过期的请求。</li>\n</ul>\n<h3 id=\"生产者发送消息\"><a class=\"markdownIt-Anchor\" href=\"#生产者发送消息\">#</a> 生产者发送消息</h3>\n<p>生产者启动完成之后，我们再看一下发送消息的过程:<br>\n 发送消息的逻辑主要是在  <code>sendDefaultImpl</code>  方法中。主要逻辑分成三步：1. 获取队列的路由信息，2. 获取  <code>MessageQueue</code> , 3. 发送消息。</p>\n<h4 id=\"获取队列路由信息\"><a class=\"markdownIt-Anchor\" href=\"#获取队列路由信息\">#</a> 获取队列路由信息</h4>\n<p>在 启动生产者流程中，已经将 <code>topic</code>  的路由信息存储到了  <code>topicPushlishInfo</code>  中，并以  <code>producerGroup</code>  为  <code>key</code> ,  <code>topicPushlishInfo</code>  为 Value ，存储到  <code>topicPublishInfoTable</code>  这个 <code>Map</code>  中。</p>\n<p>获取路由信息则是通过  <code>mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer)</code>  获取的。此方法根据 <code>topic</code>  获取路由信息，具体连接哪台 <code>nameServer</code> ，会从列表中顺序的选择 <code>nameServer</code> ，实现负载均衡；</p>\n<h4 id=\"获取messagequeue\"><a class=\"markdownIt-Anchor\" href=\"#获取messagequeue\">#</a> 获取 <code>MessageQueue</code></h4>\n<p>获取  <code>MessageQueue</code>  则是通过  <code>this.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName)</code>  来实现的。  <code>MQFaultStrategy</code>  这个类实现了选择  <code>MessageQueue</code>  的策略。主要有四种策略:</p>\n<ul>\n<li><code>latencyFaultTolerance</code> ：延迟容错对象，维护 <code>brokers</code>  的延迟信息；</li>\n<li><code>sendLatencyFaultEnable</code> ：延迟容错开关，默认不开启；</li>\n<li><code>latencyMax</code> ：延迟级别数组；</li>\n<li><code>notAvailableDuration</code>  ：根据延迟级别，对应 <code>broker</code>  不可用的时长；</li>\n</ul>\n<p>获取 <code>MessageQueue</code>  之后需要判定其对应的 <code>Broker</code>  是否可用，同时也需要和当前指定的 <code>brokerName</code>  进行匹配；如果没有获取到就选择一个延迟相对小的， <code>pickOneAtLeast</code>  会做排序处理；如果都不行就直接获取一个 <code>MessageQueue</code> ，不管其他条件了</p>\n<h4 id=\"发送消息\"><a class=\"markdownIt-Anchor\" href=\"#发送消息\">#</a> 发送消息</h4>\n<p>首先需要获取指定 <code>broker</code>  的地址，这要才能创建 <code>channel</code>  与 <code>broker</code>  连接；然后就是一些 <code>hook</code>  处理；接下来就是准备发送的消息头 <code>SendMessageRequestHeader</code> ，最后根据不同的发送策略执行发送消息。</p>\n<p>之前的文章中说过， <code>RocketMQ</code>  发送消息有三种方式：同步，异步和单向。具体的使用方法可以参考<a href=\"./1-04-01.%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B.md\">这篇文章</a>。在 <code>RocketMQ</code>  的生产者端可以发送多种类型的消息包括：延迟消息，顺序消息以及事务消息， 各种消息的发送过程我会在后面通过源码仔细和大家一起学习～。</p>\n<h3 id=\"生产者关闭流程\"><a class=\"markdownIt-Anchor\" href=\"#生产者关闭流程\">#</a> 生产者关闭流程</h3>\n<p>生产者的关闭主要有四步</p>\n<ul>\n<li>取消生产者的注册.</li>\n<li>关闭 <code>MqClient</code> =&gt; 主要是关闭生产者，关闭拉取消息服务，关闭定时任务服务，关闭远程 client，关闭负载均衡服务这 5 种服务。</li>\n<li>关闭 <code>Producer</code>  的定时任务</li>\n<li>修改状态。</li>\n</ul>\n<p>这样就完成了生产者的关闭流程。</p>\n<h3 id=\"生产者总结\"><a class=\"markdownIt-Anchor\" href=\"#生产者总结\">#</a> 生产者总结</h3>\n<p>生产者首先需要设置 <code>namesrv</code> ，或者指定其他方式更新 <code>namesrv</code> ；然后从 <code>namesrv</code>  获取 <code>topic</code>  的路由信息，路由信息包括 <code>broker</code>  以及 <code>Message Queue</code>  等信息，同时将路由信息保存在本地内存中，方便下次使用；最后从 <code>Message Queue</code>  列表中选择合适的 <code>Queue</code>  发送消息，实现负载均衡；</p>\n<h2 id=\"consumer\"><a class=\"markdownIt-Anchor\" href=\"#consumer\">#</a> Consumer</h2>\n<p>现在我们还剩下 消费者 的启动流程了。从一个简单的例子说起:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81.png\" alt=\"\"></p>\n<p>从图中可以看到使用 MQ 的消费者主要分成三部分： 1. 创建消费者对象，2. 配置消费的属性 nameServer, 消费起点，订阅主题，回调事件等。3. 启动消费者。</p>\n<h3 id=\"consumer的启动过程\"><a class=\"markdownIt-Anchor\" href=\"#consumer的启动过程\">#</a> Consumer 的启动过程</h3>\n<p>正如上文所说， 启动 <code>MQ</code>  消费者主要分为三部分，我们主要讲述第一部分和第三部分：创建 <code>Consumer</code>  对象，启动。</p>\n<h4 id=\"创建-consumer-对象\"><a class=\"markdownIt-Anchor\" href=\"#创建-consumer-对象\">#</a> 创建 Consumer 对象</h4>\n<p><code>RocketMQ</code>  支持两种消息消费模式， <code>pull</code>  模式 和  <code>push</code>  模式。  <code>pull</code>  模式是消费者主动拉取消息， <code>push</code>  模式是  <code>broker</code>  端主动推送消息给消息者端。可想而知， <code>push</code>  模式是不管消费者端死活的，只要有消息就会推给消费者端，不管消费者是否能消费完。而 <code>pull</code>  模式是不管 <code>Broker</code>  端的，可能会造成消息积压的问题。</p>\n<p><code>RocketMQ</code>  分别提供了 <code>pull</code>  模式 和  <code>push</code>  模式的消费者的支持。类结构如下图：</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-Consuomer%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt=\"\"></p>\n<p>图中  <code>push</code>  模式，提供了  <code>MQPushConsumer</code> ( <code>DefaultMQPushConsumer</code> ) 类来实现。  <code>pull</code>  模式提供  <code>MQPullConsumer</code> ( <code>DefaultMQPullConsumer</code> ) 类来实现。但是这个已经标记为废弃，并在 <code>2022</code>  年会移除，提供了  <code>LitePullConsumer</code> ( <code>DefaultLitePullConsumer</code> ) 来实现 <code>Pull</code>  模式。</p>\n<h5 id=\"创建-defaultmqpushconsumer-对象\"><a class=\"markdownIt-Anchor\" href=\"#创建-defaultmqpushconsumer-对象\">#</a> 创建 DefaultMQPushConsumer 对象</h5>\n<p><code>DefaultMQPullConsumer</code>  对象的构造参数</p>\n<ul>\n<li><code>consumerGroup</code> : 消费者组</li>\n<li><code>namespace</code> : 生产者的  <code>Namespace</code></li>\n<li><code>allocateMessageQueueStrategy</code> : 消息队列分配算法</li>\n<li><code>rpcHook</code> :  <code>rpc</code>  的钩子，用在远程调用之前执行</li>\n<li><code>enableMsgTrace</code> : 是否跟踪消息轨迹</li>\n<li><code>customizedTraceTopic</code> : 跟踪消息轨迹使用 <code>topic</code></li>\n</ul>\n<p>在  <code>DefaultMQPushConsumer</code>  的构造方法中会创建  <code>DefaultMQPushConsumerImpl</code>  对象，我们后面所说的启动过程，其实就是  <code>DefaultMQPushConsumerImpl</code>  的启动过程，即  <code>DefaultMQPushConsumerImpl.start()</code> .</p>\n<h5 id=\"创建-defaultlitepullconsumer-对象\"><a class=\"markdownIt-Anchor\" href=\"#创建-defaultlitepullconsumer-对象\">#</a> 创建  <code>DefaultLitePullConsumer</code>  对象</h5>\n<p><code>DefaultLitePullConsumer</code>  对象的参数:</p>\n<ul>\n<li><code>namespace</code> : 生产者的命名空间</li>\n<li><code>consumerGroup</code> :  消费者组</li>\n<li><code>rpcHook</code> : RPC 的回调钩子</li>\n</ul>\n<p>在  <code>DefaultLitePullConsumer</code>  的构造方法中会创建  <code>defaultLitePullConsumerImpl</code>  对象。而后面的启动过程，即是  <code>DefaultLitePullConsumerImpl</code>  的启动过程。即  <code>DefaultLitePullConsumerImpl.start()</code> .</p>\n<h4 id=\"启动\"><a class=\"markdownIt-Anchor\" href=\"#启动\">#</a> 启动</h4>\n<p>这里我再把使用 DefaultMQPushConsumer 消费消息的案例 粘贴到这里</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81.png\" alt=\"\"></p>\n<p>我们主要看  <code>consumer.start()</code>  内部的具体实现。</p>\n<h5 id=\"push模式-defaultmqpushconsumerimplstart\"><a class=\"markdownIt-Anchor\" href=\"#push模式-defaultmqpushconsumerimplstart\">#</a> push 模式: DefaultMQPushConsumerImpl.start ()</h5>\n<ul>\n<li>检查必要的参数 <code>consumerGroup</code> , 消费模式，消费起点，负载策略等。</li>\n<li>拷贝订阅关系，绑定到重试 <code>topic</code> , 以防止消费者  <code>ack</code>  失败。</li>\n<li>创建 <code>MQClientInstance</code>  实例。这里是一种单例模式。</li>\n<li>配置消费者再平衡的消费者组，消息模式，消息的分配策略，  <code>MQClientInstance</code>  实例。</li>\n<li>实例化消息拉取的包装类 并注册消息过滤的钩子</li>\n<li>加载消息的消费偏移量。 如果是广播消息从本地获取偏移数据，如果是集群消息的话，则从远程获取偏移数据</li>\n<li>启动消息消费服务。这里只是启动消费服务，但是没有启动开始消费消息。</li>\n<li>绑定消费者  <code>group</code>  和 消费者</li>\n<li>启动  <code>MQ Client Instance</code> . 这里，在生产者中也调用了  <code>mQClientFactory.start()</code> ; 方法。有个疑问，为什么消费者会启动消息推送服务呢？因为在 <code>push</code>  模式下，消费超时的消息会重新发送给 <code>Broker</code> 。所以是会使用消息推送服务的.</li>\n<li>从 <code>NameServer</code>  拉取 <code>topic</code>  的订阅信息</li>\n<li>向 <code>Broker</code>  校验客户端</li>\n<li>向所有的 <code>Broker</code>  的 <code>master</code>  节点发送心跳包，并上传 <code>FilterClass</code>  源文件给 <code>FilterServer</code></li>\n<li>立即消费消息： 将当前 <code>consumer</code>  负载得到的 <code>MessageQueue</code>  全部添加到 <code>PullMessageService.pullRequestQueue</code>  (阻塞队列) 然后 <code>PullMessageService</code>  服务会开始拉取消息。消费消息。</li>\n</ul>\n<h5 id=\"pull模式-defaultlitepullconsumerimplstart\"><a class=\"markdownIt-Anchor\" href=\"#pull模式-defaultlitepullconsumerimplstart\">#</a>  <code>pull</code>  模式:  <code>DefaultLitePullConsumerImpl.start()</code></h5>\n<p>先看下  <code>DefaultLitePullConsumer</code>  的一个简单使用:</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/2-01-DefaultLitePullConsumer%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81.png\" alt=\"\"></p>\n<p><code>DefaultLitePullConsumer</code>  的实现代码要比   <code>DefaultMQPushConsumer</code>  的代码 规整很多。在  <code>start()</code>  方法中定义了很多的子方法进行调用。</p>\n<ul>\n<li>检查属性配置是否合法。</li>\n<li>初始化  <code>MqClientInstance</code> .\n<ul>\n<li>创建  <code>MQClientInstance</code>  实例</li>\n<li>注册  <code>consumerGroup</code>  和 当前消费者的关系</li>\n</ul>\n</li>\n<li>初始化 消息消费的 再平衡 服务。</li>\n<li>配置消费者再平衡的消费者组，消息模式，消息的分配策略，  <code>MQClientInstance</code>  实例。</li>\n<li>实例化消息拉取的包装类 并注册消息过滤的钩子</li>\n<li>加载消息的消费偏移量。 如果是广播消息从本地获取偏移数据，如果是集群消息的话，则从远程获取偏移数据</li>\n<li>启动  <code>MqClientInstance</code>  实例\n<ul>\n<li>设置  <code>NameServer</code>  的地址</li>\n<li>启动  <code>remoteClient</code> . 底层使用的通讯框架是 <code>Netty</code> ，提供了实现类 <code>NettyRemotingClient</code></li>\n<li>开启定时任务</li>\n<li>启动拉取消息的服务</li>\n<li>启动负载均衡服务</li>\n<li>启动推送消息的服务</li>\n<li>修改服务的状态为启动成功</li>\n</ul>\n</li>\n<li>启动后操作\n<ul>\n<li>如果是广播的模式：更新 <code>topic</code>  的订阅关系</li>\n<li>更新消息拉取任务</li>\n<li>拉取 <code>Topic</code>  的 <code>messageQueue</code> .</li>\n<li>检查  <code>Broker Client</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"pull-模式-和-push-模式的对比\"><a class=\"markdownIt-Anchor\" href=\"#pull-模式-和-push-模式的对比\">#</a> Pull 模式 和 push 模式的对比</h5>\n<p>现在去谈 push 和 pull 两种模式的对比，还为时尚早，我就先从启动上来看下，两种方式启动的不同点:</p>\n<ul>\n<li><code>pull</code>  模式没有拷贝订阅关系，也就是说  <code>pull</code>  模式下， <code>RocketMQ</code>  是没有提供重投机制的。</li>\n<li><code>pull</code>  模式没有和  <code>Broker</code>  保持心跳包。 如果消费者过多的时候，push 模式必然会对 Broker 造成比较啊的压力。</li>\n</ul>\n<h3 id=\"消费者总结\"><a class=\"markdownIt-Anchor\" href=\"#消费者总结\">#</a> 消费者总结</h3>\n<p><code>RocketMQ</code>  对  <code>pull</code>  和  <code>push</code>  两种消息的消费模式提供了支持。 <code>pull</code>  模式，对应的实现是  <code>DefaultMqLitePullConsumer</code> 。  <code>push</code>  模式对应的实现是  <code>DefaultMqPushConsumer</code> . 仅仅对启动过程，两者的启动过程稍有不同。 <code>Push</code>  模式下， <code>RocketMQ</code>  封装了 消息消费的重投机制， <code>pull</code>  模式则没有，一切都需要消费者自己去实现。  <code>push</code>  模式会把 根据  <code>MessageQueue</code>  的分配策略，将 <code>MessageQueue</code>  拉取到本地，存储到阻塞队列中，然后通过回调消费者注册监听器进行消费。  <code>pull</code>  模式则通过在消费逻辑中定时的轮询获取消息进行消费。  下一篇文章，我会仔细的分析消息消费的过程。</p>\n<p>不管是 <code>Pull</code>  模式，还是 <code>push</code>  模式，在启动过程都是 创建  <code>MqClientInstance</code>  实例，并启动。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-06.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-06.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/",
            "title": "RocketMQ样例:事务消息",
            "date_published": "2021-09-23T09:50:00.000Z",
            "content_html": "<p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>\n<p><code>TransactionStatus.CommitTransaction</code> : 提交事务，它允许消费者消费此消息。<br>\n <code>TransactionStatus.RollbackTransaction</code> : 回滚事务，它代表该消息将被删除，不允许被消费。<br>\n <code>TransactionStatus.Unknown</code> : 中间状态，它代表需要检查消息队列来确定状态。</p>\n<h2 id=\"发送事务消息样例\"><a class=\"markdownIt-Anchor\" href=\"#发送事务消息样例\">#</a> 发送事务消息样例</h2>\n<h3 id=\"创建事务性生产者\"><a class=\"markdownIt-Anchor\" href=\"#创建事务性生产者\">#</a> 创建事务性生产者</h3>\n<p>使用  <code>TransactionMQProducer</code>  类创建生产者，并指定唯一的  <code>ProducerGroup</code> ，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionProducer</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class=\"line\">       TransactionListener transactionListener = <span class=\"keyword\">new</span> TransactionListenerImpl();</span><br><span class=\"line\">       TransactionMQProducer producer = <span class=\"keyword\">new</span> TransactionMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">       ExecutorService executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class=\"number\">2000</span>), <span class=\"keyword\">new</span> ThreadFactory() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">               Thread thread = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">               thread.setName(<span class=\"string\">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> thread;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">       producer.setExecutorService(executorService);</span><br><span class=\"line\">       producer.setTransactionListener(transactionListener);</span><br><span class=\"line\">       producer.start();</span><br><span class=\"line\">       String[] tags = <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;TagA&quot;</span>, <span class=\"string\">&quot;TagB&quot;</span>, <span class=\"string\">&quot;TagC&quot;</span>, <span class=\"string\">&quot;TagD&quot;</span>, <span class=\"string\">&quot;TagE&quot;</span>&#125;;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               Message msg =</span><br><span class=\"line\">                   <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest1234&quot;</span>, tags[i % tags.length], <span class=\"string\">&quot;KEY&quot;</span> + i,</span><br><span class=\"line\">                       (<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class=\"line\">               SendResult sendResult = producer.sendMessageInTransaction(msg, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">               System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">               Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">               e.printStackTrace();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">           Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       producer.shutdown();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、实现事务的监听接口<br>\n当发送半消息成功时，我们使用  <code>executeLocalTransaction</code>  方法来执行本地事务。它返回前一节中提到的三个事务状态之一。 <code>checkLocalTransaction</code>  方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionListenerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TransactionListener</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicInteger transactionIndex = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">executeLocalTransaction</span><span class=\"params\">(Message msg, Object arg)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> value = transactionIndex.getAndIncrement();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> status = value % <span class=\"number\">3</span>;</span><br><span class=\"line\">      localTrans.put(msg.getTransactionId(), status);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> LocalTransactionState <span class=\"title\">checkLocalTransaction</span><span class=\"params\">(MessageExt msg)</span> </span>&#123;</span><br><span class=\"line\">      Integer status = localTrans.get(msg.getTransactionId());</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != status) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (status) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> LocalTransactionState.UNKNOW;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事务消息使用上的限制\"><a class=\"markdownIt-Anchor\" href=\"#事务消息使用上的限制\">#</a> 事务消息使用上的限制</h3>\n<ul>\n<li>事务消息不支持延时消息和批量消息。</li>\n</ul>\n<p>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为  <code>15</code>  次，但是用户可以通过  <code>Broker</code>  配置文件的  <code>transactionCheckMax</code>  参数来修改此限制。如果已经检查某条消息超过  <code>N</code>  次的话（  <code>N = transactionCheckMax</code>  ） 则  <code>Broker</code>  将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写  <code>AbstractTransactionalMessageCheckListener</code>  类来修改这个行为。</p>\n<p>事务消息将在  <code>Broker</code>  配置文件中的参数  <code>transactionTimeout</code>  这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性  <code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>  来改变这个限制，该参数优先于  <code>transactionTimeout</code>  参数。</p>\n<ul>\n<li>事务性消息可能不止一次被检查或消费。</li>\n</ul>\n<p>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过  <code>RocketMQ</code>  本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。<br>\n事务消息的生产者  <code>ID</code>  不能与其他类型消息的生产者  <code>ID</code>  共享。与其他类型的消息不同，事务消息允许反向查询、 <code>MQ</code>  服务器能通过它们的生产者  <code>ID</code>  查询到消费者。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-05.%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-05.%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF/",
            "title": "RocketMQ样例:过滤消息",
            "date_published": "2021-09-23T09:30:00.000Z",
            "content_html": "<p>在大多数情况下， <code>TAG</code>  是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;TOPIC&quot;</span>, <span class=\"string\">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>消费者将接收包含 <code>TAGA</code>  或 <code>TAGB</code>  或 <code>TAGC</code>  的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用 <code>SQL</code>  表达式筛选消息。SQL 特性可以通过发送消息时的属性来进行计算。在 <code>RocketMQ</code>  定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------</span><br><span class=\"line\">| message  |</span><br><span class=\"line\">|----------|  a &gt; 5 AND b = &#x27;abc&#x27;</span><br><span class=\"line\">| a = 10   |  --------------------&gt; Gotten</span><br><span class=\"line\">| b = &#x27;abc&#x27;|</span><br><span class=\"line\">| c = true |</span><br><span class=\"line\">------------</span><br><span class=\"line\">------------</span><br><span class=\"line\">| message  |</span><br><span class=\"line\">|----------|   a &gt; 5 AND b = &#x27;abc&#x27;</span><br><span class=\"line\">| a = 1    |  --------------------&gt; Missed</span><br><span class=\"line\">| b = &#x27;abc&#x27;|</span><br><span class=\"line\">| c = true |</span><br><span class=\"line\">------------</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本语法\"><a class=\"markdownIt-Anchor\" href=\"#基本语法\">#</a> 基本语法</h2>\n<p><code>RocketMQ</code>  只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>\n<ul>\n<li>数值比较，比如： <code>&gt;</code> ， <code>&gt;=</code> ， <code>&lt;</code> ， <code>&lt;=</code> ， <code>BETWEEN</code> ， <code>=</code> ；</li>\n<li>字符比较，比如： <code>=</code> ， <code>&lt;&gt;</code> ， <code>IN</code> ；</li>\n<li><code>IS NULL </code> 或者  <code>IS NOT NUL</code> L；</li>\n<li>逻辑符号  <code>AND</code> ， <code>OR</code> ， <code>NOT</code> ；</li>\n<li>常量支持类型为：</li>\n<li>数值，比如： <code>123</code> ， <code>3.1415</code> ；</li>\n<li>字符，比如： <code>'abc'</code> ，必须用单引号包裹起来；</li>\n<li><code>NULL</code> ，特殊的常量</li>\n<li>布尔值， <code>TRUE</code>  或  <code>FALSE</code></li>\n<li>只有使用 <code>push</code>  模式的消费者才能用使用 <code>SQL92</code>  标准的 <code>sql</code>  语句，接口如下： <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(finalString topic, <span class=\"keyword\">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"使用样例\"><a class=\"markdownIt-Anchor\" href=\"#使用样例\">#</a> 使用样例</h2>\n<h3 id=\"生产者样例\"><a class=\"markdownIt-Anchor\" href=\"#生产者样例\">#</a> 生产者样例</h3>\n<p>发送消息时，你能通过 <code>putUserProperty</code>  来设置消息的属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">producer.start();</span><br><span class=\"line\">Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span>,</span><br><span class=\"line\">   tag,</span><br><span class=\"line\">   (<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 设置一些属性</span></span><br><span class=\"line\">msg.putUserProperty(<span class=\"string\">&quot;a&quot;</span>, String.valueOf(i));</span><br><span class=\"line\">SendResult sendResult = producer.send(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">producer.shutdown();</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费者样例\"><a class=\"markdownIt-Anchor\" href=\"#消费者样例\">#</a> 消费者样例</h3>\n<p>用 <code>MessageSelector.bySql</code>  来使用 <code>sql</code>  筛选消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;please_rename_unique_group_name_4&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></span><br><span class=\"line\">consumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, MessageSelector.bySql(<span class=\"string\">&quot;a between 0 and 3&quot;</span>);</span><br><span class=\"line\">consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">consumer.start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-04.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-04.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF/",
            "title": "RocketMQ样例:批量消息",
            "date_published": "2021-09-23T09:19:00.000Z",
            "content_html": "<h2 id=\"批量消息样例\"><a class=\"markdownIt-Anchor\" href=\"#批量消息样例\">#</a> 批量消息样例</h2>\n<p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的 <code>topic</code> ，相同的 <code>waitStoreMsgOK</code> ，而且不能是延时消息。此外，这一批消息的总大小不应超过 <code>4MB</code> 。</p>\n<h2 id=\"发送批量消息\"><a class=\"markdownIt-Anchor\" href=\"#发送批量消息\">#</a> 发送批量消息</h2>\n<p>如果您每次只发送不超过 <code>4MB</code>  的消息，则很容易使用批处理，样例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String topic = <span class=\"string\">&quot;BatchTest&quot;</span>;</span><br><span class=\"line\">List&lt;Message&gt; messages = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">messages.add(<span class=\"keyword\">new</span> Message(topic, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"string\">&quot;OrderID001&quot;</span>, <span class=\"string\">&quot;Hello world 0&quot;</span>.getBytes()));</span><br><span class=\"line\">messages.add(<span class=\"keyword\">new</span> Message(topic, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"string\">&quot;OrderID002&quot;</span>, <span class=\"string\">&quot;Hello world 1&quot;</span>.getBytes()));</span><br><span class=\"line\">messages.add(<span class=\"keyword\">new</span> Message(topic, <span class=\"string\">&quot;TagA&quot;</span>, <span class=\"string\">&quot;OrderID003&quot;</span>, <span class=\"string\">&quot;Hello world 2&quot;</span>.getBytes()));</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   producer.send(messages);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">   e.printStackTrace();</span><br><span class=\"line\">   <span class=\"comment\">//处理error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息列表分割\"><a class=\"markdownIt-Anchor\" href=\"#消息列表分割\">#</a> 消息列表分割</h2>\n<p>复杂度只有当你发送大批量时才会增长，你可能不确定它是否超过了大小限制（ <code>4MB</code> ）。这时候你最好把你的消息列表分割一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListSplitter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">List</span>&lt;<span class=\"title\">Message</span>&gt;&gt; </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE_LIMIT = <span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Message&gt; messages;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currIndex;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ListSplitter</span><span class=\"params\">(List&lt;Message&gt; messages)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.messages = messages;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currIndex &lt; messages.size(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Message&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">int</span> startIndex = getStartIndex();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextIndex = startIndex;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class=\"line\">            Message message = messages.get(nextIndex); </span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpSize = calcMessageSize(message);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>; </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                totalSize += tmpSize; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;Message&gt; subList = messages.subList(startIndex, nextIndex); </span><br><span class=\"line\">        currIndex = nextIndex;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getStartIndex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message currMessage = messages.get(currIndex); </span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmpSize = calcMessageSize(currMessage); </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class=\"line\">            currIndex += <span class=\"number\">1</span>;</span><br><span class=\"line\">            Message message = messages.get(curIndex); </span><br><span class=\"line\">            tmpSize = calcMessageSize(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currIndex; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">calcMessageSize</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmpSize = message.getTopic().length() + message.getBody().length(); </span><br><span class=\"line\">        Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class=\"line\">            tmpSize += entry.getKey().length() + entry.getValue().length(); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmpSize = tmpSize + <span class=\"number\">20</span>; <span class=\"comment\">// 增加⽇日志的开销20字节</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmpSize; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把大的消息分裂成若干个小的消息</span></span><br><span class=\"line\">ListSplitter splitter = <span class=\"keyword\">new</span> ListSplitter(messages);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (splitter.hasNext()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class=\"line\">      producer.send(listItem);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">      <span class=\"comment\">//处理error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-03.%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/23/rocketMQ/1-04-03.%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/",
            "title": "RocketMQ样例:延时消息",
            "date_published": "2021-09-23T09:17:00.000Z",
            "content_html": "<h2 id=\"启动消费者等待传入订阅消息\"><a class=\"markdownIt-Anchor\" href=\"#启动消费者等待传入订阅消息\">#</a> 启动消费者等待传入订阅消息</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 实例化消费者</span></span><br><span class=\"line\">      DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;ExampleConsumer&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 订阅Topics</span></span><br><span class=\"line\">      consumer.subscribe(<span class=\"string\">&quot;TestTopic&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 注册消息监听者</span></span><br><span class=\"line\">      consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (MessageExt message : messages) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// Print approximate delay time period</span></span><br><span class=\"line\">                  System.out.println(<span class=\"string\">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class=\"string\">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getBornTimestamp()) + <span class=\"string\">&quot;ms later&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"comment\">// 启动消费者</span></span><br><span class=\"line\">      consumer.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"发送延时消息\"><a class=\"markdownIt-Anchor\" href=\"#发送延时消息\">#</a> 发送延时消息</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduledMessageProducer</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 实例化一个生产者来产生延时消息</span></span><br><span class=\"line\">      DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 启动生产者</span></span><br><span class=\"line\">      producer.start();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> totalMessagesToSend = <span class=\"number\">100</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class=\"line\">          Message message = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TestTopic&quot;</span>, (<span class=\"string\">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class=\"line\">          <span class=\"comment\">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class=\"line\">          message.setDelayTimeLevel(<span class=\"number\">3</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">          producer.send(message);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 关闭生产者</span></span><br><span class=\"line\">      producer.shutdown();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证\"><a class=\"markdownIt-Anchor\" href=\"#验证\">#</a> 验证</h2>\n<p>您将会看到消息的消费比存储时间晚 <code>10</code>  秒。</p>\n<h2 id=\"延时消息的使用场景\"><a class=\"markdownIt-Anchor\" href=\"#延时消息的使用场景\">#</a> 延时消息的使用场景</h2>\n<p>比如电商里，提交了一个订单就可以发送一个延时消息， <code>1h</code>  后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>\n<h2 id=\"延时消息的使用限制\"><a class=\"markdownIt-Anchor\" href=\"#延时消息的使用限制\">#</a> 延时消息的使用限制</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String messageDelayLevel = <span class=\"string\">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>现在 <code>RocketMq</code>  并不支持任意时间的延时，需要设置几个固定的延时等级，从 <code>1s</code>  到 <code>2h</code>  分别对应着等级 1 到 18 消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关，详见代码 <code>SendMessageProcessor.java</code></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/06/rocketMQ/1-04-02.%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/06/rocketMQ/1-04-02.%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/",
            "title": "RocketMQ样例:全局顺序消息",
            "date_published": "2021-09-06T09:17:00.000Z",
            "content_html": "<p>消息有序指的是可以按照消息的发送顺序来消费 ( <code>FIFO</code> )。 <code>RocketMQ</code>  可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>\n<p>顺序消费的原理解析：在默认的情况下消息发送会采取 <code>Round Robin</code>  轮询方式把消息发送到不同的 <code>queue</code>  (分区队列)；而消费消息的时候从多个 <code>queue</code>  上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个 <code>queue</code>  中，消费的时候只从这个 <code>queue</code>  上依次拉取，则就保证了顺序。当发送和消费参与的 <code>queue</code>  只有一个，则是全局有序；如果多个 <code>queue</code>  参与，则为分区有序，即相对每个 <code>queue</code> ，消息都是有序的。</p>\n<p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个 <code>OrderId</code>  获取到的肯定是同一个队列。</p>\n<p>2.1 顺序消息生产</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.rocketmq.example.order2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.MessageQueueSelector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Producer，发送顺序消息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       producer.setNamesrvAddr(<span class=\"string\">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       producer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       String[] tags = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;TagA&quot;</span>, <span class=\"string\">&quot;TagC&quot;</span>, <span class=\"string\">&quot;TagD&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 订单列表</span></span><br><span class=\"line\">       List&lt;OrderStep&gt; orderList = <span class=\"keyword\">new</span> Producer().buildOrders();</span><br><span class=\"line\"></span><br><span class=\"line\">       Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">       SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">       String dateStr = sdf.format(date);</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 加个时间前缀</span></span><br><span class=\"line\">           String body = dateStr + <span class=\"string\">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class=\"line\">           Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span>, tags[i % tags.length], <span class=\"string\">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">           SendResult sendResult = producer.send(msg, <span class=\"keyword\">new</span> MessageQueueSelector() &#123;</span><br><span class=\"line\">               <span class=\"meta\">@Override</span></span><br><span class=\"line\">               <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">select</span><span class=\"params\">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class=\"line\">                   Long id = (Long) arg;  <span class=\"comment\">//根据订单id选择发送queue</span></span><br><span class=\"line\">                   <span class=\"keyword\">long</span> index = id % mqs.size();</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> mqs.get((<span class=\"keyword\">int</span>) index);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;, orderList.get(i).getOrderId());<span class=\"comment\">//订单id</span></span><br><span class=\"line\"></span><br><span class=\"line\">           System.out.println(String.format(<span class=\"string\">&quot;SendResult status:%s, queueId:%d, body:%s&quot;</span>,</span><br><span class=\"line\">               sendResult.getSendStatus(),</span><br><span class=\"line\">               sendResult.getMessageQueue().getQueueId(),</span><br><span class=\"line\">               body));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       producer.shutdown();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 订单的步骤</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderStep</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> orderId;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> String desc;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getOrderId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> orderId;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOrderId</span><span class=\"params\">(<span class=\"keyword\">long</span> orderId)</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.orderId = orderId;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDesc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> desc;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDesc</span><span class=\"params\">(String desc)</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.desc = desc;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"meta\">@Override</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"string\">&quot;OrderStep&#123;&quot;</span> +</span><br><span class=\"line\">               <span class=\"string\">&quot;orderId=&quot;</span> + orderId +</span><br><span class=\"line\">               <span class=\"string\">&quot;, desc=&#x27;&quot;</span> + desc + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">               <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 生成模拟订单数据</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> List&lt;OrderStep&gt; <span class=\"title\">buildOrders</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       List&lt;OrderStep&gt; orderList = <span class=\"keyword\">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">       OrderStep orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111039L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;创建&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111065L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;创建&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111039L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;付款&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103117235L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;创建&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111065L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;付款&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103117235L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;付款&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111065L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;完成&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111039L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;推送&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103117235L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;完成&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       orderDemo = <span class=\"keyword\">new</span> OrderStep();</span><br><span class=\"line\">       orderDemo.setOrderId(<span class=\"number\">15103111039L</span>);</span><br><span class=\"line\">       orderDemo.setDesc(<span class=\"string\">&quot;完成&quot;</span>);</span><br><span class=\"line\">       orderList.add(orderDemo);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> orderList;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.2 顺序消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.rocketmq.example.order2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerInOrder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class=\"line\">       consumer.setNamesrvAddr(<span class=\"string\">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\"></span><br><span class=\"line\">       consumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, <span class=\"string\">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerOrderly() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> ConsumeOrderlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class=\"line\">               context.setAutoCommit(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class=\"line\">                   System.out.println(<span class=\"string\">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class=\"string\">&quot;, content:&quot;</span> + <span class=\"keyword\">new</span> String(msg.getBody()));</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//模拟业务逻辑处理中...</span></span><br><span class=\"line\">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class=\"number\">10</span>));</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                   e.printStackTrace();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       consumer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(<span class=\"string\">&quot;Consumer Started.&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/04/rocketMQ/1-04-01.%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/04/rocketMQ/1-04-01.%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B/",
            "title": "RocketMQ样例:基本的消息生产和消费",
            "date_published": "2021-09-04T09:17:00.000Z",
            "content_html": "<p>首先我们来学习一个简单的消费生产和消费的 <code>demo</code> .</p>\n<h2 id=\"生产消息\"><a class=\"markdownIt-Anchor\" href=\"#生产消息\">#</a> 生产消息</h2>\n<p><code>RocketMQ</code> ， 给我们提供了三种简单的消息生产方式， <code>1.同步发送</code> ，  <code>2.异步发送</code> ，  <code>3.直接发送，不关心发送结果</code> 。</p>\n<p>这三种方式，分别对应三种不同的应用场景</p>\n<h3 id=\"同步发送\"><a class=\"markdownIt-Anchor\" href=\"#同步发送\">#</a> 同步发送</h3>\n<p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。这种发送方式，在发送成功之后，才会返回，否则会一直阻塞，直到抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncProducer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消息生产者Producer</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">    \tproducer.setNamesrvAddr(<span class=\"string\">&quot;192.168.1.65:9876&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 启动Producer实例</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    \t    <span class=\"comment\">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class=\"line\">    \t    Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span> <span class=\"comment\">/* Topic */</span>,</span><br><span class=\"line\">        \t<span class=\"string\">&quot;TagA&quot;</span> <span class=\"comment\">/* Tag */</span>,</span><br><span class=\"line\">        \t(<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class=\"comment\">/* Message body */</span></span><br><span class=\"line\">        \t);</span><br><span class=\"line\">        \t<span class=\"comment\">// 发送消息到一个Broker</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            <span class=\"comment\">// 通过sendResult返回消息是否成功送达</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class=\"line\">    \tproducer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异步发送\"><a class=\"markdownIt-Anchor\" href=\"#异步发送\">#</a> 异步发送</h3>\n<p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待 <code>Broker</code>  的响应。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncProducer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消息生产者Producer</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;192.168.1.65:9876&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 启动Producer实例</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">        producer.setRetryTimesWhenSendAsyncFailed(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> messageCount = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 根据消息数量实例化倒计时计算器</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> CountDownLatch2 countDownLatch = <span class=\"keyword\">new</span> CountDownLatch2(messageCount);</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">            \t<span class=\"comment\">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class=\"line\">                Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;TagA&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;OrderID188&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class=\"line\">                <span class=\"comment\">// SendCallback接收异步返回结果的回调</span></span><br><span class=\"line\">                producer.send(msg, <span class=\"keyword\">new</span> SendCallback() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(SendResult sendResult)</span> </span>&#123;</span><br><span class=\"line\">                        System.out.printf(<span class=\"string\">&quot;%-10d OK %s %n&quot;</span>, index,</span><br><span class=\"line\">                            sendResult.getMsgId());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">      \t              System.out.printf(<span class=\"string\">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class=\"line\">      \t              e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            \t&#125;);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待5s</span></span><br><span class=\"line\">\tcountDownLatch.await(<span class=\"number\">5</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class=\"line\">    \tproducer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"单向发送消息\"><a class=\"markdownIt-Anchor\" href=\"#单向发送消息\">#</a> 单向发送消息</h3>\n<p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnewayProducer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消息生产者Producer</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">        producer.setNamesrvAddr(<span class=\"string\">&quot;192.168.1.65:9876&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 启动Producer实例</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class=\"line\">        \tMessage msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span> <span class=\"comment\">/* Topic */</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;TagA&quot;</span> <span class=\"comment\">/* Tag */</span>,</span><br><span class=\"line\">                (<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class=\"comment\">/* Message body */</span></span><br><span class=\"line\">        \t);</span><br><span class=\"line\">        \t<span class=\"comment\">// 发送单向消息，没有任何返回结果</span></span><br><span class=\"line\">        \tproducer.sendOneway(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class=\"line\">    \tproducer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息消费\"><a class=\"markdownIt-Anchor\" href=\"#消息消费\">#</a> 消息消费</h2>\n<h3 id=\"push-模式-消费\"><a class=\"markdownIt-Anchor\" href=\"#push-模式-消费\">#</a> Push 模式 消费</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;192.168.1.65:9876&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 注册回调实现类来处理从broker拉取回来的消息</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class=\"line\">                <span class=\"comment\">// 标记该消息已经被成功消费</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 启动消费者实例</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Consumer Started.%n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pull-模式消费-assign\"><a class=\"markdownIt-Anchor\" href=\"#pull-模式消费-assign\">#</a> Pull 模式消费 - Assign</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LitePullConsumerAssign</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 LitePullConsumer 实例</span></span><br><span class=\"line\">        DefaultLitePullConsumer litePullConsumer = <span class=\"keyword\">new</span> DefaultLitePullConsumer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不自动提交 消息消费的偏移量</span></span><br><span class=\"line\">        litePullConsumer.setAutoCommit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 启动消费者</span></span><br><span class=\"line\">        litePullConsumer.start();</span><br><span class=\"line\">        <span class=\"comment\">// 拉取topicTest的MessageQueue列表</span></span><br><span class=\"line\">        Collection&lt;MessageQueue&gt; mqSet = litePullConsumer.fetchMessageQueues(<span class=\"string\">&quot;TopicTest&quot;</span>);</span><br><span class=\"line\">        List&lt;MessageQueue&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(mqSet);</span><br><span class=\"line\">        List&lt;MessageQueue&gt; assignList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size() / <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            assignList.add(list.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 本消费分配的 MessageQueue 列表。本消费者只会消费assignList中的消息</span></span><br><span class=\"line\">        litePullConsumer.assign(assignList);</span><br><span class=\"line\">        <span class=\"comment\">// 改变下一次拉取时，消息的偏移量。</span></span><br><span class=\"line\">        litePullConsumer.seek(assignList.get(<span class=\"number\">0</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 消息拉取 API，默认超时时间为 5s。</span></span><br><span class=\"line\">                List&lt;MessageExt&gt; messageExts = litePullConsumer.poll();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;%s %n&quot;</span>, messageExts);</span><br><span class=\"line\">                <span class=\"comment\">// 提交偏移量</span></span><br><span class=\"line\">                litePullConsumer.commitSync();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            litePullConsumer.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pull-模式消费-subcribe\"><a class=\"markdownIt-Anchor\" href=\"#pull-模式消费-subcribe\">#</a> Pull 模式消费 - SUBCRIBE</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LitePullConsumerSubscribe</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DefaultLitePullConsumer litePullConsumer = <span class=\"keyword\">new</span> DefaultLitePullConsumer(<span class=\"string\">&quot;lite_pull_consumer_test&quot;</span>);</span><br><span class=\"line\">        litePullConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class=\"line\">        litePullConsumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        litePullConsumer.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                List&lt;MessageExt&gt; messageExts = litePullConsumer.poll();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, messageExts);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            litePullConsumer.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"https://fangjiaxiaobai.github.io/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/04/rocketMQ/1-04-00.RocketMQ%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/04/rocketMQ/1-04-00.RocketMQ%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/",
            "title": "RocketMQ系列-在Java应用中的使用",
            "date_published": "2021-09-04T09:14:00.000Z",
            "content_html": "<p>上一篇文章中我们成功地搭建了几种 RocketMQ 的部署方式。<br>\n这篇文章，我们就来看一下 RocketMQ 所支持的消息类型在 Java 应用中的使用。</p>\n<h2 id=\"加入依赖\"><a class=\"markdownIt-Anchor\" href=\"#加入依赖\">#</a> 加入依赖</h2>\n<p>在上一篇文章中，我们已经使用过 RocketMQ 进行收发消息了。这一篇呢，我从头开始来学习使用 RocketMQ.</p>\n<p>首先，引入 Maven 依赖，</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.9.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果你使用 <code>gradle</code> ， 则使用  <code>compile 'org.apache.rocketmq:rocketmq-client:4.9.1'</code>  即可。</p>\n<h2 id=\"消息类型\"><a class=\"markdownIt-Anchor\" href=\"#消息类型\">#</a> 消息类型</h2>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"><label for=\"cbx_0\"> <a href=\"./1-04-01.%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B.md\">基本样例 - 基本的消息收发案例</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\"><label for=\"cbx_1\"> <a href=\"./1-04-02.%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF.md\">顺序消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\"><label for=\"cbx_2\"> <a href=\"./1-04-03.%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF.md\">延时消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\"><label for=\"cbx_3\"> <a href=\"./1-04-04.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF.md\">批量消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\"><label for=\"cbx_4\"> <a href=\"./1-04-05.%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF.md\">过滤消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\"><label for=\"cbx_5\"> <a href=\"./1-04-06.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.md\">事务消息</a></label></li>\n</ul>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"./images/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/03/rocketMQ/1-03-RocketMQ%E6%90%AD%E5%BB%BA/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/03/rocketMQ/1-03-RocketMQ%E6%90%AD%E5%BB%BA/",
            "title": "RocketMQ系列-搭建RocketMQ集群",
            "date_published": "2021-09-03T09:17:00.000Z",
            "content_html": "<h1 id=\"搭建rocketmq集群\"><a class=\"markdownIt-Anchor\" href=\"#搭建rocketmq集群\">#</a> 搭建 RocketMQ 集群</h1>\n<p>根据之前的了解，我们已经知道了 RocketMQ 可以单机部署，支持集群部署。</p>\n<p>RocketMQ 支持以下集中部署方式  <code>1.单Master模式部署</code> ， <code>2.多Master模式部署</code> ， <code>3.多Master多Slaver模式部署</code></p>\n<h2 id=\"单master模式\"><a class=\"markdownIt-Anchor\" href=\"#单master模式\">#</a> 单 Master 模式</h2>\n<p>这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。</p>\n<h3 id=\"启动-nameserver\"><a class=\"markdownIt-Anchor\" href=\"#启动-nameserver\">#</a> 启动 NameServer</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 首先启动Name Server</span></span><br><span class=\"line\">$ nohup sh mqnamesrv &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 验证Name Server 是否启动成功</span></span><br><span class=\"line\">$ tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\">The Name Server boot success...</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动-broker\"><a class=\"markdownIt-Anchor\" href=\"#启动-broker\">#</a> 启动 Broker</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 启动Broker</span></span><br><span class=\"line\">$ nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 验证Name Server 是否启动成功，例如Broker的IP为：192.168.1.2，且名称为broker-a</span></span><br><span class=\"line\">$ tail -f ~/logs/rocketmqlogs/broker.log </span><br><span class=\"line\">The broker[broker-a, 192.169.1.2:10911] boot success...</span><br></pre></td></tr></table></figure>\n<h3 id=\"验证\"><a class=\"markdownIt-Anchor\" href=\"#验证\">#</a> 验证</h3>\n<p>我们使用 Java 程序来简单的验证下消息的发送和消费，这也是我们第一次去使用 RocketMQ.</p>\n<h4 id=\"加入maven依赖\"><a class=\"markdownIt-Anchor\" href=\"#加入maven依赖\">#</a> 加入 maven 依赖</h4>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.rocketmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>rocketmq-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生产消息\"><a class=\"markdownIt-Anchor\" href=\"#生产消息\">#</a> 生产消息</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消息生产者Producer</span></span><br><span class=\"line\">        DefaultMQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">    \tproducer.setNamesrvAddr(<span class=\"string\">&quot;localhost:9876&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 启动Producer实例</span></span><br><span class=\"line\">        producer.start();</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    \t    <span class=\"comment\">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class=\"line\">    \t    Message msg = <span class=\"keyword\">new</span> Message(<span class=\"string\">&quot;TopicTest&quot;</span> <span class=\"comment\">/* Topic */</span>,</span><br><span class=\"line\">        \t<span class=\"string\">&quot;TagA&quot;</span> <span class=\"comment\">/* Tag */</span>,</span><br><span class=\"line\">        \t(<span class=\"string\">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class=\"comment\">/* Message body */</span></span><br><span class=\"line\">        \t);</span><br><span class=\"line\">        \t<span class=\"comment\">// 发送消息到一个Broker</span></span><br><span class=\"line\">            SendResult sendResult = producer.send(msg);</span><br><span class=\"line\">            <span class=\"comment\">// 通过sendResult返回消息是否成功送达</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;%s%n&quot;</span>, sendResult);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class=\"line\">    \tproducer.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消费消息\"><a class=\"markdownIt-Anchor\" href=\"#消费消息\">#</a> 消费消息</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化消费者</span></span><br><span class=\"line\">        DefaultMQPushConsumer consumer = <span class=\"keyword\">new</span> DefaultMQPushConsumer(<span class=\"string\">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 设置NameServer的地址</span></span><br><span class=\"line\">        consumer.setNamesrvAddr(<span class=\"string\">&quot;localhost:9876&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class=\"line\">        consumer.subscribe(<span class=\"string\">&quot;TopicTest&quot;</span>, <span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">    \t<span class=\"comment\">// 注册回调实现类来处理从broker拉取回来的消息</span></span><br><span class=\"line\">        consumer.registerMessageListener(<span class=\"keyword\">new</span> MessageListenerConcurrently() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> ConsumeConcurrentlyStatus <span class=\"title\">consumeMessage</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class=\"line\">                <span class=\"comment\">// 标记该消息已经被成功消费</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 启动消费者实例</span></span><br><span class=\"line\">        consumer.start();</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Consumer Started.%n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遇到的问题:</p>\n</blockquote>\n<p>按照上面的步骤，你运行成功了吗？？？</p>\n<p>我反正是没有成功的生产消息。为什么呢？</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzEuTm8=\">1.No</span> route info of this topic, TopicTest</p>\n</blockquote>\n<p>原因是：我们在启动的时候，并没有创建  <code>TopicTest</code>  这个 Topic.</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread &quot;main&quot; org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, TopicTest</span><br><span class=\"line\">See http://rocketmq.apache.org/docs/faq/ <span class=\"keyword\">for</span> further details.</span><br><span class=\"line\">\t<span class=\"built_in\">at</span> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:<span class=\"number\">610</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">at</span> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class=\"number\">1223</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">at</span> org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:<span class=\"number\">1173</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">at</span> org.apache.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:<span class=\"number\">214</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">at</span> com.fxb.learn_rocketmq.Producer.main(Producer.java:<span class=\"number\">23</span>)</span><br></pre></td></tr></table></figure>\n<p>这种问题的原因两种。 1. 网络不通，连接不到端口。  2. 没有创建这个 Topic.<br>\n 真不巧，我全遇到了。</p>\n<p>第一种呢，使用 telnet 命令，如果通了就解决了。<br>\n第二种，使用  <code>sh mqadmin updateTopic -n localhost:9876 -b 192.168.1.63:10911 -t TopicTest</code>  -n 表示 NameSerer 的地址，-b 表示 Broker 的地址，-t<br>\n 后面的就是 topicName 了。</p>\n<blockquote>\n<p>2.Broker 启动失败，提示 空间不足。</p>\n</blockquote>\n<p>原因是：在 <span class=\"exturl\" data-url=\"aHR0cDovL3J1blNlcnZlci5zaA==\">runServer.sh</span> 和 <span class=\"exturl\" data-url=\"aHR0cDovL3J1bmJyb2tlci5zaA==\">runbroker.sh</span> 脚本中配置了启动的内存大小， NameServer 启动的堆内存是 4G, 而 broker 启动的是 8g 所以，回报错因 空间不足，启动失败。</p>\n<blockquote>\n<p>3. 运行 mqadmin 命令是报错</p>\n</blockquote>\n<p>我遇到的问题是因为 宿主机安装的是 openJDK, 导致 脚本没有加载到对应的 ext 包，所以在 <span class=\"exturl\" data-url=\"aHR0cDovL3Rvb2xzLnNo\">tools.sh</span> 中加入 ext / 包的路径就可以了。 ext/ 就是 jre 下的 ext 包。</p>\n<p>如下图.<br>\n<img data-src=\"/images/rocketmq/1-03%E5%8D%95master%E9%83%A8%E7%BD%B2mqadmin%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99.png\" alt=\"\"></p>\n<h3 id=\"rocket运行程序\"><a class=\"markdownIt-Anchor\" href=\"#rocket运行程序\">#</a> Rocket 运行程序</h3>\n<p>我们先不急着去学习其他的部署方式，我们现在去看下 Rocket 运行程序的目录是什么样的。目的是了解 RocketMQ 是怎么跑起来的。这样遇到问题的时候，我们可以顺藤摸瓜去排查问题是出在什么地方。</p>\n<p><img data-src=\"/images/rocketmq/1-03-RocketMQ%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%AE%E5%BD%95.png\" alt=\"\"></p>\n<ul>\n<li>benchmark 包：提供了 Rocket 用于基准测试的工具。<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL3Byb2R1Y2VyLnNo\">producer.sh</span> ：测试普通 MQ 生产者的性能。<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL2NvbnN1bWVyLnNo\">consumer.sh</span> ：测试 MQ 消费者的性能。<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL3Rwcm9kdWNlci5zaA==\">tproducer.sh</span> ：测试事务 MQ 生产者的性能。<br>\n<span class=\"exturl\" data-url=\"aHR0cDovL2JhdGNocHJvZHVjZXIuc2g=\">batchproducer.sh</span>: 测试批量生产者的性能。</li>\n<li>bin: 提供了 启动关闭 NameServer, 启动关闭 Broker，管理 MQ 的工具。\n<ul>\n<li>mqnamesrv： 启动 NameServer 的脚本</li>\n<li>mqbroker: 启动 Broker 的脚本</li>\n<li>mqadmin: 管理 RocketMQ 的脚本</li>\n<li>mqshutdown: 关闭 MQ 的脚本</li>\n</ul>\n</li>\n<li>conf: 对 RocketMQ 进行配置的文件目录。\n<ul>\n<li>broker.conf： broker 的配置</li>\n<li>logback-*.xml: logback 日志的配置，比如 Broker，nameServer,tools 的日志配置</li>\n<li>plain_acl.yml： 权限管理的文件</li>\n<li>tools.yml: 脚本工具的配置</li>\n<li>dledger: 容灾相关的配置</li>\n</ul>\n</li>\n<li>lib: 这里存放的就是编译之后的 class 文件。</li>\n</ul>\n<p>如果在启动或者使用其他的命令遇到问题的时候，可以到对应的目录中，找到文件，然后看下代码进行处理。</p>\n<p>下面我们接着去看其他的部署方式。</p>\n<h2 id=\"多master模式\"><a class=\"markdownIt-Anchor\" href=\"#多master模式\">#</a> 多 Master 模式</h2>\n<p>一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master，这种模式的优缺点如下：</p>\n<ul>\n<li>\n<p>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</p>\n</li>\n<li>\n<p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</p>\n</li>\n</ul>\n<h3 id=\"启动nameserver\"><a class=\"markdownIt-Anchor\" href=\"#启动nameserver\">#</a> 启动 NameServer</h3>\n<p><b>NameServer 需要先于 Broker 启动，且如果在生产环境使用，为了保证高可用，建议一般规模的集群启动 3 个 NameServer</b>，各节点的启动命令相同，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 首先启动Name Server</span></span><br><span class=\"line\">$ nohup sh mqnamesrv &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 验证Name Server 是否启动成功</span></span><br><span class=\"line\">$ tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\">The Name Server boot success...</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动broker集群\"><a class=\"markdownIt-Anchor\" href=\"#启动broker集群\">#</a> 启动 Broker 集群</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 在机器A，启动第一个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-a.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器B，启动第二个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-noslave/broker-b.properties &amp;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>如上启动命令是在单个 NameServer 情况下使用的。对于多个 NameServer 的集群，Broker 启动命令中 <code>-n</code>  后面的地址列表用分号隔开即可，例如  <code>192.168.1.1:9876;192.161.2:9876</code> 。</p>\n<h2 id=\"13-多master多slave模式-异步复制\"><a class=\"markdownIt-Anchor\" href=\"#13-多master多slave模式-异步复制\">#</a> 1.3 多 Master 多 Slave 模式 - 异步复制</h2>\n<p>每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>\n<ul>\n<li>\n<p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</p>\n</li>\n<li>\n<p>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息。</p>\n</li>\n</ul>\n<h3 id=\"启动nameserver-2\"><a class=\"markdownIt-Anchor\" href=\"#启动nameserver-2\">#</a> 启动 NameServer</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 首先启动Name Server</span></span><br><span class=\"line\">$ nohup sh mqnamesrv &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 验证Name Server 是否启动成功</span></span><br><span class=\"line\">$ tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\">The Name Server boot success...</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动broker集群-2\"><a class=\"markdownIt-Anchor\" href=\"#启动broker集群-2\">#</a> 启动 Broker 集群</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 在机器A，启动第一个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器B，启动第二个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器C，启动第一个Slave，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-a-s.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器D，启动第二个Slave，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多master多slave模式-同步双写\"><a class=\"markdownIt-Anchor\" href=\"#多master多slave模式-同步双写\">#</a> 多 Master 多 Slave 模式 - 同步双写</h3>\n<p>每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>\n<ul>\n<li>\n<p>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</p>\n</li>\n<li>\n<p>缺点：性能比异步复制模式略低（大约低 10% 左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p>\n</li>\n</ul>\n<h3 id=\"启动nameserver-3\"><a class=\"markdownIt-Anchor\" href=\"#启动nameserver-3\">#</a> 启动 NameServer</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 首先启动Name Server</span></span><br><span class=\"line\">$ nohup sh mqnamesrv &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 验证Name Server 是否启动成功</span></span><br><span class=\"line\">$ tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=\"line\">The Name Server boot success...</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动broker集群-3\"><a class=\"markdownIt-Anchor\" href=\"#启动broker集群-3\">#</a> 启动 Broker 集群</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 在机器A，启动第一个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器B，启动第二个Master，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器C，启动第一个Slave，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-a-s.properties &amp;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">### 在机器D，启动第二个Slave，例如NameServer的IP为：192.168.1.1</span></span><br><span class=\"line\">$ nohup sh mqbroker -n 192.168.1.1:9876 -c <span class=\"variable\">$ROCKETMQ_HOME</span>/conf/2m-2s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>以上 Broker 与 Slave 配对是通过指定相同的 BrokerName 参数来配对，Master 的 BrokerId 必须是 0，Slave 的 BrokerId 必须是大于 0 的数。另外一个 Master 下面可以挂载多个 Slave，同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分。$ROCKETMQ_HOME 指的 RocketMQ 安装目录，需要用户自己设置此环境变量。</p>\n<h1 id=\"mqadmin管理工具\"><a class=\"markdownIt-Anchor\" href=\"#mqadmin管理工具\">#</a> mqadmin 管理工具</h1>\n<p>关于 mqadmin 命令的使用，我们可以通过  <code>sh mqadmin</code>  命令来查看命令的选项，用的多自然就记住了，后面我们也不会通过这种方式来管理 RocketMQ 集群。但是在我们学习的过程中，我们还是会非常频繁的使用这个命令。</p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>执行命令方法： <code>./mqadmin &#123;command&#125; &#123;args&#125;</code></li>\n<li>几乎所有命令都需要配置 - n 表示 NameServer 地址，格式为 ip:port</li>\n<li>几乎所有命令都可以通过 - h 获取帮助</li>\n<li>如果既有 Broker 地址（-b）配置项又有 clusterName（-c）配置项，则优先以 Broker 地址执行命令，如果不配置 Broker 地址，则对集群中所有主机执行命令，只支持一个 Broker 地址。-b 格式为 ip:port，port 默认是 10911</li>\n<li>在 tools 下可以看到很多命令，但并不是所有命令都能使用，只有在 MQAdminStartup 中初始化的命令才能使用，你也可以修改这个类，增加或自定义命令</li>\n<li>由于版本更新问题，少部分命令可能未及时更新，遇到错误请直接阅读相关命令源码</li>\n</ol>\n</blockquote>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/02/rocketMQ/1-02-RocketMQ%E6%A6%82%E5%BF%B5/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/02/rocketMQ/1-02-RocketMQ%E6%A6%82%E5%BF%B5/",
            "title": "RocketMQ系列-RocketMQ概念",
            "date_published": "2021-09-02T09:17:00.000Z",
            "content_html": "<h2 id=\"rocketmq概念\"><a class=\"markdownIt-Anchor\" href=\"#rocketmq概念\">#</a> RocketMQ 概念</h2>\n<p>我在学习 <code>RocketMQ</code>  的时候，看到文档中介绍了很多的概念。我非常反感，但是又没有办法，没有这些概念，就没办法更好的去学习后面的内容，当后面使用很多名词来梳理实现原理的时候，就会一头雾水。</p>\n<p>上一篇文章中，我们知道了 <code>RocketMQ</code>  由四部分构成。</p>\n<h3 id=\"消息模型\"><a class=\"markdownIt-Anchor\" href=\"#消息模型\">#</a> 消息模型</h3>\n<p><code>Producer</code>  负责生产消息， <code>Consumer</code>  负责消费消息， <code>Broker</code>  负责存储消息， <code>NameServer</code>  负责对 <code>Producer</code>  和  <code>Customer</code>  的服务发现，还有路由这两个功能。 <code>Broker</code>  在实际部署过程中对应一台服务器，每个  <code>Broker</code>  可以存储多个 <code>Topic</code>  的消息，每个 <code>Topic</code>  的消息也可以分片存储于不同的  <code>Broker</code> 。 <code>Message Queue</code>  用于存储消息的物理地址，每个 <code>Topic</code>  中的消息地址存储于多个  <code>Message Queue</code>  中。 <code>ConsumerGroup</code>  由多个 <code>Consumer</code>  实例构成。</p>\n<h3 id=\"消息生产者producer\"><a class=\"markdownIt-Anchor\" href=\"#消息生产者producer\">#</a> 消息生产者（Producer）</h3>\n<p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到 <code>broker</code>  服务器。 <code>RocketMQ</code>  提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要 <code>Broker</code>  返回确认信息，单向发送不需要。</p>\n<h3 id=\"消息消费者consumer\"><a class=\"markdownIt-Anchor\" href=\"#消息消费者consumer\">#</a> 消息消费者（ <code>Consumer</code> ）</h3>\n<p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从 <code>Broker</code>  服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费 ( <code>pull</code> )、推动式消费 ( <code>push</code> )。</p>\n<h3 id=\"生产者组producer-group\"><a class=\"markdownIt-Anchor\" href=\"#生产者组producer-group\">#</a> 生产者组（ <code>Producer Group</code> ）</h3>\n<p>同一类 <code>Producer</code>  的集合，这类 <code>Producer</code>  发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则 <code>Broker</code>  服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>\n<h3 id=\"消费者组consumer-group\"><a class=\"markdownIt-Anchor\" href=\"#消费者组consumer-group\">#</a> 消费者组（ <code>Consumer Group</code> ）</h3>\n<p>同一类 <code>Consumer</code>  的集合，这类 <code>Consumer</code>  通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 <code>Topic</code> 。 <code>RocketMQ </code> 支持两种消息模式：集群消费（ <code>Clustering</code> ）和广播消费（ <code>Broadcasting</code> ）。</p>\n<h3 id=\"拉取式消费pull-consumer\"><a class=\"markdownIt-Anchor\" href=\"#拉取式消费pull-consumer\">#</a> 拉取式消费（ <code>Pull Consumer</code> ）</h3>\n<p><code>Consumer</code>  消费的一种类型，应用通常主动调用 <code>Consumer</code>  的拉消息方法从 <code>Broker</code>  服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>\n<h3 id=\"推动式消费push-consumer\"><a class=\"markdownIt-Anchor\" href=\"#推动式消费push-consumer\">#</a> 推动式消费（ <code>Push Consumer</code> ）</h3>\n<p><code>Consumer</code>  消费的一种类型，该模式下 <code>Broker</code>  收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>\n<h3 id=\"主题topic\"><a class=\"markdownIt-Anchor\" href=\"#主题topic\">#</a> 主题（ <code>Topic</code> ）</h3>\n<p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 <code>RocketMQ</code>  进行消息订阅的基本单位。</p>\n<h3 id=\"代理服务器broker-server\"><a class=\"markdownIt-Anchor\" href=\"#代理服务器broker-server\">#</a> 代理服务器（ <code>Broker Server</code> ）</h3>\n<p>消息中转角色，负责存储消息、转发消息。代理服务器在 <code>RocketMQ</code>  系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>\n<h3 id=\"nameserver\"><a class=\"markdownIt-Anchor\" href=\"#nameserver\">#</a>  <code>NameServer</code></h3>\n<p><code>NameServer</code>  充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的 <code>Broker IP</code>  列表。多个 <code>Nameserver</code>  实例组成集群，但相互独立，没有信息交换。</p>\n<h3 id=\"集群消费clustering\"><a class=\"markdownIt-Anchor\" href=\"#集群消费clustering\">#</a> 集群消费（ <code>Clustering</code> ）</h3>\n<p>集群消费模式下，相同 <code>Consumer Group</code>  的每个 <code>Consumer</code>  实例平均分摊消息。</p>\n<h3 id=\"广播消费broadcasting\"><a class=\"markdownIt-Anchor\" href=\"#广播消费broadcasting\">#</a> 广播消费（ <code>Broadcasting</code> ）</h3>\n<p>广播消费模式下，相同 <code>Consumer Group</code>  的每个 <code>Consumer</code>  实例都接收全量的消息。</p>\n<h3 id=\"普通顺序消息normal-ordered-message\"><a class=\"markdownIt-Anchor\" href=\"#普通顺序消息normal-ordered-message\">#</a> 普通顺序消息（ <code>Normal Ordered Message</code> ）</h3>\n<p>普通顺序消费模式下，消费者通过同一个消息队列（  <code>Topic</code>  分区，称作 M <code>essage Queue</code> ） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>\n<h3 id=\"严格顺序消息strictly-ordered-message\"><a class=\"markdownIt-Anchor\" href=\"#严格顺序消息strictly-ordered-message\">#</a> 严格顺序消息（ <code>Strictly Ordered Message</code> ）</h3>\n<p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>\n<h3 id=\"消息message\"><a class=\"markdownIt-Anchor\" href=\"#消息message\">#</a> 消息（ <code>Message</code> ）</h3>\n<p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。 <code>RocketMQ</code>  中每个消息拥有唯一的 <code>Message ID</code> ，且可以携带具有业务标识的 <code>Key</code> 。系统提供了通过 <code>Message ID</code>  和 <code>Key</code>  查询消息的功能。</p>\n<h3 id=\"标签tag\"><a class=\"markdownIt-Anchor\" href=\"#标签tag\">#</a> 标签（ <code>Tag</code> ）</h3>\n<p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 <code>RocketMQ</code>  提供的查询系统。消费者可以根据 <code>Tag</code>  实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n<p>这是一篇极为枯燥的文章。从下篇文章开始，我们开始对 <code>RocketMQ</code>  进行实践。从零搭建 <code>RocketMQ</code>  集群.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/rocketMQ/1-01-RocketMQ%E7%AE%80%E4%BB%8B/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/rocketMQ/1-01-RocketMQ%E7%AE%80%E4%BB%8B/",
            "title": "Rocket系列-入门",
            "date_published": "2021-09-01T09:17:00.000Z",
            "content_html": "<h1 id=\"rocketmq-介绍\"><a class=\"markdownIt-Anchor\" href=\"#rocketmq-介绍\">#</a> RocketMQ 介绍</h1>\n<p>截止  <code>2021</code>  年 <code>9</code>  月 <code>1</code>  日，  <code>RocketMQ</code>  最新版本是  <code>4.9.1</code> 。</p>\n<p>最新 <code>Star</code>  数为 <code>1.5w</code> .  <code>fork</code>  数量是 <code>8.4k</code> .</p>\n<p><img data-src=\"/images/rocketmq/RocketMQ-title-pic.png\" alt=\"\"></p>\n<h2 id=\"发展历程\"><a class=\"markdownIt-Anchor\" href=\"#发展历程\">#</a> 发展历程</h2>\n<p><code>RocketMQ</code>  的发展历程分为两部分， <code>2001</code>  年开始 <code>RocketMQ</code>  的前身 <code>Notify</code> ，在 <code>2016</code>  年阿里将 <code>RocketMQ</code>  捐赠给 <code>Apache</code>  基金会中进行孵化。</p>\n<h3 id=\"在阿里\"><a class=\"markdownIt-Anchor\" href=\"#在阿里\">#</a> 在阿里</h3>\n<p>阿里巴巴消息中间件起源于 <code>2001</code>  年的五彩石项目， <code>Notify</code>  在这期间应运而生，用于交易核心消息的流转。</p>\n<p>至 <code>2010</code>  年， <code>B2B</code>  开始大规模使用 <code>ActiveMQ</code>  作为消息内核，随着阿里业务的快速发展，急需一款支持顺序消息，拥有海量消息堆积能力的消息中间件， <code>MetaQ 1.0</code>  在 <code>2011</code>  年诞生。</p>\n<p>到 <code>2012</code>  年， <code>MetaQ</code>  已经发展到了 <code>MetaQ 3.0</code> ，并抽象出了通用的消息引擎 <code>RocketMQ</code> 。随后，将 <code>RocketMQ</code>  进行了开源，阿里的消息中间件正式走入了公众的视野。</p>\n<p>到 <code>2015</code>  年， <code>RocketMQ</code>  已经经历了多年双十一的洗礼，在可用性、可靠性以及稳定性等方面都有出色的表现。与此同时，云计算大行其道，阿里消息中间件基于 <code>RocketMQ</code>  推出了 <code>Aliware MQ 1.0</code> ，开始为阿里云上成千上万家企业提供消息服务。</p>\n<p>到今年， <code>MetaQ</code>  在 <code>2016</code>  年双十一承载了万亿级消息的流转，跨越了一个新的里程碑，同时 <code>RocketMQ</code>  进入 <code>Apache</code>  孵化。</p>\n<h3 id=\"apache\"><a class=\"markdownIt-Anchor\" href=\"#apache\">#</a> Apache</h3>\n<ul>\n<li><code>2017</code>  年 <code>2</code>  月 <code>7</code>  日  <code>4.0.0</code>  版本，成为 <code>Apache</code>  项目之后的第一个版本。属于 <code>Apache</code>  的孵化项目。</li>\n<li><code>2017</code>  年 <code>6</code>  月 <code>8</code>  日  <code>4.1.0</code>  版本，</li>\n<li><code>2017</code>  年 <code>12</code>  月 <code>13</code>  日  <code>4.2.0</code></li>\n<li><code>2018</code>  年 <code>7</code>  月 <code>26</code>  日  <code>4.3.0</code></li>\n<li><code>2019</code>  年 <code>1</code>  月 <code>17</code>  日  <code>4.4.0</code>  版本</li>\n<li><code>2019</code>  年 <code>5</code>  月 <code>21</code>  日  <code>4.5.1</code>  版本</li>\n<li><code>2019</code>  年 <code>11</code>  月 <code>19</code>  日  <code>4.6.0</code>  版本</li>\n<li><code>2020</code>  年 <code>3</code>  月 <code>5</code>  日  <code>4.7.0</code>  版本</li>\n<li><code>2020</code>  年 <code>12</code>  月 <code>9</code>  日  <code>4.8.0</code>  版本</li>\n<li><code>2021</code>  年 <code>6</code>  月 <code>17</code>  日  <code>4.9.0</code>  版本</li>\n<li><code>2021</code>  年 <code>8</code>  月 <code>27</code>  日   <code>4.9.1</code>  版本</li>\n</ul>\n<p>截止目前， <code>RocketMQ</code>  先后经历了 <code>20</code>  年的发展，承载这淘宝双十一万亿级消息的处理。</p>\n<h2 id=\"rocket特性\"><a class=\"markdownIt-Anchor\" href=\"#rocket特性\">#</a> Rocket 特性</h2>\n<p><code>RocketMQ</code>  具有下面的功能特性:</p>\n<ul>\n<li>订阅发布：这个是消息队里产品的基础功能。</li>\n<li>支持事务型消息：指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。</li>\n<li>支持延时消息：指消息发送到 <code>broker</code>  后，不会立即被消费，等待特定时间投递给真正的 <code>topic</code></li>\n<li>支持消息重试:  <code>Consumer</code>  消费消息失败后，要提供一种重试机制，令消息再消费一次</li>\n<li>支持消息过滤:  <code>RocketMQ</code>  的消费者可以根据 <code>Tag</code>  进行消息过滤，也支持自定义属性过滤。</li>\n<li>支持消息重放：生产者在发送消息时，同步消息失败会重投，异步消息有重试， <code>oneway</code>  没有任何保证。</li>\n<li>支持流量控制： 分为生产者流控和消费者流控。生产者流控因为 <code>broker</code>  处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</li>\n<li>支持死信队列：死信队列用于处理无法被正常消费的消息.</li>\n</ul>\n<p>在后面的学习中，我们也会着重的学习这几种特性。</p>\n<h2 id=\"rocketmq的组成部分\"><a class=\"markdownIt-Anchor\" href=\"#rocketmq的组成部分\">#</a> RocketMQ 的组成部分</h2>\n<p><code>Apache RocketMQ</code>  是一个分布式消息和流媒体平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可伸缩性。它由四部分组成:  <code>NameServer</code> 、 <code>Broker</code> 、 <code>Producer</code>  和 <code>Consumer</code> 。它们中的每一个都是可以集群方式部署，都可以水平地扩展，而不需要单个故障点。如下图。</p>\n<p><img data-src=\"/images/rocketmq/1-01-rmq-basic-arc.png\" alt=\"\"></p>\n<h3 id=\"nameserver-cluster\"><a class=\"markdownIt-Anchor\" href=\"#nameserver-cluster\">#</a> NameServer cluster</h3>\n<p><code>NameServer</code>  提供轻量级服务发现功能和消息路由功能。 每个  <code>Name Server</code>  记录完整的路由信息​​，提供相应的读写服务，并支持快速存储扩展。</p>\n<h3 id=\"broker-cluster\"><a class=\"markdownIt-Anchor\" href=\"#broker-cluster\">#</a> Broker Cluster</h3>\n<p><code>Broker</code>  通过提供轻量级的 <code>TOPIC</code>  和 <code>QUEUE</code>  机制来处理消息存储。它们支持 <code>Push</code>  和 <code>Pull</code>  模型，包含容错机制 ( <code>2</code>  个或 <code>3</code>  个副本)，并提供强大的峰值填充和以原始时间顺序积累数千亿条消息的能力。此外， <code>broker</code>  还提供了灾难恢复、丰富的指标统计信息和警报机制，这些都是传统消息传递系统所缺乏的。</p>\n<h3 id=\"producer-cluster\"><a class=\"markdownIt-Anchor\" href=\"#producer-cluster\">#</a> Producer Cluster</h3>\n<p>生产者支持分布式部署。分布式生产者通过多种负载平衡模式向 <code>Broker</code>  集群发送消息。发送进程支持快速故障和低延迟。</p>\n<h3 id=\"consumer-cluster\"><a class=\"markdownIt-Anchor\" href=\"#consumer-cluster\">#</a> Consumer Cluster</h3>\n<p>消费者也支持 <code>Push</code>  和 <code>Pull</code>  模型中的分布式部署。它还支持集群消费和消息广播。它提供了实时消息订阅机制，可以满足大多数用户的需求。</p>\n<p>下一篇文章我们一起学习一下 关于 <code>RocketMQ</code>  的相关概念。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/rocketMQ/README/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/rocketMQ/README/",
            "title": "RocketMQ系列-开篇",
            "date_published": "2021-09-01T09:16:00.000Z",
            "content_html": "<h2 id=\"开篇\"><a class=\"markdownIt-Anchor\" href=\"#开篇\">#</a> 开篇</h2>\n<p>写这篇文章的时间是 <code>2021</code>  年 <code>9</code>  月 <code>1</code>  日，不知道是否有勇气写完全部系列之后再发布给大家，这只能算是自己学习 <code>RocketMQ</code>  的笔记吧。希望在 2021 年的年底能够将整个系列完整的发布到方家小白公众号和 <a href=\"https://fangjiaxiaobai.github.io/\">fangjiaxiaobai.github.io</a> 博客中。想写的文章也还有很多，同时在写的有 《Java 的 Stream 并行流设计》 和  《聊聊面试那点事》。</p>\n<p>2021 年国家发布了很多政策，尤其是互联网行业，特别是 在线教育，我前些日子里也是一名在线教育从业者。</p>\n<p>而写这个系列的最根本的原因，也是因为被人常问的就是  <code>RocketMQ</code>  的底层原理，可想而知，我并答不上来。所以，欠自己的债，总是需要还的。</p>\n<p>趁着空档期，所以从零到一的去聊聊这 <code>RocketMQ</code> .</p>\n<p>相信很多同学都是或多或少的使用过 <code>RocketMQ</code> , 这里呢，我们还是从零到一的去学习。第一篇，第二篇都是比较枯燥的内容，本着理论先行的原则，我们会去了解  <code>RoctMQ</code>  的发展历程，和  <code>RocketMQ</code>  中使用的概念。 第三篇我们就会 自己搭建 <code>RocketMQ</code>  集群，为我们后面的案例和原理学习迈出具有里程碑意义的一步。</p>\n<h2 id=\"目录\"><a class=\"markdownIt-Anchor\" href=\"#目录\">#</a> 目录</h2>\n<h3 id=\"入门\"><a class=\"markdownIt-Anchor\" href=\"#入门\">#</a> 入门</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"><label for=\"cbx_0\"> <a href=\"/2021/09/01/rocketMQ/1-01-RocketMQ%E7%AE%80%E4%BB%8B/\">Rocket 系列 - 入门</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\"><label for=\"cbx_1\"> <a href=\"/2021/09/02/rocketMQ/1-02-RocketMQ%E6%A6%82%E5%BF%B5/\">概念</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\"><label for=\"cbx_2\"> <a href=\"/2021/09/03/rocketMQ/1-03-RocketMQ%E6%90%AD%E5%BB%BA/\">安装</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\"><label for=\"cbx_3\"> <a href=\"/2021/09/04/rocketMQ/1-04-00.RocketMQ%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/\">使用</a></label>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\"><label for=\"cbx_4\"> <a href=\"/2021/09/04/rocketMQ/1-04-01.%E5%9F%BA%E6%9C%AC%E6%A0%B7%E4%BE%8B/\">基本样例</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\"><label for=\"cbx_5\"> <a href=\"/2021/09/06/rocketMQ/1-04-02.%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF/\">顺序消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_6\" checked=\"true\" disabled=\"true\"><label for=\"cbx_6\"> <a href=\"/2021/09/23/rocketMQ/1-04-03.%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/\">延时消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_7\" checked=\"true\" disabled=\"true\"><label for=\"cbx_7\"> <a href=\"/2021/09/23/rocketMQ/1-04-04.%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF/\">批量消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_8\" checked=\"true\" disabled=\"true\"><label for=\"cbx_8\"> <a href=\"/2021/09/23/rocketMQ/1-04-05.%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF/\">过滤消息</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_9\" checked=\"true\" disabled=\"true\"><label for=\"cbx_9\"> <a href=\"/2021/09/23/rocketMQ/1-04-06.%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/\">事务消息</a></label></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进阶架构设计\"><a class=\"markdownIt-Anchor\" href=\"#进阶架构设计\">#</a> 进阶 (架构设计)</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_10\" checked=\"true\" disabled=\"true\"><label for=\"cbx_10\"> <a href=\"/2021/09/28/rocketMQ/2-01-RocketMQ-Arch-Start/\">架构设计之启动过程详解</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" checked=\"true\" disabled=\"true\"><label for=\"cbx_11\"> <a href=\"/2021/09/28/rocketMQ/2-02-RocketMQ-Arch-Message/\">架构设计之消息的收发过程详解</a></label></li>\n</ul>\n<h3 id=\"高手细节设计-解读源码\"><a class=\"markdownIt-Anchor\" href=\"#高手细节设计-解读源码\">#</a> 高手 (细节设计，解读源码)</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_12\" checked=\"true\" disabled=\"true\"><label for=\"cbx_12\"> <a href=\"/2022/01/02/rocketMQ/3-01-RocketMQ-Transaction-msg/\">事务消息实现原理</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_13\" disabled=\"true\"><label for=\"cbx_13\"> 延时消息实现原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_14\" checked=\"true\" disabled=\"true\"><label for=\"cbx_14\"> <a href=\"/2022/05/16/rocketMQ/3-02-reliabllity-msg/\">消息可靠性实现原理</a></label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_15\" disabled=\"true\"><label for=\"cbx_15\"> 消息可靠性实现原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_16\" disabled=\"true\"><label for=\"cbx_16\"> 负载均衡原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_17\" disabled=\"true\"><label for=\"cbx_17\"> 消息过滤原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_18\" disabled=\"true\"><label for=\"cbx_18\"> 消息重放原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_19\" disabled=\"true\"><label for=\"cbx_19\"> 延时消息实现原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_20\" disabled=\"true\"><label for=\"cbx_20\"> 消费者的 <code>Rebalance</code>  机制</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_21\" checked=\"true\" disabled=\"true\"><label for=\"cbx_21\"> <a href=\"/2022/07/09/rocketMQ/3-08-save-msg-detail/\">消息刷盘过程详解</a></label></li>\n</ul>\n<h3 id=\"宗师\"><a class=\"markdownIt-Anchor\" href=\"#宗师\">#</a> 宗师</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_22\" disabled=\"true\"><label for=\"cbx_22\"> 容灾</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_23\" disabled=\"true\"><label for=\"cbx_23\"> 运维工具 <code>mqadmin</code>  的使用</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_24\" disabled=\"true\"><label for=\"cbx_24\"> 最佳实践（ <code>Best Practice</code> ）</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_25\" disabled=\"true\"><label for=\"cbx_25\"> 如何处理消息丢失保证消息的可靠性</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_26\" disabled=\"true\"><label for=\"cbx_26\"> 如何避免消息重复消费</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_27\" disabled=\"true\"><label for=\"cbx_27\"> 如何实现事务消息，保证数据一致性</label></li>\n</ul>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/rocketmq/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "RocketMQ",
                "消息队列"
            ]
        }
    ]
}