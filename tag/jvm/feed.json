{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"jvm\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/",
            "title": "JVM之你没见过的OOM",
            "date_published": "2021-08-19T09:13:55.000Z",
            "content_html": "<p>一文搞懂内存溢出，保内存平安，防止你被祭天:[手动滑稽]:</p>\n<h2 id=\"释义\"><a class=\"markdownIt-Anchor\" href=\"#释义\">#</a> 释义</h2>\n<p><code>OOM</code>  的含义，到底是什么意思？<br>\n 是 JVM 独有的吗？  <code>linux</code>  是否也会存在，那又是怎么肥事？</p>\n<p><code>OOM</code>  :  <code>Out Of Memory</code>  .  内存溢出。内存溢出来了，也就是说内存不够用了，就会发生这个问题了。</p>\n<h3 id=\"内存又是什么呢\"><a class=\"markdownIt-Anchor\" href=\"#内存又是什么呢\">#</a> 内存又是什么呢？</h3>\n<p>1、 内存 是计算机的重要部件之一。它用于暂时存放 CPU 中的运算数据，与硬盘等外部存储交换数据。是外存与 <code>CPU</code>  进行沟通的桥梁。</p>\n<p>2、 <code>Java</code>  内存。说到这里我们就不得说一下 java 的内存模型 (JMM) 了。如下图。</p>\n<p><img data-src=\"/images/java/jvm/JMM.png\" alt=\"JMM\"></p>\n<p>就这个一个图就很不下几十个面试考点：比如 <code>votitle</code>  关键字，内存栅栏，指令重排，5 项 <code>Happen-Before</code>  原则，内存原子操作，数据 <code>IO</code>  操作等等。</p>\n<p>闲话少扯，抛个问题， <code>OOM</code>  发生区域会上图中那个部分发生呢？</p>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p><code>java</code>  运行时内存区域  <code>JAVA RUNTIME MEMEORY AREA</code> , 注意区分 <code>JMM</code> .</p>\n<p>大家都知道的， <code>java</code>  运行时内存区域，分为程序计数器 (PC 寄存器)，java 虚拟机栈，本地方法栈，堆，方法区，运行时常量池，堆外内存 (直接内存)</p>\n<p>1、程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为 <code>Undefined</code> 。</p>\n<p>2、 <code>Java</code>  虚拟机栈是描述  <code>Java</code>  方法运行过程的内存模型。 <code>Java</code>  虚拟机栈会为每一个即将运行的  <code>Java</code>  方法创建一块叫做 “栈帧” 的区域，用于存放该方法运行过程中的一些信息，比如：局部变量表，操作数栈，动态链接，方法出口信息等，方法执行的过程即为栈帧压栈出栈的过程。</p>\n<p>3、本地方法栈是为  <code>JVM</code>  运行  <code>Native</code>  方法准备的空间，由于很多  <code>Native</code>  方法都是用  <code>C</code>  语言实现的，所以它通常又叫  <code>C</code>  栈。它与  <code>Java</code>  虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>\n<p>4、堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。这一区域是线程共享，整个  <code>Java</code>  虚拟机只有一个堆，所有的线程都访问同一个堆。堆又可划分为年轻代和老年代，年轻代内存又可以分为 <code>Eden</code> ,  <code>from Surivor</code> , <code>to Surivor</code> , 并且默认以 8:1:1 的比例进行分配。</p>\n<p>5、方法区： <code>Java</code>  虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：已经被虚拟机加载的类信息，常亮，静态变量，即时编译编译器编译后的代码。线程共享的区域。为了与堆区分，方法还有一个别名： <code>Non-Heap</code>  (非堆)。</p>\n<p>5.1 、运行时常量池：存放常量的区域。 在运行期间，可以向常量池中添加新的变量，如  <code>String</code>  类的 <code>intern()</code>  方法。</p>\n<p>6、堆外内存是 <code>java</code>  虚拟机之外的内容，但也可能被 <code>java</code>  使用。需要注意的是，这部分内容也会因内存不足而抛出  <code>OutOfMemoryError</code> 、</p>\n<p>知道了 <code>Java</code>  运行内存区域，那么可能发生  <code>OOM</code>  的区域有哪些呢？</p>\n<p>我们都知道 <code>OOM</code>  只的是内存溢出，所以 堆，非堆即方法区，本地方法栈，以及堆外内存 都是会发生  <code>OOM</code>  的。</p>\n<p>那 <code>java</code>  虚拟机栈呢？不会发生内容溢出吗？   会！但是 栈发生内容溢出的时候，报的错误是  <code>StackOverflowError</code> .</p>\n<p>那程序计数器呢？  程序计数器，是不会发送内容溢出的。 因为 存储的是：当前线程正在执行的那条字节码指令的地址啊。</p>\n<p>如下图：</p>\n<p><img data-src=\"/images/java/jvm/OOM%E5%8C%BA%E5%9F%9F%E5%9B%BE.png\" alt=\"OOM区域图\"></p>\n<p>在上图中还指定了各区域大小的参数配置：</p>\n<ul>\n<li>\n<p><code>-Xms</code>  设置堆的最小空间大小。</p>\n</li>\n<li>\n<p><code>-Xmx</code>  设置堆的最大空间大小。</p>\n</li>\n<li>\n<p><code>-XX:NewSize</code>  设置新生代最小空间大小。</p>\n</li>\n<li>\n<p><code>-XX:MaxNewSize</code>  设置新生代最大空间大小。</p>\n</li>\n<li>\n<p><code>-XX:PermSize</code>  设置永久代最小空间大小。</p>\n</li>\n<li>\n<p><code>-XX:MaxPermSize</code>  设置永久代最大空间大小。</p>\n</li>\n<li>\n<p><code>-Xss</code>  设置每个线程的堆栈大小。</p>\n</li>\n</ul>\n<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。  <code>老年代空间大小=堆空间大小-年轻代大空间大小</code></p>\n<h2 id=\"场景分析\"><a class=\"markdownIt-Anchor\" href=\"#场景分析\">#</a> 场景分析</h2>\n<p>我们挨个分析下发生 <code>OOM</code>  的 9 种场景</p>\n<p>什么时候会发生 <code>OOM</code>  呢？  当内存严重不够用的时候就会发生   <code>java.lang.OutOfMemoryError</code>  。</p>\n<p>我们来看下每个区域都有可能出现内存溢出问题.</p>\n<h3 id=\"javaheap-space\"><a class=\"markdownIt-Anchor\" href=\"#javaheap-space\">#</a>  <code>JavaHeap space</code></h3>\n<p>当堆内存（ <code>Heap Space</code> ）没有足够空间存放新创建的对象时，就会抛出  <code>java.lang.OutOfMemoryError:Javaheap space</code>  错误。</p>\n<p><code>Javaheap space</code>  错误产生的常见原因可以分为以下几类：</p>\n<p>1. 请求创建一个超大对象，通常是一个大数组。<br>\n2. 超出预期的访问量 / 数据量，通常是上游系统请求流量飙升，常见于各类促销 / 秒杀活动，可以结合业务流量指标排查是否有尖状峰值。<br>\n3. 过度使用终结器（ <code>Finalizer</code> ），该对象没有立即被  <code>GC</code> 。<br>\n4. 内存泄漏（ <code>Memory Leak</code> ），大量对象引用没有释放， <code>JVM</code>  无法对其自动回收，常见于使用了  <code>File</code>  等资源没有回收。</p>\n<h4 id=\"解决方案\"><a class=\"markdownIt-Anchor\" href=\"#解决方案\">#</a> 解决方案</h4>\n<p>针对大部分情况，通常只需要通过  <code>-Xmx</code>  参数调高  <code>JVM</code>  堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p>\n<p>1、如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。<br>\n2、如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。<br>\n3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</p>\n<h4 id=\"代码案例\"><a class=\"markdownIt-Anchor\" href=\"#代码案例\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示大对象</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bigObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 21 可以，22就会OOM</span></span><br><span class=\"line\">    <span class=\"comment\">// 4* 1024 * 1024 = 4M * 32 = 128M</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] integers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/heapSpaceError.png\" alt=\"\"></p>\n<h3 id=\"gc-overhead-limit-exceeded\"><a class=\"markdownIt-Anchor\" href=\"#gc-overhead-limit-exceeded\">#</a>  <code>GC overhead limit exceeded</code></h3>\n<p>当  <code>Java</code>  进程花费  <code>98%</code>  以上的时间执行  <code>GC</code> ，但只恢复了不到  <code>2%</code>  的内存，且该动作连续重复了  <code>5</code>  次，就会抛出  <code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>  错误。简单地说，就是应用程序已经基本耗尽了所有可用内存，  <code>GC</code>  也无法回收。</p>\n<h4 id=\"解决方案-2\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-2\">#</a> 解决方案</h4>\n<p>同  <code>JavaHeap space</code>  部分的异常解决方案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示 频繁GC</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">overHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        map.put(r.nextInt(), <span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:<br>\n<img data-src=\"/images/java/jvm/gcOverHead.png\" alt=\"\"></p>\n<h3 id=\"permgen-spacejdk8-已废弃-see-元空间\"><a class=\"markdownIt-Anchor\" href=\"#permgen-spacejdk8-已废弃-see-元空间\">#</a>  <code>Permgen space</code> ( <code>JDK8</code>  已废弃， <code>see</code>  元空间。)</h3>\n<div class=\"note info\">\n<p>为什么会废弃 永久代？     <code>see</code> ： <span class=\"exturl\" data-url=\"aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8xMjI=\">http://openjdk.java.net/jeps/122</span></p>\n</div>\n<p>该错误表示永久代（ <code>Permanent Generation</code> ）已用满，通常是因为加载的  <code>class</code>  数目太多或体积太大。</p>\n<p>永久代存储对象主要包括以下几类：</p>\n<p>加载 / 缓存到内存中的  <code>class</code>  定义，包括类的名称，字段，方法和字节码；<br>\n常量池；<br>\n对象数组 / 类型数组所关联的  <code>class</code> ；<br>\n <code>JIT</code>  编译器优化后的  <code>class</code>  信息。<br>\n <code>PermGen</code>  的使用量与加载到内存的  <code>class</code>  的数量 / 大小正相关。</p>\n<h4 id=\"解决方案-3\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-3\">#</a> 解决方案</h4>\n<p>根据  <code>Permgen space</code>  报错的时机，可以采用不同的解决方案，如下所示：</p>\n<ul>\n<li>程序启动报错，修改  <code>-XX:MaxPermSize</code>  启动参数，调大永久代空间。</li>\n<li>应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份  <code>class</code>  信息，只需重启 JVM 即可解决。</li>\n<li>运行时报错，应用程序可能会动态创建大量  <code>class</code> ，而这些  <code>class</code>  的生命周期很短暂，但是 JVM 默认不会卸载  <code>class</code> ，可以设置  <code>-XX:+CMSClassUnloadingEnabled</code>  和  <code>-XX:+UseConcMarkSweepGC</code>  这两个参数允许  <code>JVM</code>  卸载  <code>class</code> 。</li>\n<li>如果上述方法无法解决，可以通过  <code>jmap</code>  命令  <code>dump</code>  内存对象  <code>jmap-dump:format=b,file=dump.hprof</code>  ，然后利用  <code>Eclipse MAT https://www.eclipse.org/mat</code>  功能逐一分析开销最大的  <code>classloader</code>  和重复  <code>class</code> 。</li>\n</ul>\n<h3 id=\"metaspace\"><a class=\"markdownIt-Anchor\" href=\"#metaspace\">#</a>  <code>Metaspace</code></h3>\n<p><code>JDK 1.8</code>  使用  <code>Metaspace</code>  替换了永久代（ <code>Permanent Generation</code> ）</p>\n<p>该错误表示  <code>Metaspace</code>  已被用满，通常是因为加载的  <code>class</code>  数目太多或体积太大。</p>\n<p>此类问题的原因与解决方法跟  <code>PermGenspace</code>  非常类似，可以参考上文。</p>\n<p>需要特别注意的是调整  <code>Metaspace</code>  空间大小的启动参数为  <code>-XX:MaxMetaspaceSize</code> 。</p>\n<h4 id=\"代码案例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-2\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示  元数据区</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 在 `for` 循环中, 动态生成很多class, 最终将这些class加载到 Metaspace 中</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意配置: -XX:MaxMetaspaceSize=64m</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">metaSpace</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ; i++) &#123;</span><br><span class=\"line\">        Class c = cp.makeClass(<span class=\"string\">&quot;eu.plumbr.demo.Generated&quot;</span> + i).toClass();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:</p>\n<p><img data-src=\"/images/java/jvm/metaSpace.png\" alt=\"\"></p>\n<h3 id=\"unable-to-create-new-native-thread\"><a class=\"markdownIt-Anchor\" href=\"#unable-to-create-new-native-thread\">#</a>  <code>Unable to create new native thread</code></h3>\n<p>每个  <code>Java</code>  线程都需要占用一定的内存空间，当  <code>JVM</code>  向底层操作系统请求创建一个新的  <code>native</code>  线程时，如果没有足够的资源分配就会报此类错误。</p>\n<h4 id=\"原因分析\"><a class=\"markdownIt-Anchor\" href=\"#原因分析\">#</a> 原因分析</h4>\n<p><code>JVM</code>  向  <code>OS</code>  请求创建  <code>native</code>  线程失败，就会抛出  <code>Unable to create new native thread</code> ，常见的原因包括以下几类：</p>\n<p>线程数超过操作系统最大线程数  <code>ulimit</code>  限制；<br>\n线程数超过  <code>kernel.pid_max</code> （只能重启）；<br>\n <code>native</code>  内存不足；</p>\n<p>该问题发生的常见过程主要包括以下几步：</p>\n<p><code>JVM</code>  内部的应用程序请求创建一个新的  <code>Java</code>  线程；<br>\n <code>JVM native</code>  方法代理了该次请求，并向操作系统请求创建一个  <code>native</code>  线程；<br>\n操作系统尝试创建一个新的  <code>native</code>  线程，并为其分配内存；<br>\n如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次  <code>native</code>  内存分配；<br>\n <code>JVM</code>  将抛出  <code>java.lang.OutOfMemoryError:Unableto createnewnativethread</code>  错误。</p>\n<h4 id=\"解决方案-4\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-4\">#</a> 解决方案</h4>\n<ul>\n<li>升级配置，为机器提供更多的内存；</li>\n<li>降低  <code>Java Heap Space</code>  大小；</li>\n<li>修复应用程序的线程泄漏问题；</li>\n<li>限制线程池大小；</li>\n<li>使用  <code>-Xss</code>  参数减少线程栈的大小；</li>\n<li>调高  <code>OS</code>  层面的线程最大数：执行  <code>ulimit -a</code>  查看最大线程数限制，使用  <code>ulimit -u xxx</code>  调整最大线程数限制。</li>\n</ul>\n<h4 id=\"代码案例-3\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-3\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示: Unable to create new native thread</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">nativeThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:</p>\n<p><img data-src=\"/images/java/jvm/unableCreateNative.png\" alt=\"\"></p>\n<h3 id=\"out-of-swap-space\"><a class=\"markdownIt-Anchor\" href=\"#out-of-swap-space\">#</a>  <code>Out of swap space</code></h3>\n<p>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（ <code>Virtual Memory</code> ）由物理内存（ <code>Physical Memory</code> ）和交换空间（ <code>Swap Space</code> ）两部分组成。当运行时程序请求的虚拟内存溢出时就会报  <code>Outof swap space</code>  错误。</p>\n<p>这个错误通常是操作系统层面的原因。</p>\n<h4 id=\"原因分析-2\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-2\">#</a> 原因分析</h4>\n<p>该错误出现的常见原因包括以下几类：</p>\n<ul>\n<li>\n<ol>\n<li>地址空间不足；</li>\n</ol>\n</li>\n<li>2. 物理内存已耗光；</li>\n<li>3. 应用程序的本地内存泄漏（ <code>native leak</code> ），例如不断申请本地内存，却不释放。</li>\n<li>4. 执行  <code>jmap-histo:live</code>  命令，强制执行  <code>Full GC</code> ；如果几次执行后内存明显下降，则基本确认为  <code>Direct ByteBuffer</code>  问题。</li>\n</ul>\n<h4 id=\"解决方案-5\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-5\">#</a> 解决方案</h4>\n<p>根据错误原因可以采取如下解决方案：</p>\n<ul>\n<li>\n<ol>\n<li>升级地址空间为  <code>64 bit</code> ；</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>使用  <code>Arthas</code>  检查是否为  <code>Inflater/Deflater</code>  解压缩问题，如果是，则显式调用  <code>end</code>  方法。</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><code>Direct ByteBuffer</code>  问题可以通过启动参数  <code>-XX:MaxDirectMemorySize</code>  调低阈值。</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>升级服务器配置 / 隔离部署，避免争用。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"kill-process-or-sacrifice-child\"><a class=\"markdownIt-Anchor\" href=\"#kill-process-or-sacrifice-child\">#</a>  <code>Kill process or sacrifice child</code></h3>\n<p>有一种内核作业（ <code>Kernel Job</code> ）名为  <code>Out of Memory Killer</code> ，它会在可用内存极低的情况下 “杀死”（ <code>kill</code> ）某些进程。 <code>OOM Killer</code>  会对所有进程进行打分，然后将评分较低的进程 “杀死”，具体的评分规则可以参考  <code>Surviving the Linux OOM Killer</code> 。</p>\n<p>不同于其他的  <code>OOM</code>  错误，  <code>Killprocessorsacrifice child</code>  错误不是由  <code>JVM</code>  层面触发的，而是由操作系统层面触发的。</p>\n<h4 id=\"原因分析-3\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-3\">#</a> 原因分析</h4>\n<p>默认情况下， <code>Linux</code>  内核允许进程申请的内存总量大于系统可用内存，通过这种 “错峰复用” 的方式可以更有效的利用系统资源。</p>\n<p>然而，这种方式也会无可避免地带来一定的 “超卖” 风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活  <code>OOM Killer</code> ，寻找评分低的进程，并将其 “杀死”，释放内存资源。</p>\n<h4 id=\"解决方案-6\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-6\">#</a> 解决方案</h4>\n<ul>\n<li>升级服务器配置 / 隔离部署，避免争用。</li>\n<li><code>OOM Killer</code>  调优。</li>\n</ul>\n<h4 id=\"代码案例-4\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-4\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示:Kill process or sacrifice child</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    java.util.List&lt;<span class=\"keyword\">int</span>[]&gt; l = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">10000</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            l.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">100000000</span>]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/killprocess.png\" alt=\"\"></p>\n<h3 id=\"requested-array-size-exceeds-vm-limit\"><a class=\"markdownIt-Anchor\" href=\"#requested-array-size-exceeds-vm-limit\">#</a>  <code>Requested array size exceeds VM limit</code></h3>\n<p>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。</p>\n<p>JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为  <code>Integer.MAX_VALUE-2</code> 。</p>\n<p>此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[Integer.MAX_VALUE-i];</span><br><span class=\"line\">            System.out.format(<span class=\"string\">&quot;Successfully initialized an array with %,d elements.\\n&quot;</span>, Integer.MAX_VALUE-i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容</p>\n<p><img data-src=\"/images/java/jvm/requestArraySize.png\" alt=\"\"></p>\n<h3 id=\"direct-buffer-memory\"><a class=\"markdownIt-Anchor\" href=\"#direct-buffer-memory\">#</a>  <code>Direct buffer memory</code></h3>\n<p><code>java</code>  允许应用程序通过  <code>Direct ByteBuffer</code>  直接访问堆外内存，许多高性能程序通过  <code>Direct ByteBuffer</code>  结合内存映射文件（ <code>Memory Mapped File</code> ）实现高速  <code>IO</code> 。</p>\n<h4 id=\"原因分析-4\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-4\">#</a> 原因分析</h4>\n<p><code>Direct ByteBuffer</code>  的默认大小为  <code>64 MB</code> ，一旦使用超出限制，就会抛出  <code>Directbuffer memory</code>  错误。</p>\n<h4 id=\"解决方案-7\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-7\">#</a> 解决方案</h4>\n<ul>\n<li><code>Java</code>  只能通过  <code>ByteBuffer</code> . <code>allocateDirect</code>  方法使用  <code>Direct ByteBuffer</code> ，因此，可以通过  <code>Arthas</code>  等在线诊断工具拦截该方法进行排查。</li>\n<li>检查是否直接或间接使用了  <code>NIO</code> ，如  <code>netty</code> ， <code>jetty</code>  等。</li>\n<li>通过启动参数  <code>-XX:MaxDirectMemorySize</code>  调整  <code>Direct ByteBuffer</code>  的上限值。</li>\n<li>检查  <code>JVM</code>  参数是否有  <code>-XX:+DisableExplicitGC</code>  选项，如果有就去掉，因为该参数会使  <code>System.gc()</code>  失效。</li>\n<li>检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用  <code>sun.misc.Cleaner</code>  的  <code>clean()</code>  方法来主动释放被  <code>Direct ByteBuffer</code>  持有的内存空间。</li>\n<li>内存容量确实不足，升级配置。</li>\n</ul>\n<h4 id=\"代码案例-5\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-5\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示对外内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;maxDirectMemory : &quot;</span> + (sun.misc.VM.maxDirectMemory() / (<span class=\"keyword\">double</span>) (<span class=\"number\">1024</span> * <span class=\"number\">1024</span>)) + <span class=\"string\">&quot;MB&quot;</span>);</span><br><span class=\"line\">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class=\"number\">6</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\">    System.out.println(byteBuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/directBuffer.png\" alt=\"\"></p>\n<h2 id=\"排查思路\"><a class=\"markdownIt-Anchor\" href=\"#排查思路\">#</a> 排查思路</h2>\n<p>分享遇到 <code>OOM</code>  类问题如何快速定位问题，具体哪行代码发生了问题</p>\n<p>什么表现会发生 <code>OOM</code>  呢？</p>\n<p>最直接的～，有报错， <code>outOfMemoryError</code> 。 就是发生了。<br>\n有频繁 <code>GC</code>  的事件发生的时候，也要注意下，可能是在  <code>OOM</code>  的边缘疯狂试探。 比如  <code>FullGC</code> ，  <code>Young GC</code> , 等。<br>\n <code>CPU</code>  占用率较高。<br>\n先说一个思路哈～</p>\n<h3 id=\"止损\"><a class=\"markdownIt-Anchor\" href=\"#止损\">#</a> 止损。</h3>\n<p>如果你在线上遇到了这个问题， 请，务必！ 先将服务重启！立刻，马上。 及时止损。  <code>ps</code> : 可以留一台机器做案发现场，记得下掉该机器，不对外提供服务。</p>\n<h3 id=\"问题排查\"><a class=\"markdownIt-Anchor\" href=\"#问题排查\">#</a> 问题排查</h3>\n<p>注意观察线上服务情况，如果再次出现 <code>OOM</code> , 影响业务，再问题没有解决完成之前，还是采用重启的方式解决。<br>\n可以通过  <code>glowroot</code>  等可视化的监控工具，观察。<br>\n也可以通过在机器上 使用   <code>jstat -gc pid</code>  来查看 <code>GC</code>  情况。<br>\n分析造成 <code>OOM</code>  的问题。(具体如何排查，可参考案例模块)</p>\n<p>查到对应 <code>JVM</code>  进程 =&gt;  排查到占用内存打的 <code>jvm</code>  线程 =&gt; 查看对应线程栈信息 =&gt; 使用 <code>Jmap</code>  来生成线程堆栈信息文件 =&gt; 分析大对象 <code>or</code>  占用内存大的原因 =&gt;  基本上改代码或者 <code>jvm</code>  配置。</p>\n<p>其他排查问题思路和这个也是大差不差，使用的命令不同而已。</p>\n<h3 id=\"案例\"><a class=\"markdownIt-Anchor\" href=\"#案例\">#</a> 案例</h3>\n<details class=\"warning\"><summary>举个栗子🌰吧</summary><div>\n<p>比较常见的应该是：  <code>java.lang. outOfMemoryError: Java heap Space</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示OOM 排查过程</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSpaceError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; bigObject());</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示大对象</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bigObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 21 可以，22就会OOM</span></span><br><span class=\"line\">    <span class=\"comment\">// 4* 1024 * 1024 = 4M * 32 = 128M</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] integers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">22</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后发现控制台打印出了 <code>OOM</code>  :  <code>java heap space</code> .  好吧，就装作看不见吧</p>\n<p>1、使用  <code>jps</code>  命令获取到  <code>jvm</code>  进程号</p>\n<p><img data-src=\"/images/java/jvm/oom%E6%A1%88%E4%BE%8Bjps.png\" alt=\"\"></p>\n<p>2、使用  <code>jmap</code>  命令 <code>dump</code>  出 堆栈信息。<br>\n<img data-src=\"/images/java/jvm/jdump.png\" alt=\"\"></p>\n<p>3、使用  <code>mat</code>  工具，分析 <code>dump</code>  文件内容。  (下载地址:  <code>https://www.eclipse.org/mat/downloads.php</code>    下载是真特🐴的慢啊，<span class=\"label success\">❤️一般人我不告诉他：公众号回复 <code>MAT</code>  就能直接获取</span>)</p>\n<blockquote>\n<p>如果下载之后无法启动的话，提示 无法创建虚拟机。需要简单配置下：<br>\n <code>-vm /Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/bin</code></p>\n</blockquote>\n<p>3.1、下载下 <code>dump</code>  文件，使用本地分析 <code>mat</code>  工具进行分析。</p>\n<p>启动 <code>mat</code> .<br>\n<img data-src=\"/images/java/jvm/mat.png\" alt=\"\"></p>\n<p><code>Open a  heap Dump</code>  之后，就可以愉快的分析了。</p>\n<p>具体分析方法请自行百度吧。</p>\n<p>3.2、如果 <code>dump</code>  文件较小，也可以 <code>java</code>  自带的工具 jhat 命令进行分析。<br>\n<img data-src=\"/images/java/jvm/jmap.png\" alt=\"\"></p>\n<p>然后访问本机的  <code>7000</code>  端口，就可以到看到分析的内容了。<br>\n<img data-src=\"/images/java/jvm/image2021-4-15_19-8-56.png\" alt=\"\"><br>\n进入之后，就可以看到堆内存占用情况的柱状图了。<br>\n<img data-src=\"/images/java/jvm/heapHistogram.png\" alt=\"\"><br>\n发现有  <code>Class[I</code>  占用最多，     <code>Class[I</code>  表示的是  <code>int</code>  数组。 那我们就查下代码里用到 <code>Class[I</code>  中的地方，</p>\n<p>哇，果然是在  <code>new</code>  了一个大的数据，撑爆了内存。</p>\n<p>补充下：</p>\n<p>先查看 jvm 进程号 <br>\n <code> jps </code>   注意：只能查看属于当前用户 <code>java</code>  进程<br>\n  <code>ps -ef| grep java</code>  找到对应服务的进程编号<br>\n <code>ps -ef| grep 服务名</code></p>\n<p>如下图:<br>\n<img data-src=\"/images/java/jvm/%E8%A1%A5%E5%85%85.png\" alt=\"\"><br>\n 需要注意下:</p>\n<p>1) 查看当前应用运行情况信息，查看是否配置了 <code>gc log：-Xloggc:/apps/srv/instance/damai.gaotu100.com/logs/damai.gaotu100.com-gc.log</code>   , 可以从 <code>gc</code>  日志中查到很多信息。</p>\n<p>2）查看是否有 <code>oom</code>  自动打印二进制 <code>dump</code>  文件：  <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/apps/srv/instance/damai.gaotu100.com/logs/heapdump.hprof</code>   。</p>\n<blockquote>\n<p>如果没有配置，可以通过命令自行打印:   <code>jmap -dump:format=b,file=/apps/srv/instance/test-kefu-web.baijiahulian.com/logs/22316.1.hprof pid</code></p>\n</blockquote>\n<p>这里推荐下，阿里开源的 jvm 排查工具  arthas（阿尔萨斯）  <code>https://arthas.aliyun.com/doc/</code> 。文档很全，需要的自行阅读吧～～</p>\n</div></details>\n<h2 id=\"解决方案-8\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-8\">#</a> 解决方案</h2>\n<p>分享遇到 <code>OOM</code>  问题时怎样解决？</p>\n<blockquote>\n<p>长兄于病视神，未有形而除之，故名不出于家。中兄治病，其在毫毛，故名不出于闾。若扁鹊者，镵血脉，投毒药，副肌肤，闲而名出闻于诸侯。 所以才有凡此者不病病，治之无名，使之无形，至功之成，其下谓之自然。<br>\n这句话，用在我们这里就是  系统的整个生命周期中，不出现任何 <code>OOM</code> , 其 谓之自然。</p>\n</blockquote>\n<p>根据上述的排查过程，找到了问题根源之后，那就<br>\n 1. 改代码<br>\n 2. 调整内存配置</p>\n<p>大刀阔斧的干吧！</p>\n<div class=\"note success no-icon\">\n<p>大家有什么建议呢？</p>\n</div>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>我们看待 <code>OOM</code>  应该从全面来看，有可能是  <code>jvm</code>  内存确实盛不下要分配的对象，也有可能是 频繁 <code>GC</code> ，且收效甚低导致的，还有可能是宿主机上内存不够杀死 <code>jvm</code>  导致的，加载的类过大过多造成的，虚拟内存不够用等等。最后也不要忽略 堆外内存的内存溢出。</p>\n<p>线上遇到这类问题，第一要及时止损，方式很简单，重启就能解决。   保证线上可用之后，再去查问题，根治问题。  同时不用忘了监控线上服务是否有内存要溢出的情况，及时重启，为处理 <code>OOM</code>  问题争取时间。</p>\n<p>排查问题时，首先找到对应 <code>jvm</code>  进程，然后使用 <code>jmap</code>  打印出 内存映射文件，然后使用 <code>jhat</code>  或者  <code>mat</code>  工具进行分析，定位原因。解决问题。</p>\n<p>最后，我们在 <code>coding</code>  的时候，要注意下，不要编写导致 <code>OOM</code>  代码。“未有形而除之～”</p>\n<h2 id=\"抛个问题~\"><a class=\"markdownIt-Anchor\" href=\"#抛个问题~\">#</a> 抛个问题～</h2>\n<p>发生 OOM，程序会退出吗？</p>\n<blockquote>\n<p>下期见</p>\n</blockquote>\n<h4 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h4>\n<p>希望和你一起遇见更好的自己<br>\n<img data-src=\"/images/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "OOM",
                "JVM",
                "Java"
            ]
        }
    ]
}