{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"log\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2022/02/24/mylogs/talk_about_log/",
            "url": "https://fangjiaxiaobai.github.io/2022/02/24/mylogs/talk_about_log/",
            "title": "聊聊日志",
            "date_published": "2022-02-24T10:18:18.000Z",
            "content_html": "<p><code>https://github.com/golang/glog</code> ，是  <code>google</code>  提供的一个不维护的日志库， <code>glog</code>  有其他语言的一些版本，对我当时使用  <code>log</code>  库有很大的影响。它包含如下日志级别：  <code>Info</code> ,  <code>Warning</code> ,  <code>Error</code> ,  <code>Fatal</code>  (会中断程序执行)<br>\n 还有类似  <code>log4go</code> ,  <code>loggo</code>  , <code>zap</code>  等其他第三方日志库，他们还提供了设置日志级别的可见行，一般提供日志级别：  <code>Trace</code>  ,  <code>Debug</code>  ,  <code>Info</code>  ,  <code>Warning</code>  ,  <code>Error</code>  ,  <code>Critical</code> .</p>\n<h2 id=\"日志级别\"><a class=\"markdownIt-Anchor\" href=\"#日志级别\">#</a> 日志级别</h2>\n<h3 id=\"warning\"><a class=\"markdownIt-Anchor\" href=\"#warning\">#</a> Warning</h3>\n<p>没人看警告，因为从定义上讲，没有什么出错。也许将来会出问题，但这听起来像是别人的问题。我们尽可能的消除警告级别，它要么是一条信息性消息，要么是一个错误。我们参考  <code>Go</code>  语言设计额哲学，所有警告都是错误，其他语言的  <code>warning</code>  都可以忽略，除非  <code>IDE</code>  或者在  <code>CICD</code>  流程中强制他们为  <code>error</code> ，然后逼着程序员们尽可能去消除。同样的，如果想要最终消除  <code>warning</code>  可以记录为  <code>error</code> ，让代码作者重视起来。</p>\n<h3 id=\"fatal\"><a class=\"markdownIt-Anchor\" href=\"#fatal\">#</a> Fatal</h3>\n<p>记录消息后，直接调用  <code>os.Exit(1)</code> ，这意味着： 在其他  <code>goroutine</code>   <code>defer</code>  语句不会被执行； 各种  <code>buffers</code>  不会被  <code>flush</code>  ，包括日志的； 临时文件或者目录不会被移除； 不要使用  <code>fatal</code>  记录日志，而是向调用者返回错误。如果错误一直持续到  <code>main.main</code> 。 <code>main.main</code>  那就是在退出之前做处理任何清理操作的正确位置。</p>\n<h3 id=\"error\"><a class=\"markdownIt-Anchor\" href=\"#error\">#</a> Error</h3>\n<p>也有很多人，在错误发生的地方要立马记录日志，尤其要使用  <code>error</code>  级别记录。</p>\n<p><img data-src=\"./images/12-log-01.png\" alt=\"\"></p>\n<h4 id=\"处理-error\"><a class=\"markdownIt-Anchor\" href=\"#处理-error\">#</a> 处理 error</h4>\n<p>把  <code>error</code>  抛给调用者，在顶部打印日志；<br>\n如果您选择通过日志记录来处理错误，那么根据定义，它不再是一个错误 — 您已经处理了它。记录错误的行为会处理错误，因此不再适合将其记录为错误。</p>\n<p><img data-src=\"./images/12-log-02.png\" alt=\"\"></p>\n<h3 id=\"debug\"><a class=\"markdownIt-Anchor\" href=\"#debug\">#</a> DEBUG</h3>\n<p>相信只有两件事你应该记录：</p>\n<ul>\n<li>开发人员在开发或调试软件时关心的事情。</li>\n<li>用户在使用软件时关心的事情。</li>\n</ul>\n<p>显然，它们分别是调试和信息级别。<br>\n <code>log.Info</code>  只需将该行写入日志输出。不应该有关闭它的选项，因为用户只应该被告知对他们有用的事情。如果发生了一个无法处理的错误，它就会抛出到  <code>main.main</code> 。 <code>main.main</code>  程序终止的地方。在最后的日志消息前面插入  <code>fatal</code>  前缀，或者直接写入  <code>os.Stderr</code> 。<br>\n <code>log.Debug</code> ，是完全不同的事情。它由开发人员或支持工程师控制。在开发过程中，调试语句应该是丰富的，而不必求助于  <code>trace</code>  或  <code>debug2</code> （您知道自己是谁）级别。日志包应该支持细粒度控制，以启用或禁用调试，并且只在包或更精细的范围内启用或禁用调试语句。</p>\n<p>B 站的 go 框架是如何设计和思考的：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dvLWtyYXRvcy9rcmF0b3MvdHJlZS92Mi4wLngvbG9n\">https://github.com/go-kratos/kratos/tree/v2.0.x/log</span></p>\n<h2 id=\"日志选型\"><a class=\"markdownIt-Anchor\" href=\"#日志选型\">#</a> 日志选型</h2>\n<p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p>\n<ul>\n<li>收集－能够采集多种来源的日志数据；</li>\n<li>传输－能够稳定的把日志数据传输到中央系统；</li>\n<li>存储－如何存储日志数据；</li>\n<li>分析－可以支持  <code>UI</code>  分析；</li>\n<li>警告－能够提供错误报告，监控机制；</li>\n</ul>\n<p>开源界鼎鼎大名  <code>ELK stack</code> ，分别表示： <code>Elasticsearch</code>  ,  <code>Logstash</code> ,  <code>Kibana</code>  , 它们都是开源软件。新增了一个  <code>FileBeat</code> ，它是一个轻量级的日志收集处理工具 ( <code>Agent</code> )， <code>Filebeat</code>  占用资源少，适合于在各个服务器上搜集日志后传输给  <code>Logstash</code> ，官方也推荐此工具。</p>\n<h3 id=\"elk\"><a class=\"markdownIt-Anchor\" href=\"#elk\">#</a> ELK</h3>\n<p>此架构由  <code>Logstash</code>  分布于各个节点上搜集相关日志、数据，并经过分析、过滤后发送给远端服务器上的  <code>Elasticsearch</code>  进行存储。<br>\n <code>Elasticsearch</code>  将数据以分片的形式压缩存储并提供多种  <code>API</code>  供用户查询，操作。用户亦可以更直观的通过配置  <code>Kibana Web</code>  方便的对日志查询，并根据数据生成报表。<br>\n因为  <code>logstash</code>  属于  <code>server</code>  角色，必然出现流量集中式的热点问题，因此我们不建议使用这种部署方式，同时因为 还需要做大量  <code>match</code>  操作（格式化日志），消耗的  <code>CPU</code>  也很多，不利于  <code>scale out</code> 。</p>\n<p><img data-src=\"./images/12-log-03.png\" alt=\"\"></p>\n<p><img data-src=\"./images/12-log-04.png\" alt=\"\"></p>\n<p>此种架构引入了消息队列机制，位于各个节点上的  <code>Logstash Agent</code>  先将数据 / 日志传递给  <code>Kafka</code> ，并将队列中消息或数据间接传递给  <code>Logstash</code> ， <code>Logstash</code>  过滤、分析后将数据传递给 <code>Elasticsearch</code>  存储。最后由  <code>Kibana</code>  将日志和数据呈现给用户。因为引入了  <code>Kafka</code> ，所以即使远端  <code>Logstash server</code>  因故障停止运行，数据将会先被存储下来，从而避免数据丢失。<br>\n更进一步的：  将收集端  <code>logstash</code>  替换为  <code>beats</code> , 更灵活，消耗资源更少，扩展性更强。</p>\n<p><img data-src=\"./images/12-log-05.png\" alt=\"\"></p>\n<h2 id=\"日志系统的设计目标\"><a class=\"markdownIt-Anchor\" href=\"#日志系统的设计目标\">#</a> 日志系统的设计目标</h2>\n<ul>\n<li>接入方式收敛；</li>\n<li>日志格式规范；</li>\n<li>日志解析对日志系统透明；</li>\n<li>系统高吞吐、低延迟；</li>\n<li>系统高可用、容量可扩展、高可运维性；</li>\n</ul>\n<h2 id=\"日志系统的格式规范\"><a class=\"markdownIt-Anchor\" href=\"#日志系统的格式规范\">#</a> 日志系统的格式规范</h2>\n<p><code>JSON</code>  作为日志的输出格式：<br>\n <code>time</code> : 日志产生时间， <code>ISO8601</code>  格式；<br>\n <code>level</code> : 日志等级， <code>ERROR</code> 、 <code>WARN</code> 、 <code>INFO</code> 、 <code>DEBUG</code> ；<br>\n <code>app_id</code> : 应用 <code>id</code> ，用于标示日志来源；<br>\n <code>instance_id</code> : 实例  <code>id</code> ，用于区分同一应用不同实例，即  <code>hostname</code> ；</p>\n<p><img data-src=\"./images/12-log-06.png\" alt=\"\"></p>\n<h2 id=\"日志系统的设计与实现\"><a class=\"markdownIt-Anchor\" href=\"#日志系统的设计与实现\">#</a> 日志系统的设计与实现</h2>\n<p>日志从产生到可检索，经历几个阶段：</p>\n<ul>\n<li><b>生产 &amp; 采集</b></li>\n<li><b>传输 &amp; 切分</b></li>\n<li><b>存储 &amp; 检索</b></li>\n</ul>\n<h3 id=\"采集\"><a class=\"markdownIt-Anchor\" href=\"#采集\">#</a> 采集</h3>\n<p><img data-src=\"./images/12-log-07.png\" alt=\"\"></p>\n<h4 id=\"logstash\"><a class=\"markdownIt-Anchor\" href=\"#logstash\">#</a>  <code>logstash</code> ：</h4>\n<p>监听  <code>tcp/udp</code> <br>\n 适用于通过网络上报日志的方式</p>\n<h4 id=\"filebeat\"><a class=\"markdownIt-Anchor\" href=\"#filebeat\">#</a>  <code>filebeat</code> ：</h4>\n<p>直接采集本地生成的日志文件<br>\n适用于日志无法定制化输出的应用</p>\n<h4 id=\"logagent\"><a class=\"markdownIt-Anchor\" href=\"#logagent\">#</a>  <code>logagent</code> ：</h4>\n<p>物理机部署，监听  <code>unixsocket</code> <br>\n 日志系统提供各种语言  <code>SDK</code> <br>\n 直接读取本地日志文件</p>\n<p><img data-src=\"./images/12-log-08.png\" alt=\"logagent的设计\"></p>\n<h3 id=\"传输\"><a class=\"markdownIt-Anchor\" href=\"#传输\">#</a> 传输</h3>\n<p>基于  <code>flume + Kafka</code>  统一传输平台<br>\n基于  <code>LogID</code>  做日志分流：</p>\n<ul>\n<li>一般级别</li>\n<li>低级别</li>\n<li>高级别（ <code>ERROR</code> ）</li>\n</ul>\n<p>现在替换为  <code>Flink + Kafka</code>  的实现方式。</p>\n<p><img data-src=\"./images/12-log-09.png\" alt=\"\"></p>\n<h3 id=\"切分\"><a class=\"markdownIt-Anchor\" href=\"#切分\">#</a> 切分</h3>\n<p>从 <code>kafka</code>  消费日志，解析日志，写入 <code>elasticsearch</code> <br>\n <code>bili-index</code> : 自研， <code>golang</code>  开发，逻辑简单，性能 高，可定制化方便。<br>\n・日志规范产生的日志 ( <code>log agent</code>  收集)<br>\n <code>logstash</code> :  <code>es</code>  官方组件，基于  <code>jruby</code>  开发，功能强大， 资源消耗高，性能低。<br>\n・处理未按照日志规范产生的日志 ( <code>filebeat</code> 、 <code>logstash</code>  收集)，需配置各种日志解析规则。</p>\n<h3 id=\"存储和检索\"><a class=\"markdownIt-Anchor\" href=\"#存储和检索\">#</a> 存储和检索</h3>\n<p><code>elasticsearch</code>  多集群架构：<br>\n日志分级、高可用</p>\n<p>单数据集群内:<br>\n <code>master node + data node(hot/stale) + client node</code> <br>\n 每日固定时间进行热 -&gt; 冷迁移<br>\n <code>Index</code>  提前一天创建，基于  <code>template</code>  进行 <code>mapping</code>  管理<br>\n检索基于  <code>kibana</code></p>\n<h4 id=\"存储-文件\"><a class=\"markdownIt-Anchor\" href=\"#存储-文件\">#</a> 存储 - 文件</h4>\n<ul>\n<li>使用自定义协议，对  <code>SDK</code>  质量、版本升级都有比较高的要求，因此我们长期会使用 “本地文件” 的方案实现：</li>\n<li>采集本地日志文件：位置不限，容器内 <code>or</code>  物理机</li>\n<li>配置自描述：不做中心化配置，配置由  <code>app/paas</code>  自身提供， <code>agent</code>  读取配置并生效</li>\n<li>日志不重不丢：多级队列，能够稳定地处理日志收集过程中各种异常</li>\n<li>可监控：实时监控运行状态</li>\n<li>完善的自我保护机制：限制自身对于宿主机资源的消耗，限制发送速度</li>\n</ul>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "log",
                "go-log"
            ]
        }
    ]
}