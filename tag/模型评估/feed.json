{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"模型评估\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/11/17/machine-learn/Model-evaluation/02-confusion_matrix/",
            "url": "https://fangjiaxiaobai.github.io/2021/11/17/machine-learn/Model-evaluation/02-confusion_matrix/",
            "title": "模型评估之 分类模型的评估指标",
            "date_published": "2021-11-17T10:18:00.000Z",
            "content_html": "<p>混淆矩阵 ( <code>Confusion Matrix</code> ) 是分类模型的一种评估指标。它是使用一种特定的矩阵来呈现算法性能的可视化效果，通常是监督学习。(非监督学习，通常用匹配矩阵：m <code>atching matrix</code> ) 其每一列代表预测值，每一行代表的是实际的类别。这个名字来源于它可以非常容易的表明多个类别是否有混淆（也就是一个 <code>class</code>  被预测成另一个 <code>class</code> ）。</p>\n<h2 id=\"举例\"><a class=\"markdownIt-Anchor\" href=\"#举例\">#</a> 举例</h2>\n<p>我们以 是否感染新冠肺炎的模型来演示 混淆矩阵。</p>\n<p>按照定义，我们可以得到如下矩阵。</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-1.png\" alt=\"\"></p>\n<p>横向看上图，预测感染新冠为  <code>Positive</code> , 即为阳性， 未感染新冠为  <code>Negative</code>  , 即 阴性。</p>\n<p>纵向看上图，预测正确的为  <code>True</code> ,  预测错误的为 <code>False</code> .</p>\n<p>所以会得出 如下四种结果；</p>\n<ul>\n<li><code>True Positive</code> :  <code>TP</code> , 真阳性，即预测结果是新冠，真实值也是新冠。</li>\n<li><code>True Negative</code> :  <code>TN</code> , 真阴性，即预测结果是未感染，真实也未感染新冠。</li>\n</ul>\n<p>这两个结果是模型预测正确的结果，也是我们最想得到的部分，这两部分所占比重越大，模型效果越好。对应上图中绿色部分。其占比成为模型的准确率。</p>\n<ul>\n<li><code>False Positive</code> :  <code>FP</code> , 假阳性，即预测得了新冠，但是实际人并没有感染新冠。这种的属于误报。其占比属于误报率。在统计学中，  <code>FP</code>  又称为 第一类错误 ( <code>Type Error I</code> ，被判定为真的假)</li>\n<li><code>False Negative</code> :  <code>FN</code> , 假阴性，即预测没有感染新冠，但是实例已经感染了新冠。这种属于漏报率。其占比成为漏报率。 <code>FN</code>  又称为 第二类错误 ( <code>Type Error II</code> , 被判定为假的真)</li>\n</ul>\n<p>这两种情况，是模型预测错误的场景，所占比重越低越好。对应上图中红色部分。</p>\n<h2 id=\"指标\"><a class=\"markdownIt-Anchor\" href=\"#指标\">#</a> 指标</h2>\n<p>很多指标都是从混淆矩阵发展出来的。在例子中，我们已经知道了准确率，误报率，漏报率。</p>\n<p>以图为例，我们来详细的看下分类模型中混淆矩阵的相关指标.</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-2.png\" alt=\"\"></p>\n<h3 id=\"准确率\"><a class=\"markdownIt-Anchor\" href=\"#准确率\">#</a> 🔥🔥准确率</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">accuracy=\\frac{TP+TN}{TP+TN+FP+FN}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>那么，本例子中的准确率，就是： <code>(10+30)/100=40%</code></p>\n<p>理解成本最低，但不要滥用。在样本不均衡情况下，指标结果容易出现较大偏差；</p>\n<h3 id=\"精确率\"><a class=\"markdownIt-Anchor\" href=\"#精确率\">#</a> 🔥🔥精确率</h3>\n<p>精确率是判断模型识别出来的结果有多精确的指标。对应到信用评分的产品上，就是模型找到的真的坏人（对应混淆矩阵中的）的比率占模型找到的所有坏人（对应混淆矩阵中的 ）的比率。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">precision=\\frac{TP}{TP+FP}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>用于关注筛选结果是不是正确的场景，宁可没有预测出来，也不能预测错了。比如，在刷脸支付的场景下，我们宁可告诉用户检测不通过，也不能让另外一个人的人脸通过检测。</p>\n<p>精确率，又称为 查准率.</p>\n<h3 id=\"漏报率fnr\"><a class=\"markdownIt-Anchor\" href=\"#漏报率fnr\">#</a> 漏报率 (FNR)</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mi>N</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>N</mi></mrow><mrow><mi>F</mi><mi>N</mi><mo>+</mo><mi>T</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">FNR = \\frac{FN}{FN + TP}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>那么，本例子中的漏报率，就是： <code>20/(10+20)=66.67%</code></p>\n<h3 id=\"误报率\"><a class=\"markdownIt-Anchor\" href=\"#误报率\">#</a> 误报率</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">FPR = \\frac{FP}{FP + TP}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>那么，本例子中的漏报率，就是： <code>40/(40+30)=37.14%</code></p>\n<h3 id=\"召回率\"><a class=\"markdownIt-Anchor\" href=\"#召回率\">#</a> 🔥🔥召回率</h3>\n<p>表示实际患者中，预测患病成功的概率.  <code>Recall Rate</code>  又称为  <code>Sensitive</code> , 查全率。预测感染占实际感染的额比率。即预测为真占实际为真的比率。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mi>P</mi><mi>R</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">Sensitive(TPR)=\\frac{TP}{TP+FN}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>用于关注筛选结果是不是全面的场景，“宁可错杀一千，绝不放过一个”。</p>\n<h3 id=\"specificity\"><a class=\"markdownIt-Anchor\" href=\"#specificity\">#</a> Specificity</h3>\n<p>表示未患病中，预测未患病成功的概率。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mi>N</mi><mi>R</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">Specificity(TNR)=\\frac{TN}{TN+FP}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1296600000000003em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>这两个指标的出现，能更好的帮你比较模型间的差异，并在其中做出取舍。例如当两个模型的  <code>Accuracy</code>  相近时，如果你更看重于预测患病的效果，你应该选  <code>Sensitivity</code>  值较高的；相反，如果你更看重于预测未患病的效果，你就应该选择  <code>Specificity</code>  较高的。</p>\n<h3 id=\"f1-score\"><a class=\"markdownIt-Anchor\" href=\"#f1-score\">#</a> 🔥🔥F1 Score</h3>\n<p><code>F1</code>  可以综合反应精确率 和召回率。  <code>F1</code>  值越高，代表模型在精确率 和 召回率的综合表现越好。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mn>1</mn><mo>=</mo><mfrac><mrow><mn>2</mn><mo>×</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>×</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">F1=\\frac{2 \\times preciosion \\times recall}{precision+recall}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.25188em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714399999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<h3 id=\"p-r曲线\"><a class=\"markdownIt-Anchor\" href=\"#p-r曲线\">#</a> P-R 曲线</h3>\n<p TP+FP=\"\"><code>P</code>  表示查准率 (或者精确率), 计算公式是: \\frac{TP}</p>\n<p TP+FN=\"\"><code>R</code>  表示查全率 (或者召回率，Sensitive), 计算公式是: \\frac{TP}</p>\n<p><code>P-R</code>  曲线是描述查准率 / 查全率变化的曲线， <code>P-R</code>  曲线定义如下：根据学习器的预测结果（一般为一个实值或概率）对测试样本进行排序，将最可能是 “正例” 的样本排在前面，最不可能是 “正例” 的排在后面，按此顺序逐个把样本作为 “正例” 进行预测，每次计算出当前的 <code>P</code>  值和 <code>R</code>  值，如下图所示：</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-4.png\" alt=\"\"></p>\n<h4 id=\"如何看p-r曲线\"><a class=\"markdownIt-Anchor\" href=\"#如何看p-r曲线\">#</a> 如何看 P-R 曲线？</h4>\n<p><code>P-R</code>  曲线如何评估呢？若一个 <code>学习器A</code>  的 <code>P-R</code>  曲线被另一个 <code>学习器B</code>  的 <code>P-R</code>  曲线完全包住，则称： <code>B</code>  的性能优于 <code>A</code> 。若 <code>A</code>  和 <code>B</code>  的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了 “平衡点”（ <code>Break-Event Point</code> ，简称 <code>BEP</code> ），即当 <code>P=R</code>  时的取值，平衡点的取值越高，性能更优。</p>\n<p>P 和 R 指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是 F-Measure，又称 F-Score。F-Measure 是 P 和 R 的加权调和平均，即：</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-5.png\" alt=\"\"></p>\n<p>特别地，当 β=1 时，也就是常见的 F1 度量，是 P 和 R 的调和平均，当 F1 较高时，模型的性能越好。</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-6.png\" alt=\"\"></p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-7.png\" alt=\"\"></p>\n<p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。简单理解，宏观就是先算出每个混淆矩阵的 <code>P</code>  值和 <code>R</code>  值，然后取得平均 <code>P</code>  值 <code>macro-P</code>  和平均 <code>R</code>  值 <code>macro-R</code> ，在算出 <code>Fβ</code>  或 <code>F1</code> ，而微观则是计算出混淆矩阵的平均 <code>TP</code> 、 <code>FP</code> 、 <code>TN</code> 、 <code>FN</code> ，接着进行计算 <code>P</code> 、 <code>R</code> ，进而求出 <code>Fβ</code>  或 <code>F1</code> 。</p>\n<h3 id=\"roc-曲线-和-auc\"><a class=\"markdownIt-Anchor\" href=\"#roc-曲线-和-auc\">#</a> 🔥🔥ROC 曲线 和 AUC</h3>\n<p><code>ROC</code>  曲线与 <code>P-R</code>  曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是 <code>ROC</code>  曲线以 “真正例率”（ <code>True Positive Rate</code> ，简称 <code>TPR</code> , 计算公式: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{TP}{TP+FN}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.275662em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>）为横轴，纵轴为 “假正例率”（ <code>False Positive Rate</code> ，简称 <code>FPR</code> , 计算公式: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{FP}{TN+FP}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.275662em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>, 又称为特异性。 <code>Specificity</code> 。）， <code>ROC</code>  偏重研究基于测试样本评估值的排序好坏。</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-9.png\" alt=\"\"></p>\n<p>简单分析图像，可以得知：当 <code>FN=0</code>  时， <code>TN</code>  也必须 <code>0</code> ，反之也成立，我们可以画一个队列，试着使用不同的截断点（即阈值）去分割队列，来分析曲线的形状， <code>(0,0)</code>  表示将所有的样本预测为负例， <code>(1,1)</code>  则表示将所有的样本预测为正例， <code>(0,1)</code>  表示正例全部出现在负例之前的理想情况， <code>(1,0)</code>  则表示负例全部出现在正例之前的最差情况。</p>\n<h4 id=\"怎么看-roc曲线呢\"><a class=\"markdownIt-Anchor\" href=\"#怎么看-roc曲线呢\">#</a> 怎么看 ROC 曲线呢？</h4>\n<p>若一个学习器 <code>A</code>  的 <code>ROC</code>  曲线被另一个学习器 <code>B</code>  的 <code>ROC</code>  曲线完全包住，则称 <code>B</code>  的性能优于 <code>A</code> 。若 <code>A</code>  和 <code>B</code>  的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。 <code>ROC</code>  曲线下的面积定义为 <code>AUC</code> （ <code>Area Uder ROC Curve</code> ），不同于 <code>P-R</code>  的是，这里的 <code>AUC</code>  是可估算的，即 <code>AOC</code>  曲线下每一个小矩形的面积之和。易知： <code>AUC</code>  越大，证明排序的质量越好， <code>AUC</code>  为 <code>1</code>  时，证明所有正例排在了负例的前面， <code>AUC</code>  为 <code>0</code>  时，所有的负例排在了正例的前面。</p>\n<p><code>AUC</code>  计算公式:</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-10.png\" alt=\"\"></p>\n<h3 id=\"代价敏感错误率与代价曲线\"><a class=\"markdownIt-Anchor\" href=\"#代价敏感错误率与代价曲线\">#</a> 代价敏感错误率与代价曲线</h3>\n<p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt; 有疾病只是增多了检查，但有疾病–&gt; 无疾病却是增加了生命危险。以二分类为例，由此引入了 “代价矩阵”（ <code>cost matrix</code> ）。</p>\n<p>在非均等错误代价下，我们希望的是最小化 “总体代价”，这样 “代价敏感” 的错误率为:</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-11.png\" alt=\"\"></p>\n<p>同样对于 ROC 曲线，在非均等错误代价下，演变成了 “代价曲线”，代价曲线横轴是取值在 [0,1] 之间的正例概率代价，式中 p 表示正例的概率，纵轴是取值为 [0,1] 的归一化代价。</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-12.png\" alt=\"\"><br>\n<img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-13.png\" alt=\"\"></p>\n<p>代价曲线的绘制很简单：设 <code>ROC</code>  曲线上一点的坐标为 ( <code>TPR</code> ， <code>FPR</code> ) ，则可相应计算出 <code>FNR</code> ，然后在代价平面上绘制一条从 ( <code>0</code> ， <code>FPR</code> ) 到 ( <code>1</code> ， <code>FNR</code> ) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将 <code>ROC</code>  曲线图的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-confusionMetrix-14.png\" alt=\"\"></p>\n<p>以上就是 由混淆矩阵引申出来的指标了，当然这些指标都是用来评估分类模型的。下篇文章，我们再来介绍回归模型的评估指标。</p>\n<h3 id=\"指标图\"><a class=\"markdownIt-Anchor\" href=\"#指标图\">#</a> 指标图</h3>\n<p><img data-src=\"/images/ml/model_evalution/model-evalution-4.png\" alt=\"\"></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"qrcode\"></p>\n",
            "tags": [
                "MachineLearn",
                "模型评估"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/11/17/machine-learn/Model-evaluation/01-overview/",
            "url": "https://fangjiaxiaobai.github.io/2021/11/17/machine-learn/Model-evaluation/01-overview/",
            "title": "模型评估概述",
            "date_published": "2021-11-17T10:18:00.000Z",
            "content_html": "<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h2>\n<p>模型评估可以分为 离线评估和在线评估 两大类。在产品的不同阶段，我们要根据不同的场景去应用他们。</p>\n<p>两种评估方式由于其场景不同，所评估的关注点也不尽相同。其中，离线评估关注的是模型效果相关的指标，如精准率、 <code>KS</code>  等等。在线评估关注的是业务相关指标，比如新用户的转化率、优惠券的核销率、信贷审核的通过率等等。由于模型的在线评估与业务场景强相关，所以我们的课程重点将放在模型的离线评估上。</p>\n<h3 id=\"在线评估\"><a class=\"markdownIt-Anchor\" href=\"#在线评估\">#</a> 在线评估</h3>\n<p>在线评估是指在模型部署上线后，使用线上真实数据对模型进行的评估。这个时候，产品经理或者运营同学大多采用  <code>ABTest</code>  的方式去判断业务的表现.</p>\n<h3 id=\"离线评估\"><a class=\"markdownIt-Anchor\" href=\"#离线评估\">#</a> 离线评估</h3>\n<p>离线评估是指在模型部署上线前对模型进行的验证和评估工作，这个时候如果发现问题，我们可以很方便地对模型的参数进行调整和改进。</p>\n<p>离线评估又可以分为 <code>特征评估</code> 和 <code>模型评估</code> 两大类。</p>\n<h4 id=\"特征评估\"><a class=\"markdownIt-Anchor\" href=\"#特征评估\">#</a> 特征评估</h4>\n<p>为什么要关注特征评估呢？如果只评估最终模型的指标是否合规的时候，就相当于把模型作为一个 黑盒子了。但同时也要了解模型里面的内容，所以模型特征的评估也是非常重要的。 那特征评估主要关注那些内容呢？</p>\n<h5 id=\"特征自身的稳定性\"><a class=\"markdownIt-Anchor\" href=\"#特征自身的稳定性\">#</a> 特征自身的稳定性</h5>\n<p>对于特征自身的稳定，我们一般使用 <code>PSI</code>  这个指标来判断。  <code>PSI</code>  是评估某个特征的数据随着时间推移发生变化而不再稳定的指标。简单来说，就是看这个特征是不是稳定的，如果一个重要特征不够稳定，就会直接影响到模型整体的稳定性，自然也会影响业务。</p>\n<blockquote>\n<p><code>PSI</code> : ( <code>Population Stability Index</code> .  <code>PSI</code> ), 这里简单介绍一下，后面我会在一篇文章中，详细的介绍 群体稳定性 ( <code>PSI</code> ) 这个概念。 <code>PSI</code>  可用来衡量测试样本及模型开发样本评分的分布差异，为最常见的模型稳定度评估指标。计算公式为:  <code>PSI = sum(（实际占比-预期占比）* ln(实际占比/预期占比))</code> <br>\n 一般以训练集（ <code>INS</code> ）的样本分布作为预期分布，进而跨时间窗按月 / 周来计算 <code>PSI</code> ，得到 <code>Monthly/weekly PSI Report</code> ，进而剔除不稳定的变量。同理，在模型上线部署后，也将通过 <code>PSI</code>  曲线报表来观察模型的稳定性。</p>\n</blockquote>\n<h5 id=\"特征来源的稳定性\"><a class=\"markdownIt-Anchor\" href=\"#特征来源的稳定性\">#</a> 特征来源的稳定性</h5>\n<p>关于 特征来源的稳定性 评估，大致可以分为两种情况:</p>\n<ul>\n<li>如果特征数据来源于集团内部，主要考虑具体来自哪条业务线，这条业务是否稳定，以及业务方是否可能收回或者停止共享数据。</li>\n<li>如果特征接入方是外部公司，特别注意要看这个公司是否合规，是否具备完善的技术储备等等。</li>\n</ul>\n<h5 id=\"成本\"><a class=\"markdownIt-Anchor\" href=\"#成本\">#</a> 成本</h5>\n<p>在获取数据的时候，也要考虑接入的成本问题。</p>\n<ul>\n<li>公司内部数据，一般来说，不存在成本。在不同业务线的角度来说，可能会存在费用分摊的问题。</li>\n<li>外部数据，肯定是有成本的，或许是公司合作，或许是公司直接购买， 正常支付公司费用就好了。特别是注意，如果数据是按调用次数，流量计费的话，是否可以通过预先拉取数据来减少调用。</li>\n</ul>\n<h4 id=\"模型评估\"><a class=\"markdownIt-Anchor\" href=\"#模型评估\">#</a> 模型评估</h4>\n<p>模型的评估主要包括三个部分：统计性、模型性能和模型稳定性。</p>\n<h5 id=\"统计性指标\"><a class=\"markdownIt-Anchor\" href=\"#统计性指标\">#</a> 统计性指标</h5>\n<p>统计性指标指的就是模型输出结果的覆盖度、最大值、最小值、人群分布等指标。我们拿到一个模型，最先看的不是性能指标也不是稳定性，而是统计性指标，它决定了模型到底能不能用。</p>\n<p>在不同的场景下，由于我们的业务不同，对模型的要求不同，对模型统计性指标的关注点也会不同。 对统计性指标进行评估的时候，我们要充分考虑业务场景。</p>\n<p>比如:</p>\n<ul>\n<li>覆盖度。 在金融风控的场景下，如果一个模型的覆盖率低于  <code>60%</code> , 基本上就很难给到客户使用了，因为覆盖低低，风控的业务人员基本没办法对这个模型应用到决策引擎中。如果非要调用的话，最好的情况也就是用到决策树的某个分支上，专门用于某一小部分人群中，不过意义不大。</li>\n<li>最大最小值，也就是分数范围，以信用评分模型为例，如果信用评分模型覆盖的人数很多，但是模型输出的信用分数范围却很窄，假设是 <code>90-95</code> ，很显然，人群并没有好的区分度。 可以参考下芝麻分的范围就设置到了 <code>350-950</code> 。</li>\n<li>人群分布：指的是模型对人打分后，分数和人群的分布形态，这个分布形态应该符合我们的常识，比如用户消费能力评估模型，对于人群的打分结果就应该符合正态分布。</li>\n</ul>\n<h5 id=\"模型性能\"><a class=\"markdownIt-Anchor\" href=\"#模型性能\">#</a> 模型性能</h5>\n<p>模型的性能评估指标是评估模型效果的指标，他和模型要解决的问题相关， 模型要解决的问题，可以分成分类问题和回归问题。</p>\n<h6 id=\"分类模型\"><a class=\"markdownIt-Anchor\" href=\"#分类模型\">#</a> 分类模型</h6>\n<p>分类模型的性能评价指标主要包括：  <code>混淆矩阵</code> ， <code>KS</code> ，  <code>AUC</code>  等等。分类模型的性能评价指标主要包括： <code>混淆矩阵</code> 、 <code>KS</code> 、 <code>AUC</code>  等等。通过混淆矩阵，我们既可以得到一个模型的精确率、召回率这些指标，从而可以评估一个模型的区分能力，我们也可以计算得到的  <code>TPR</code> 、 <code>FPR</code> ，从而计算出  <code>AUC</code> 、 <code>KS</code>  等相关指标。因此，混淆矩阵是评估二分类模型的基础工具。</p>\n<h6 id=\"回归模型\"><a class=\"markdownIt-Anchor\" href=\"#回归模型\">#</a> 回归模型</h6>\n<p>回归模型的性能评价指标主要包括  <code>MAE</code>  (平均绝对误差),  <code>MSE</code>  (均方误差),  <code>RMSE</code>  (均方根误差), <code>R方</code> 。</p>\n<h5 id=\"模型稳定性\"><a class=\"markdownIt-Anchor\" href=\"#模型稳定性\">#</a> 模型稳定性</h5>\n<p>模型的稳定性即判断模型输出结果，是否会随着时间推移，而发生较大变化不再稳定的指标，模型的稳定性会直接影响模型的结果。比如在风控场景下，如果风控模型不够稳定，对于用户风险判断的结果就会发生较大变化。这个时候，我们需要实时调整风控策略，同时也要注意调整后造成决策不合理的情况。对于模型的稳定性，我们主要使用  <code>PSI</code>  进行评估。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"qrcode\"></p>\n",
            "tags": [
                "MachineLearn",
                "模型评估"
            ]
        }
    ]
}