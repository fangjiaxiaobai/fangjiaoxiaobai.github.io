{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"面经\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/04/%E9%9D%A2%E7%BB%8F/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/04/%E9%9D%A2%E7%BB%8F/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "title": "JDK的内置线程池",
            "date_published": "2021-08-04T06:14:00.000Z",
            "content_html": "<h1 id=\"线程池是什么\"><a class=\"markdownIt-Anchor\" href=\"#线程池是什么\">#</a> 线程池是什么？</h1>\n<p>线程池可以控制线程运行的数量，处理过程中将任务放到队列中，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，那么超出数量的线程就会排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>\n<p>主要特点为：<br>\n1、降低资源消耗，通过重复利用已创建的线程创建和销毁造成的消耗。<br>\n2、提供响应速度。当任务到达时，任务可以不需要等待线程创建，能够立即执行。<br>\n3、提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以进行统一的分配，调优和监控。</p>\n<h1 id=\"线程池参数\"><a class=\"markdownIt-Anchor\" href=\"#线程池参数\">#</a> 线程池参数：</h1>\n<ul>\n<li><code>corePoolSize</code> : 线程池中常驻的线程数。</li>\n<li><code>maximumPoolSize</code> : 线程池中能够容纳同时执行的最大线程数，此值必须大于 1.</li>\n<li><code>keepAliveTime</code> : 多余的空闲线程的存活时间。当前线程池数量超过 <code>corePoolSize</code>  时，当空闲时间达 <code>keepAliveTime</code>  值时，多余的空闲线程会被销毁直到剩下 <code>corePoolSize</code>  个线程为止。</li>\n<li><code>unit</code> :  <code>keepAliveTime</code>  的单位.</li>\n<li><code>workQueue</code> : 任务队列，被提交但尚未执行的任务.</li>\n<li><code>threadFactory</code> : 表示生成线程池中工作线程的线程工厂，用于创建线程。</li>\n<li><code>headler</code> : 拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数 ( <code>maximumPoolSize</code> ) 时采取的措施。</li>\n</ul>\n<h1 id=\"线程池运行原理\"><a class=\"markdownIt-Anchor\" href=\"#线程池运行原理\">#</a> 线程池运行原理：</h1>\n<ul>\n<li><code>1</code> . 在创建线程之后，等待提交过来的任务请求。</li>\n<li><code>2</code> . 当调用 <code>execute()</code>  方法添加一个请求任务时，线程池会做如下判断：\n<ul>\n<li><code>2.1</code> 、如果正在运行的线程数量小于 <code>corePoolSize</code> ，那么马上创建线程执行这个任务。</li>\n<li><code>2.2</code> 、如果正在运行的线程数量大于或等于 <code>corePoolSize</code> ，那么将这个任务放入队列。</li>\n<li><code>2.3</code> 、如果这时候队列满了且正在运行的线程数量还小于 <code>maximumPoolSize</code> , 那么创建非核心线程 l 立刻执行这个任务。</li>\n<li><code>2.4</code> 、如果队列满了且正在运行的线程数量大于或者等于这个 <code>maximumPoolSize</code> , 那么线程池会启动饱和拒绝策略来执行。</li>\n</ul>\n</li>\n<li><code>3</code> 、当线程执行完成任务时，它会从队列中取下一个任务来执行。</li>\n<li><code>4</code> 、当线程无事可做超过一定的时间 ( <code>keepAliveTime</code> ) 时，线程池会判断：<br>\n如果当前运行的线程数大于 <code>corePoolSize</code> ，那么这个线程就会被停掉。<br>\n所以线程池的所有任务完成后它最终会收缩到 <code>corePoolSize</code>  的大小。</li>\n</ul>\n<h1 id=\"线程池拒绝策略\"><a class=\"markdownIt-Anchor\" href=\"#线程池拒绝策略\">#</a> 线程池拒绝策略</h1>\n<p>拒绝策略实现了  <code>RejectedExecutionHandler</code>  接口。</p>\n<h2 id=\"jdk内置的四种\"><a class=\"markdownIt-Anchor\" href=\"#jdk内置的四种\">#</a> JDK 内置的四种:</h2>\n<ul>\n<li><code>AbortPolicy</code>  (默认): 直接抛出 <code>RejectedExecutionException</code>  异常阻止系统正常运行。</li>\n<li><code>CallerRunsPolicy</code> : “调用者运行” 一种运行机制，该策略既不会 抛弃任务，也不会抛出异常，而是返回给调用者，从而减轻新任务流量。</li>\n<li><code>DiscardOldestPolicy</code> : 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li>\n<li><code>DiscardPolicy</code> : 直接丢弃任务，不予任何处理也不会抛出异常。如果允许任务丢失，这是最好的</li>\n</ul>\n<h1 id=\"如何配置线程池参数\"><a class=\"markdownIt-Anchor\" href=\"#如何配置线程池参数\">#</a> 如何配置线程池参数</h1>\n<ul>\n<li>\n<p>CPU 密集型:<br>\n 需要大量的运算，没有阻塞。CPU 一直在全速运行。<br>\nCPU 密集型任务只有在真正的多核 CPU 上才可以得到加速</p>\n<p><b>参考公式： CPU 核心数 + 1 个线程</b></p>\n</li>\n<li>\n<p>IO 密集型：<br>\n即该任务需要大量的 IO，即大量的阻塞。<br>\n在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 运算能力浪费等待。所以在 IO 秘籍型任务重使用多线程可以大大的加速程序运行，即使在单核 CPU 上，这种加速主要就是利用了被浪费掉的阻塞时间。<br>\nIO 密集型，大部分线程都会阻塞。所以需要多配置线程。配置方案有两种：</p>\n<p><b>1、参考公式: CPU 核数 / 1 - 阻塞系数。 阻塞系数在 0.8-0.9 之间。</b><br>\n比如 8 核 CPU:</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>8</mn><mrow><mn>1</mn><mo>−</mo><mn>0.9</mn></mrow></mfrac><mo>=</mo><mn>80</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{8}{1-0.9}=80</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2484389999999999em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">9</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mord\">0</span></span></span></span></p>\n<p>个线程<br>\n<b>2、参考公式: CPU 核数 * 2</b></p>\n</li>\n</ul>\n",
            "tags": [
                "线程池",
                "面经"
            ]
        }
    ]
}