{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"jdk\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/11/11/JDK%E6%BA%90%E7%A0%81/versions/jdk11/",
            "url": "https://fangjiaxiaobai.github.io/2021/11/11/JDK%E6%BA%90%E7%A0%81/versions/jdk11/",
            "title": "不要再在用JDK11写JDK8的代码了!",
            "date_published": "2021-11-11T10:18:18.000Z",
            "content_html": "<p>入职新公司两个月了，用 <code>JDK11</code>  写了两个月 <code>JDK8</code>  的代码，再也憋不住想看看 <code>JDK11</code>  的新特性了。没用过 <code>JDK9,10</code> . 那就说说 <code>JDK8-JDK11</code>  的变化吧。</p>\n<h2 id=\"新\"><a class=\"markdownIt-Anchor\" href=\"#新\">#</a> 新</h2>\n<ul>\n<li>语法增强\n<ul>\n<li>本地变量类型推断</li>\n<li><code>Collection</code>  增强</li>\n<li><code>Stream</code>  增强</li>\n<li><code>Optional</code>  增强</li>\n<li><code>InputStream</code>  增强</li>\n<li><code>String</code>  增强</li>\n</ul>\n</li>\n<li>模块化开发</li>\n<li>新工具\n<ul>\n<li><code>REPL</code>  交互式编程</li>\n<li><code>Low-Overhead Heap Profiling</code></li>\n<li><code>Flight Recorder</code></li>\n</ul>\n</li>\n<li>新功能\n<ul>\n<li>源代码直接执行</li>\n<li>完全支持 <code>Linux</code>  容器</li>\n<li>支持 <code>Unicode 10</code></li>\n<li>新支持的加密算法</li>\n<li><code>HttpClient</code></li>\n</ul>\n</li>\n<li>垃圾回收器\n<ul>\n<li><code>ZGC</code></li>\n<li><code>Epsilon</code></li>\n<li>更好的 <code>G1</code></li>\n</ul>\n</li>\n<li>移除与不再推荐使用的类库或功能\n<ul>\n<li>移除了 <code>Java EE</code>  和 <code>CORBA Moudles</code></li>\n<li>将 <code>Nashorn Javascript</code>  标记为不推荐</li>\n<li>将 <code>Pack200 Tools and API</code>  标记为不推荐</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"jdk8-jdk11的语法新特性\"><a class=\"markdownIt-Anchor\" href=\"#jdk8-jdk11的语法新特性\">#</a> JDK8-JDK11 的语法新特性</h2>\n<h3 id=\"本地变量类型推断\"><a class=\"markdownIt-Anchor\" href=\"#本地变量类型推断\">#</a> 本地变量类型推断</h3>\n<p><code>since JDK10</code></p>\n<p><code>Java10</code>  以后可以用 <code>var</code>  定义一个局部变量，不用显式写出它的类型。但要注意，被 <code>var</code>  定义的变量仍然是静态类型，编译器会试图去推断其类型。所以，我们需要注意  <code>1</code> . 不兼容的类型是不能重新赋值的！ <code>2</code> . 只要编译器无法推断出变量类型，就会编译错误！</p>\n<p>举个栗子:</p>\n<h4 id=\"基本使用\"><a class=\"markdownIt-Anchor\" href=\"#基本使用\">#</a> 基本使用</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str1 = <span class=\"string\">&quot;local variable type interface&quot;</span>;</span><br><span class=\"line\">    String str2 = <span class=\"string\">&quot;local variable type interface&quot;</span>;</span><br><span class=\"line\">    System.out.println(str1 == str2); <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"简化泛型声明\"><a class=\"markdownIt-Anchor\" href=\"#简化泛型声明\">#</a> 简化泛型声明</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简化泛型声明</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lists = <span class=\"keyword\">new</span> ArrayList&lt;Map&lt;String, List&lt;String&gt;&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> item : lists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> entries = item.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> entry : entries) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            <span class=\"keyword\">var</span> values = entry.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value : values) &#123;</span><br><span class=\"line\">                System.out.println(value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>幸好编译器会有类型提示。如下图。</p>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-1.png\" alt=\"\"></p>\n<h4 id=\"简化lambda参数\"><a class=\"markdownIt-Anchor\" href=\"#简化lambda参数\">#</a> 简化 lambda 参数</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * lambda参数</span></span><br><span class=\"line\"><span class=\"comment\"> * 从Java 11开始，lambda参数也允许使用var关键字：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Predicate&lt;String&gt; predNotNull = (<span class=\"keyword\">var</span> a) -&gt; a != <span class=\"keyword\">null</span> &amp;&amp; !a.isBlank();</span><br><span class=\"line\"></span><br><span class=\"line\">    String strAfterFilter = Stream.of(<span class=\"string\">&quot;I&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;love&quot;</span>, <span class=\"string\">&quot; &quot;</span>, <span class=\"string\">&quot;my&quot;</span>, <span class=\"string\">&quot;wife&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;very&quot;</span>, <span class=\"string\">&quot;much&quot;</span>)</span><br><span class=\"line\">            .filter(predNotNull)</span><br><span class=\"line\">            .collect(Collectors.joining(<span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">    System.out.println(strAfterFilter); <span class=\"comment\">//I love my wife very much</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"不兼容的类型赋值\"><a class=\"markdownIt-Anchor\" href=\"#不兼容的类型赋值\">#</a> 不兼容的类型赋值</h4>\n<p>这种直接编译失败，第一行和第二行已经推断出来了  <code>str</code>  是  <code>String</code>  类型。 第三行就不能赋值为 <code>double</code>  类型了。</p>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-2.png\" alt=\"\"></p>\n<h4 id=\"不能推测的类型\"><a class=\"markdownIt-Anchor\" href=\"#不能推测的类型\">#</a> 不能推测的类型</h4>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-3.png\" alt=\"\"></p>\n<p>但是，对于用习惯了  <code>IDEA</code>  快捷指令的我来说，这个 <code>var</code>  变量，对我来说毫无意义。感觉 <code>jdk</code>  是在炫技，但我毫无兴趣。</p>\n<p>比如，在 <code>idea</code>  中，你输入  <code>new ArrayList().var</code>  , 然后回车， <code>IDEA</code>  就会为你自动生成类型。<br>\n类似的还有  <code>lists.for</code> ,  <code>lists.fori</code>  等等。所以，个人并不推荐大家使用该语法，并非不能用，比如在  <code>lambda</code>  中使用替换类型时还是比较好的。如果你还没有掌握  <code>xx.var</code>  这种异能加持的话，想用就用吧。</p>\n<p>总之，看别人写了个  <code>var</code>  时，不要发出 “哇藕， <code>Java</code>  还可以这么写”。</p>\n<h3 id=\"collection增强\"><a class=\"markdownIt-Anchor\" href=\"#collection增强\">#</a> Collection 增强</h3>\n<p>这个比较简单，就是  <code>List</code>  ,  <code>Set</code> ,  <code>Map</code>  这三种集合多了两个方法  <code>of</code>  和  <code>copyOf</code> .</p>\n<p><code>since jdk9</code></p>\n<p>这里直接用三个栗子分别演示一下</p>\n<h4 id=\"list\"><a class=\"markdownIt-Anchor\" href=\"#list\">#</a> List</h4>\n<p><code>List.of</code>  内部是创建一个的   <code>immutable collections</code> 。不可变集合。所以不可以增删改元素。</p>\n<p><code>List.of()</code>   和  <code>List.copyOf()</code>  都是创建的不可变集合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示 List</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; integers1 = List.copyOf(integers);</span><br><span class=\"line\">    System.out.println(integers == integers1); <span class=\"comment\">// true</span></span><br><span class=\"line\">    integers.add(<span class=\"number\">5</span>); <span class=\"comment\">//  UnsupportedOperationException</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"set\"><a class=\"markdownIt-Anchor\" href=\"#set\">#</a> Set</h4>\n<p><code>Set</code>  和  <code>List</code>  的用法类似。 同样的，也是不可变集合。需要注意的是， <code>copyOf</code>  方法，如果形参是可变集合，则返回的也是可变集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示 Set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Integer&gt; integers = Set.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    Set&lt;Integer&gt; integers1 = Set.copyOf(integers);</span><br><span class=\"line\">    System.out.println(integers == integers1); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">//        integers.add(5); //  UnsupportedOperationException</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Set&lt;Integer&gt; integers2 = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    integers2.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">    integers2.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">    integers2.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">    Set&lt;Integer&gt; integers3 = Set.copyOf(integers2);</span><br><span class=\"line\">    System.out.println(integers3 == integers2); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 元素不能重复 =&gt;  java.lang.IllegalArgumentException</span></span><br><span class=\"line\">    Set&lt;Integer&gt; integers4 = Set.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\">#</a> Map</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示Map</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用of创建Map</span></span><br><span class=\"line\">    Map&lt;String, Integer&gt; map1 = Map.of(<span class=\"string\">&quot;k1&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;k2&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    Map&lt;String, Integer&gt; map2 = Map.copyOf(map1);</span><br><span class=\"line\">    System.out.println(map1 == map2); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// copyOf，取决于传入的map是否为可变集合</span></span><br><span class=\"line\">    HashMap&lt;String, Integer&gt; map3 = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map3.put(<span class=\"string\">&quot;k1&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    map3.put(<span class=\"string\">&quot;k2&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    Map&lt;String, Integer&gt; map4 = Map.copyOf(map3);</span><br><span class=\"line\">    System.out.println(map3 == map4); <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// key不能重复 =&gt; java.lang.IllegalArgumentExceptio</span></span><br><span class=\"line\">    Map&lt;String, Integer&gt; map5 = Map.of(<span class=\"string\">&quot;k1&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;k2&quot;</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;k1&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream增强\"><a class=\"markdownIt-Anchor\" href=\"#stream增强\">#</a> Stream 增强</h3>\n<p><code>since JDK9</code></p>\n<p><code>Stream</code>  相关内容，新增了 <code>4</code>  个方法.</p>\n<h4 id=\"增加单个参数构造方法\"><a class=\"markdownIt-Anchor\" href=\"#增加单个参数构造方法\">#</a> 增加单个参数构造方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 新增单个元素的Stream构造,允许为空</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(Stream.ofNullable(<span class=\"keyword\">null</span>).count()); <span class=\"comment\">// 0</span></span><br><span class=\"line\">    System.out.println(Stream.of(<span class=\"number\">1</span>).count()); <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"增加takewhile方法\"><a class=\"markdownIt-Anchor\" href=\"#增加takewhile方法\">#</a> 增加 takeWhile 方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 演示take while方法</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  * 从头开始计算，遇到不满足Predicate的元素即停止。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; collect1 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>).takeWhile(i -&gt; i &lt;= <span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect1); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Integer&gt; collect2 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>).takeWhile(i -&gt; i &gt; <span class=\"number\">6</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect2); <span class=\"comment\">// [ ]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"增加-dropwhile-方法\"><a class=\"markdownIt-Anchor\" href=\"#增加-dropwhile-方法\">#</a> 增加 dropWhile 方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 演示 dropWhile 方法</span></span><br><span class=\"line\"><span class=\"comment\">  * 从头开始计算，遇到第一个不满足 Predicte的元素时，开始计算。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; collect1 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>).dropWhile(i -&gt; i &lt;= <span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect1); <span class=\"comment\">// [1, 2, 3, 4, 5, 4, 3, 2, 1]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Integer&gt; collect2 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>).dropWhile(i -&gt; i &gt; <span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect2); <span class=\"comment\">// [4, 5, 4, 3, 2, 1]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"iterate-重载方法\"><a class=\"markdownIt-Anchor\" href=\"#iterate-重载方法\">#</a> iterate 重载方法</h4>\n<p>这个  <code>iterate</code>  方法的新重载方法，可以让你提供一个  <code>Predicate</code>  (判断条件) 来指定什么时候结束迭代。</p>\n<p>需要注意的是：相比 <code>JDK8</code>  的方法， <code>iterator</code>  是第三个参数，第二个参数是 <code>Prediction</code> 。 <code>Prediction</code>  中进行判断的取值是迭代之后的数值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 演示 iterate 的重载方法</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Jdk8支持使用这种方式， 生成从1开始的平方数</span></span><br><span class=\"line\">    List&lt;Integer&gt; collect1 = Stream.iterate(<span class=\"number\">1</span>, i -&gt; i * <span class=\"number\">2</span>).limit(<span class=\"number\">5</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect1); <span class=\"comment\">// [1, 2, 4, 8, 16]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// JDK9 支持，加入一个 Prediction, 判断如何终止。</span></span><br><span class=\"line\">    List&lt;Integer&gt; collect2 = Stream.iterate(<span class=\"number\">1</span>, i -&gt; i &lt;= <span class=\"number\">16</span>, i -&gt; i * <span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(collect2); <span class=\"comment\">// [1, 2, 4, 8, 16]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"optional-增强\"><a class=\"markdownIt-Anchor\" href=\"#optional-增强\">#</a> Optional 增强</h3>\n<p><code>Since JDK 9</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 提供一个默认的Optional对象</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个变量, 可能为空 or not</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> variable = <span class=\"string\">&quot;jdk 11&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// jdk 8 支持of(),ofNullable() 转换为Optional对象。</span></span><br><span class=\"line\">    List&lt;String&gt; collect = Optional.of(variable).stream().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// JDK 8 可以通过 orElse, 当 variable 为空的时候，返回一个默认的字符串值。</span></span><br><span class=\"line\">    Optional.ofNullable(variable).orElse(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// jdk 9 提供了提供 or() 返回一个默认Optional对象。</span></span><br><span class=\"line\">    Optional.empty().or(() -&gt; Optional.of(<span class=\"string\">&quot;jdk 11&quot;</span>)).get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"inputstream-加强\"><a class=\"markdownIt-Anchor\" href=\"#inputstream-加强\">#</a> InputStream 加强</h3>\n<p><code>InputStream</code>  终于有了一个非常有用的方法： <code>transferTo</code> ，可以用来将数据直接传输到  <code>OutputStream</code> ，这是在处理原始数据流时非常常见的一种用法。</p>\n<p>还是举个栗子吧:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 直接将数据写入输出流</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> classLoader = ClassLoader.getSystemClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> inputStream = classLoader.getResourceAsStream(<span class=\"string\">&quot;readFile.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> javastack = File.createTempFile(<span class=\"string\">&quot;writeFile&quot;</span>, <span class=\"string\">&quot;txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (<span class=\"keyword\">var</span> outputStream = <span class=\"keyword\">new</span> FileOutputStream(javastack)) &#123;</span><br><span class=\"line\">        inputStream.transferTo(outputStream);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"string增强\"><a class=\"markdownIt-Anchor\" href=\"#string增强\">#</a> String 增强</h3>\n<h4 id=\"isblank\"><a class=\"markdownIt-Anchor\" href=\"#isblank\">#</a> isBlank</h4>\n<p>判断目标字符串是否是空白字符。</p>\n<p>使用功能上的问题，感觉还是例子来的舒服。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 判断字符串是否为空</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 半角空格  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot; &quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 全角空格  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;　&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 半角空格的unicode字符值  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;\\u0020&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 全角空格的unicode字符值  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;\\u3000&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 制表符  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;\\t&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 回车  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;\\r&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 换行  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;\\n&quot;</span>.isBlank());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 各种空白字符拼接  ===&gt; true</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot; \\t\\r\\n　&quot;</span>.isBlank());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"stripstripleading与striptrailing\"><a class=\"markdownIt-Anchor\" href=\"#stripstripleading与striptrailing\">#</a> strip，stripLeading 与 stripTrailing</h4>\n<p>去除字符串的前后字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全角空格 + 制表符 + 回车 + 换行 + 半角空格 + &lt;内容&gt; + 全角空格 + 制表符 + 回车 + 换行 + 半角空格</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strTest = <span class=\"string\">&quot;　\\t\\r\\n 你好 jdk11　\\t\\r\\n &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// strip 去除两边空白字符</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;[&quot;</span> + strTest.strip() + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// stripLeading 去除开头的空白字符</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;[&quot;</span> + strTest.stripLeading() + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// stripTrailing 去除结尾的空白字符</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;[&quot;</span> + strTest.stripTrailing() + <span class=\"string\">&quot;]&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"repeat\"><a class=\"markdownIt-Anchor\" href=\"#repeat\">#</a> repeat</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> strOri = <span class=\"string\">&quot;jdk11&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = strOri.repeat(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = strOri.repeat(<span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(str1);</span><br><span class=\"line\">System.out.println(str2);</span><br><span class=\"line\"><span class=\"comment\">// repeat传入参数为1时，不会创建一个新的String对象，而是直接返回原来的String对象。</span></span><br><span class=\"line\">System.out.println(str1 == strOri);</span><br></pre></td></tr></table></figure>\n<h4 id=\"lines\"><a class=\"markdownIt-Anchor\" href=\"#lines\">#</a> lines</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 按照换行符拆分字符串</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">demo3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> strContent = <span class=\"string\">&quot;hello java\\rhello jdk11\\nhello world\\r\\nhello everyone&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// lines方法用 \\r 或 \\n 或 \\r\\n 对字符串切割并返回stream对象</span></span><br><span class=\"line\">    strContent.lines().forEach(System.out::println);</span><br><span class=\"line\">    System.out.println(strContent.lines().count());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模块化开发\"><a class=\"markdownIt-Anchor\" href=\"#模块化开发\">#</a> 模块化开发</h2>\n<p><code>Java9</code>  引入了模块化， <code>Java Platform Module System</code> ， <code>java</code>  平台模块系统，简称 <code>JPMS</code> 。</p>\n<p>这里和大家一起做一下。</p>\n<h3 id=\"新建两个-module\"><a class=\"markdownIt-Anchor\" href=\"#新建两个-module\">#</a> 新建两个 module</h3>\n<p>我们新建两个模块 core 和 business。 如下图</p>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-5.png\" alt=\"\"></p>\n<h3 id=\"core-模块配置\"><a class=\"markdownIt-Anchor\" href=\"#core-模块配置\">#</a> core 模块配置</h3>\n<ul>\n<li>新建一个类 RestResult ，表示公共调用的类。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestResult</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> T data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer code;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String errMsg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RestResult</span><span class=\"params\">(T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建一个  <code>module-info.java</code> . 声明  <code>module</code>  信息.   <code>exports</code>  将  <code>com.fxb.learn.module.core</code>  这个包下的类都 export 出去。\n<ul>\n<li>如果是一个 <code>java</code>  的普通应用，则在  <code>src</code>  目录下，新建  <code>module-info.java</code>  文件即可。</li>\n<li>如果是一个 <code>maven</code>  应用，则需要在  <code>src/main/java</code>  目录下，新建  <code>module-info.java </code> 文件。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// core 是module的名称</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> core &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将指定的包下类，export出去</span></span><br><span class=\"line\">    <span class=\"keyword\">exports</span> com.fxb.learn.<span class=\"keyword\">module</span>.core;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"business-模块配置\"><a class=\"markdownIt-Anchor\" href=\"#business-模块配置\">#</a> business 模块配置</h3>\n<ul>\n<li>在 <code>business</code>  模块下，新建一个  <code>module-info.java</code> . 文件位置上 <code>core</code>  模块中的一致。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> business &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> core;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 <code>Idea</code>  中配置， <code>business</code>  模块引用 <code>core</code>  模块。</li>\n</ul>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-4.png\" alt=\"\"></p>\n<h3 id=\"写个例子看看\"><a class=\"markdownIt-Anchor\" href=\"#写个例子看看\">#</a> 写个例子看看</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 演示模块调用。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RestResult&lt;User&gt; <span class=\"title\">getUserById</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RestResult&lt;&gt;(<span class=\"keyword\">new</span> User(<span class=\"number\">1</span>, <span class=\"string\">&quot;fangjiaxiaobai&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"新工具\"><a class=\"markdownIt-Anchor\" href=\"#新工具\">#</a> 新工具</h2>\n<p><code>JDK</code>  还提供了一些新的工具，  <code>REPL</code>  交互式编程， <code>Low-Overhead Heap Profiling</code>  (免费的低耗能飞行记录仪和堆分析仪), <code>Flight Recorder</code>  (黑盒子)</p>\n<h3 id=\"repl交互式编程\"><a class=\"markdownIt-Anchor\" href=\"#repl交互式编程\">#</a>  <code>REPL</code>  交互式编程</h3>\n<p>你是否使用 j <code>upter</code> ,  <code>java </code> 也有了！</p>\n<p><code>Java</code>  提供了一个新的工具 <code>jshell</code> ， <code>Java</code>  终于可以像 <code>python</code> ， <code>scala</code>  等语言那样，交互式演示语法了</p>\n<p><img data-src=\"/images/java/jdk/versions/jdk8-jdk11-6.png\" alt=\"\"></p>\n<p>具体命令可以使用  <code>/help</code>  命令查看。</p>\n<h3 id=\"low-overhead-heap-profiling\"><a class=\"markdownIt-Anchor\" href=\"#low-overhead-heap-profiling\">#</a> Low-Overhead Heap Profiling</h3>\n<p>免费的低耗能飞行记录仪和堆分析仪。</p>\n<p>通过 <code>JVMTI</code>  的 <code>SampledObjectAlloc</code>  回调提供了一个开销低的 <code>heap</code>  分析方式提供一个低开销的，为了排错 <code>java</code>  应用问题，以及 <code>JVM</code>  问题的数据收集框架。<br>\n具有一下功能:</p>\n<ul>\n<li>提供用于生产和消费数据作为事件的 <code>API</code></li>\n<li>提供缓存机制和二进制数据格式</li>\n<li>允许事件配置和事件过滤</li>\n<li>提供 <code>OS</code> , <code>JVM</code>  和 <code>JDK</code>  库的事件</li>\n</ul>\n<h3 id=\"flight-recorder\"><a class=\"markdownIt-Anchor\" href=\"#flight-recorder\">#</a> Flight Recorder</h3>\n<p><code>Flight Recorder</code>  源自飞机的黑盒子。  <code>Flight Recorder</code>  以前是商业版的特性，在 <code>java11</code>  当中开源出来，它可以导出事件到文件中，之后可以用 <code>Java Mission Control</code>  来分析。</p>\n<p>两种启动方式:</p>\n<p>可以在应用启动时配置 <code>java -XX:StartFlightRecording</code> <br>\n 应用启动之后，使用 <code>jcmd</code>  来录制，如下代码:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jcmd &lt;pid&gt; JFR.start  <span class=\"comment\"># 启动记录仪</span></span><br><span class=\"line\">$ jcmd &lt;pid&gt; JFR.dump.filename=recording.jfr  <span class=\"comment\"># 将记录内容保存到文件里</span></span><br><span class=\"line\">$ jcmd &lt;pid&gt; JFR.stop  <span class=\"comment\"># 停止记录仪</span></span><br></pre></td></tr></table></figure>\n<p>不过在  <code>jdk11</code>  是没办法查看  <code>jfr</code>  的。如果想看，安装  <code>jdk12</code>  吧。 不，可以试试  <code>jdk16</code>  ,   <code>jdk16</code>  也是 <code>LTS</code>  版本！・</p>\n<blockquote>\n<p>JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在 SPECjbb2015 等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR, 用以在复杂环境中进行 &quot;After-the-fact&quot; 分析。还需要苦恼重现随机问题吗？JFR 让问题简化了很多<br>\n在保证低开销的基础上，JFR 提供的能力也令人眼前一亮，例如：我们无需 BCI 就可以进行 Object Allocation Profiling， 终于不用担心 BTrace 之类把进程搞挂了。对锁竞争、阻塞、延迟，JVM GC、SafePoint 等领域，进行非常细粒度分析。甚至深入 JIT Compiler 内部，全面把握热点方法、内联、逆优化等等。JFR 提供了标准的 Java,C++ 等扩展 API, 可以与各种层面的应用进行定制、集成，为复杂的企业应用栈或者复杂的分布式应用，提供 All-in-One 解决方案。而这一切都是内建在 JDK 和 JVM 内部的，并不需要额外的依赖，开箱即用。</p>\n</blockquote>\n<h2 id=\"新功能\"><a class=\"markdownIt-Anchor\" href=\"#新功能\">#</a> 新功能</h2>\n<h3 id=\"httpclient\"><a class=\"markdownIt-Anchor\" href=\"#httpclient\">#</a> HttpClient</h3>\n<p><code>JDK 9</code>  开始引入 <code>HttpClient API</code>  来处理 <code>HTTP</code>  请求。 从 <code>JDK 11</code>  开始，这个・正式进入标准库包。<br>\n参考网址：<span class=\"exturl\" data-url=\"aHR0cDovL29wZW5qZGsuamF2YS5uZXQvZ3JvdXBzL25ldC9odHRwY2xpZW50L2ludHJvLmh0bWw=\">http://openjdk.java.net/groups/net/httpclient/intro.html</span></p>\n<p><code>HttpClient</code>  具有以下特性:</p>\n<ul>\n<li>支持  <code>HTTP1.1</code>  和  <code>HTTP2</code> ,  <code>websocket</code>  协议</li>\n<li>支持同步和异步编程模型</li>\n<li>将请求和响应主体作为响应式流 ( <code>reactive-streams</code> ) 处理，并使用构建器模式</li>\n<li>要发送 <code>http</code>  请求，首先要使用其构建器创建一个 <code>HttpClient</code> 。这个构建器能够配置每个客户端的状态：\n<ul>\n<li>首选协议版本 (  <code>HTTP/1.1</code>  或  <code>HTTP/2</code>  )</li>\n<li>是否跟随重定向</li>\n<li>代理</li>\n<li>身份验证</li>\n</ul>\n</li>\n</ul>\n<p>一旦构建完成，就可以使用 <code>HttpClient</code>  发送多个请求。</p>\n<h4 id=\"httprequest\"><a class=\"markdownIt-Anchor\" href=\"#httprequest\">#</a> HttpRequest</h4>\n<p><code>HttpRequest</code>  是由它的构建器创建的。请求的构建器可用于设置:</p>\n<ul>\n<li>请求 <code>URI</code></li>\n<li>请求 <code>Method</code>  (  <code>GET</code> ,  <code>PUT</code> ,  <code>POST</code>  )</li>\n<li>请求主体 (如果有)</li>\n<li>超时时间</li>\n<li>请求头</li>\n</ul>\n<p><code>HttpRequest</code>  构建之后是不可变的，但可以发送多次。</p>\n<h4 id=\"synchronous-or-asynchronous\"><a class=\"markdownIt-Anchor\" href=\"#synchronous-or-asynchronous\">#</a> Synchronous or Asynchronous</h4>\n<p>请求既可以同步发送，也可以异步发送。当然同步的 <code>API</code>  会导致线程阻塞直到 <code>HttpResponse</code>  可用。异步 <code>API</code>  立即返回一个 <code>CompletableFuture</code> ，当 <code>HttpResponse</code>  可用时，它将获取 <code>HttpResponse</code>  并执行后续处理。</p>\n<h4 id=\"data-as-reactive-streams\"><a class=\"markdownIt-Anchor\" href=\"#data-as-reactive-streams\">#</a> Data as reactive-streams</h4>\n<p>请求和响应的主体作为响应式流 (具有非阻塞背压的异步数据流) 供外部使用。 <code>HttpClient</code>  实际上是请求正文的订阅者和响应正文字节的发布者。 <code>BodyHandler</code>  接口允许在接收实际响应体之前检查响应代码和报头，并负责创建响应 <code>BodySubscriber</code> 。</p>\n<p><code>HttpRequest</code>  和 <code>HttpResponse</code>  类型提供了许多便利的工厂方法，用于创建请求发布者和响应订阅者，以处理常见的主体类型，如文件、字符串和字节。这些便利的实现要么累积数据，直到可以创建更高级别的 <code>Java</code>  类型（如 <code>String</code> ），要么就文件流传输数据。 <code>BodySubscriber</code>  和 <code>BodyPublisher</code>  接口可以实现为自定义反应流处理数据。</p>\n<p><code>HttpRequest</code>  和 <code>HttpResponse</code>  还提供了转换器，用于将  <code>java.util.concurrent.Flow</code>  的  <code>Publisher/Subscriber</code>  类型转换为  <code>HTTP Client</code>  的  <code>BodyPublisher/BodySubscriber</code>  类型。</p>\n<h4 id=\"请求协议-http2\"><a class=\"markdownIt-Anchor\" href=\"#请求协议-http2\">#</a> 请求协议 HTTP/2</h4>\n<p><code>Java HTTP Client</code>  支持  <code>HTTP/1.1</code>  和  <code>HTTP/2</code> 。默认情况下，客户端将使用  <code>HTTP/2</code>  发送请求。发送到尚不支持  <code>HTTP/2 </code> 的服务器的请求将自动降级为  <code>HTTP/1.1</code> 。</p>\n<p>以下是 <code>HTTP/2</code>  带来的主要改进:</p>\n<ul>\n<li>标头压缩。 HTTP/2 使用 HPACK 压缩，从而减少了开销。</li>\n<li>与服务器的单一连接减少了建立多个 TCP 连接所需的往返次数。</li>\n<li>多路复用。 在同一连接上，同时允许多个请求。</li>\n<li>服务器推送。 可以将其他将来需要的资源发送给客户端。</li>\n<li>二进制格式。 更紧凑。</li>\n</ul>\n<p>由于 <code>HTTP/2</code>  是默认的首选协议，并且在需要的地方无缝地实现回退到 <code>HTTP/1.1</code> ，那么当 <code>HTTP/2</code>  被更广泛地部署时， <code>Java HTTP</code>  客户端就无需修正它的应用代码。</p>\n<p>具体的 <code>Java Doc</code>  可以参考: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTEvZG9jcy9hcGkvamF2YS5uZXQuaHR0cC9qYXZhL25ldC9odHRwL3BhY2thZ2Utc3VtbWFyeS5odG1s\">https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/package-summary.html</span></p>\n<p>看了  <code>Java Doc</code> , 感觉使用起来比较简单。这里就不举例了。感兴趣的朋友，可以自行深入研究一下。</p>\n<h3 id=\"源代码直接执行\"><a class=\"markdownIt-Anchor\" href=\"#源代码直接执行\">#</a> 源代码直接执行</h3>\n<p>一个单文件源代码，也就是说，单独的 <code>java</code>  文件，有 <code>main</code>  方法，且只依赖 <code>jdk</code>  类库以及自己文件内部定义的类，可以直接用 <code>java</code>  执行而无需先编译再执行编译后的 <code>class</code>  文件了。</p>\n<p>你可能问了，有什么用呢？我平时也不关系它是否生成了 <code>class</code>  文件。</p>\n<p>如果你是做数据相关的工作，可能需要写一些脚本的时候，这却是轻松了很多。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  learn git:(master) ✗ ll</span><br><span class=\"line\">total 8</span><br><span class=\"line\">-rw-r--r--  1 wangxiyue  staff   411B Nov  9 22:58 SourceCodeExecDemo.java</span><br><span class=\"line\">➜  learn git:(master) ✗ java SourceCodeExecDemo.java</span><br><span class=\"line\">1.解析数据格式.....</span><br><span class=\"line\">2.处理数据.....</span><br><span class=\"line\">3.重组数据.....</span><br><span class=\"line\">➜  learn git:(master) ✗ ll                          </span><br><span class=\"line\">total 8</span><br><span class=\"line\">-rw-r--r--  1 wangxiyue  staff   411B Nov  9 22:58 SourceCodeExecDemo.java</span><br></pre></td></tr></table></figure>\n<p>可以看到确实没有  <code>class</code>  文件生成。</p>\n<h3 id=\"完全支持linux容器\"><a class=\"markdownIt-Anchor\" href=\"#完全支持linux容器\">#</a> 完全支持 Linux 容器</h3>\n<p>在 <code>Docker</code>  容器中运行 <code>Java</code>  应用程序一直存在一个问题，那就是在容器中运行的 <code>JVM</code>  程序在设置内存大小和 <code>CPU</code>  使用率后，会导致应用程序的性能下降。这是因为 <code>Java</code>  应用程序没有意识到它正在容器中运行。随着 <code>Java10</code>  的发布，这个问题总算得以解诀， <code>JVM</code>  现在可以识别由容器控制组 ( <code>cgroups</code> ) 设置的约束，可以在容器中使用内存和 <code>CPU</code>  约束来直接管理 <code>Java</code>  应用程序，其中包括:</p>\n<ul>\n<li>遵守容器中设置的内存限制</li>\n<li>在容器中设置可用的 <code>CPU</code></li>\n<li>在容器中设置 <code>CPU</code>  约束</li>\n</ul>\n<h3 id=\"支持unicode-10\"><a class=\"markdownIt-Anchor\" href=\"#支持unicode-10\">#</a> 支持 Unicode 10</h3>\n<p><code>Unicode 10</code>  新增了 <code>8518</code>  个字符，总计达到了 <code>136690</code>  个字符。包括 <code>56</code>  个新的 <code>emoji</code>  表情符号。</p>\n<p><code>JDK11</code>  在 <code>java.lang</code>  下增加了 4 个类来处理:</p>\n<ul>\n<li><code>CharacterData00.class</code></li>\n<li><code>CharacterData01.class</code></li>\n<li><code>CharacterData02.class</code></li>\n<li><code>CharacterData0E.class</code></li>\n</ul>\n<h3 id=\"新支持的加密算法\"><a class=\"markdownIt-Anchor\" href=\"#新支持的加密算法\">#</a> 新支持的加密算法</h3>\n<p><code>Java</code>  实现了 <code>RFC7539</code>  中指定的 <code>ChaCha20</code>  和 <code>Poly1305</code>  两种加密算法，代替 <code>RC4</code> 。<br>\n <code>RFC7748</code>  定义的密钥协商方案更高效，更安全， <code>JDK</code>  增加了两个新的接口 <code>XECPublicKey</code>  和 <code>XECPrivateKey</code> 。</p>\n<h2 id=\"垃圾回收器\"><a class=\"markdownIt-Anchor\" href=\"#垃圾回收器\">#</a> 垃圾回收器</h2>\n<h3 id=\"zgc\"><a class=\"markdownIt-Anchor\" href=\"#zgc\">#</a> ZGC</h3>\n<p>启用方法： <code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></p>\n<p>说明： <code>ZGC</code> , <code> A Scalable Low-Latency Garbage collector</code> (  <code>Experimental</code> ) ，一个可伸缩的低延时的垃圾回收器。 <code>GC</code>  暂停时间不会超过 <code>10ms</code> ，既能处理几百兆的小堆，也能处理几个 <code>T</code>  的大堆。和 <code>G1</code>  相比，应用吞吐能力不会下降超过 <code>15%</code> ，为未来的 <code>GC</code>  功能和利用 <code>colord</code>  指针以及 <code>Load barriers</code>  优化奠定了基础。初始只支持 <code>64</code>  位系统。</p>\n<p><code>ZGC</code>  的设计目标是：支持 <code>TB</code>  级内存容量，暂停时间低 ( <code>&lt;10ms</code> )，对整个程序吞吐量的影响小于 <code>15%</code> 。将来还可以扩 展实现机制，以支持不少令人兴奋的功能，例如多层堆 (即热对象置于 <code>DRAM</code>  和冷对象置于 <code>NVMe</code>  闪存)，或压缩堆。</p>\n<p><code>GC</code>  是 <code>java</code>  主要优势之一。然而，当 <code>GC</code>  停顿太长，就会开始影响应用的响应时间。消除或者减少 <code>GC</code>  停顿时长， <code>java</code>  将有可能在更广泛的应用场景中成长为一个更有吸引力的平台。此外，现代系统中可用内存不断增长，用户和程序员希望 <code>JVM</code>  能够以高效的方式充分利用这些内存，并且无需长时间的 <code>GC</code>  暂停时间。</p>\n<p><code>ZGC</code>  是一个并发，基于 <code>region</code> , 压缩型的垃圾收集器，只有 <code>root</code>  扫描阶段会 <code>STW</code> , 因此 <code>GC</code>  停顿时间不会随着堆的增长和存活对象的增长而变长。</p>\n<h3 id=\"epsilon\"><a class=\"markdownIt-Anchor\" href=\"#epsilon\">#</a> Epsilon</h3>\n<p>实验性质，生产环境不建议使用。</p>\n<p>启用方法： <code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code></p>\n<p>说明：开发一个处理内存分配但不实现任何实际内存回收机制的 <code>GC</code> , 一旦可用堆内存用完， <code>JVM</code>  就会退出，如果有 <code>System.gc()</code>  调用，实际上什么也不会发生 (这种场景下和 <code>-XX:+DisableExplicitGC</code>  效果一样), 因为没有内存回收，这个实现可能会警告用户尝试强制 <code>GC</code>  是徒劳的。</p>\n<p>主要用途如下:</p>\n<ul>\n<li>性能测试 (它可以帮助过滤掉 <code>GC</code>  引起的性能假象)</li>\n<li>内存压力测试 (例如，知道测试用例应该分配不超过 <code>1GB</code>  的内存，我们可以使用 <code>-Xmx1g -XX:+UseEpsilonGC</code> ，如果程序有问题，则程序会崩溃。</li>\n<li>非常短的 <code>JOB</code>  任务 (对于这种任务， <code>GC</code>  是在浪费资源)</li>\n<li><code>VM</code>  接口测试</li>\n<li><code>Last-drop</code>  延迟 &amp; 吞吐改进</li>\n</ul>\n<h3 id=\"更好的g1\"><a class=\"markdownIt-Anchor\" href=\"#更好的g1\">#</a> 更好的 G1</h3>\n<p>对于 <code>G1 GC</code> , 相比于 <code>JDK8</code> , 升级到 <code>JDK 11</code>  即可免费享受到：并行的 <code>Full GC</code> , 快速的 <code>CardTable</code>  扫描，自适应的堆占用比例调整 ( <code>IHOP</code> ), 在并发标记阶段的类型卸载等等。这些都是针对 <code>G1</code>  的不断增强，其中串行 <code>FullGC</code>  等甚至是曾经被广泛诟病的短板，你会发现 <code>GC</code>  配置和调优在 <code>JDK11</code>  中越来越方便。</p>\n<h2 id=\"移除与不再推荐使用的类库或功能\"><a class=\"markdownIt-Anchor\" href=\"#移除与不再推荐使用的类库或功能\">#</a> 移除与不再推荐使用的类库或功能</h2>\n<p><code>Jdk9</code>  到 <code>Jdk11</code> ，陆续移除了一些类库或功能。</p>\n<h3 id=\"移除了java-ee和corba-moudles\"><a class=\"markdownIt-Anchor\" href=\"#移除了java-ee和corba-moudles\">#</a> 移除了 Java EE 和 CORBA Moudles</h3>\n<p>在 <code>java11</code>  中移除了不太使用的 <code>JavaEE</code>  模块和 <code>CORBA</code>  技术。</p>\n<p><code>CORBA</code>  来自于二十世纪九十年代， <code>Oracle</code>  认为，现在用 <code>CORBA</code>  开发现代 <code>Java</code>  应用程序已经没有意义了，维护 <code>CORBA</code>  的成本已经超过了保留它带来的好处。</p>\n<p>但是删除 <code>CORBA</code>  将使得那些依赖于 <code>JDK</code>  提供部分 <code>CORBAAPI</code>  的 <code>CORBA</code>  实现无法运行。目前还没有第三方 <code>CORBA</code>  版本，也不确定是否会有第三方愿意接手 <code>CORBA API</code>  的维护工作。</p>\n<p>在 <code>java11</code>  中将 <code>java9</code>  标记废弃的 <code>Java EE</code>  及 <code>CORBA</code>  模块移除掉，具体如下:</p>\n<p><code>xml</code>  相关被移除的：</p>\n<ul>\n<li><code>java.xml.ws</code></li>\n<li><code>java.xml.bind</code></li>\n<li><code>java.xml.ws</code></li>\n<li><code>java.xml.ws.annotation</code></li>\n<li><code>jdk.xml.bind</code></li>\n<li><code>jdk.xml.ws</code></li>\n</ul>\n<p>只剩下 <code>java.xml</code> ,  <code>java.xml.crypto.jdk.xml.dom</code>  这几个模块。</p>\n<p>其它被移除的 Java EE 和 CORBA 相关类库:</p>\n<ul>\n<li><code>java.corba</code></li>\n<li><code>java.se.ee</code></li>\n<li><code>java.activation</code></li>\n<li><code>java.transaction</code>  (但是 <code>java11</code>  新增了一个 <code>java.transaction.xa</code>  模块)</li>\n</ul>\n<h3 id=\"其他移除的类库\"><a class=\"markdownIt-Anchor\" href=\"#其他移除的类库\">#</a> 其他移除的类库</h3>\n<ul>\n<li><code>com.sun.awt.AWTUtilities</code></li>\n<li><code>sun.miss.Unsafe.defineClass</code></li>\n<li><code>Thread.destroy()</code>  以及  <code>Thread.stop(Throwable)</code>  方法</li>\n<li><code>sun.nio.ch.disableSystemWideOverlappingFileLockCheck</code>  属性</li>\n<li><code>sun.locale.formatasdefault</code>  属性</li>\n<li><code>jdk snmp</code>  模块</li>\n<li><code>javafx</code></li>\n<li><code>java Mission Control</code></li>\n<li><code>Root Certificates</code> : 一些根证书被移除： <code>Baltimore Cybertrust Code Signing CA, SECOM Root Certificate, AOL and Swisscom Root Certificates</code></li>\n</ul>\n<p>其中，使用 <code>java.lang.invoke.MethodHandles.Lookup.defineClass</code>  来替代移除的 <code>sun.miss.Unsafe.defineClass</code> 。</p>\n<h3 id=\"将nashorn-javascript标记为不推荐\"><a class=\"markdownIt-Anchor\" href=\"#将nashorn-javascript标记为不推荐\">#</a> 将 Nashorn Javascript 标记为不推荐</h3>\n<p>将 <code>Javascript</code>  引擎标记为 <code>Deprecate</code> ，后续版本会移除，有需要的可以考虑使用开源的 <code>GraalVM</code> 。</p>\n<h3 id=\"将pack200-tools-and-api标记为不推荐\"><a class=\"markdownIt-Anchor\" href=\"#将pack200-tools-and-api标记为不推荐\">#</a> 将 Pack200 Tools and API 标记为不推荐</h3>\n<p><code>java11</code>  中将 <code>pack200</code>  以及 <code>unpack200</code>  工具以及 <code>java.tiljar</code>  中的 <code>Pack200 API</code>  标记为 <code>Deprecate</code> 。因为 <code>Pack200</code>  主要是用来压缩 <code>jar</code>  包的工具，由于网络下载速度的提升以及 <code>java9</code>  引入模块化系统之后不再依赖 <code>Pack200</code> ，因此这个版本将其标记为 <code>Deprecate</code> 。</p>\n<h2 id=\"预告\"><a class=\"markdownIt-Anchor\" href=\"#预告\">#</a> 预告</h2>\n<p>继 <code>LTS JDK8</code>  之后，又一 <code>LTS</code> , 你会用吗？ <code>JDK16</code> , 它来了。</p>\n<h2 id=\"对了\"><a class=\"markdownIt-Anchor\" href=\"#对了\">#</a> 对了</h2>\n<p><code>JDK11</code>  写  <code>JDK8</code>  的代码？</p>\n<p>代码始终是代码，写的再多，写不懂你我。</p>\n<p>多看一点，就比其他们多懂一点。所以，你关不关注我，问题不大！</p>\n<p>人情世故。不是世故，就是事故。问题真的不大。</p>\n<p>文中所有代码，在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vZmFuZ2ppYXhpYW9iYWkvbGVhcm5famF2YS90cmVlL21hc3Rlci9meGJfamRrMTE=\">https://gitee.com/fangjiaxiaobai/learn_java/tree/master/fxb_jdk11</span></p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/java/jdk/versions/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "JDK",
                "JDK版本",
                "JDK11"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "title": "JDK的Stream之系列一 初窥流原理",
            "date_published": "2021-08-23T15:13:55.000Z",
            "content_html": "<p>学东西的时候最好是理论先行，为什么？没有理论，想当然的去干，干好了是 瞎猫碰上死耗子，干不好就瞎干，浪费时间，只会弄得身心俱疲。<br>\n可是在真正的工作中，很少工作会允许你先弄清原理再去实操。但是不管怎么说，欠下的债终究是需要还的。</p>\n<p>今天咱们的主题是  <code>stream</code> . 咱们就从 <code>Stream</code>  的 &quot;道，术，法，器&quot; 四个阶段来聊好好的聊聊这个  <code>Stream</code> .</p>\n<h2 id=\"以器始从使用开始\"><a class=\"markdownIt-Anchor\" href=\"#以器始从使用开始\">#</a> 以 &quot;器&quot; 始：从使用开始</h2>\n<blockquote>\n<p>你平时是怎么使用  <code>Stream</code>  的？</p>\n</blockquote>\n<p>比如我会使用 <code>Stream</code>  创建一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integerStream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// do somethings ..</span></span><br></pre></td></tr></table></figure>\n<p>或者把一种集合类型转成 <code>stream</code> ，然后做一些聚合操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; collect = list.stream()</span><br><span class=\"line\">        .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">        .filter(item -&gt; item &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">        .sorted()</span><br><span class=\"line\">        .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>那在 <code>jdk1.7</code>  及以前的时候，我们是怎么处理的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历list，所有元素+5</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    Integer integer = list.get(i);</span><br><span class=\"line\">    integer += <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正序排序</span></span><br><span class=\"line\">sort(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新List.存储10个元素</span></span><br><span class=\"line\">List&lt;Integer&gt; newList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (list.size() &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    System.arraycopy(list, list.size() - <span class=\"number\">11</span>, newList, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    System.arraycopy(list, <span class=\"number\">0</span>, newList, <span class=\"number\">0</span>, list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的对比，我们很明显的就能对比出来：<br>\n <code>stream</code>  的编码方式，使代码更加简洁，可读性也比较强。而且 <code>Stream</code>  提供了集合的常用操作，比如 <code>sort</code> , <code>过滤</code> ， <code>去重</code> ， <code>计数</code> ， <code>limit</code> , <code>skip</code>  等等，直接可以用，可以大大的提高开发效率。</p>\n<p>那  <code>Stream</code>  为我们提供了多少功能呢？</p>\n<p>从全局来看，所有和  <code>stream</code>  相关的类，都在  <code>java.lang.stream</code>  这包下。</p>\n<p>这个包下有很多的类。总体来说，</p>\n<p>流处理相关的操作分为两类:</p>\n<ul>\n<li>中间操作 ( <code>Intermediate Operations</code> )\n<ul>\n<li>无状态的中间操作 ( <code>Stateless</code> ): 使用  <code>StatelessOp</code>  表示。每个操作都是互不影响，不依赖的。这类的操作有:  <code>filter()</code> 、 <code>flatMap()</code> 、 <code>flatMapToDouble()</code> 、 <code>flatMapToInt()</code> 、 <code>flatMapToLong()</code> 、 <code>map()</code> 、 <code>mapToDouble()</code> 、 <code>mapToInt()</code> 、 <code>mapToLong()</code> 、 <code>peek()</code> 、 <code>unordered()</code>  等</li>\n<li>有状态操作（ <code>Stateful</code> ）：使用  <code>StatefulOp</code>  表示。处理时会记录状态，比如处理了几个。后面元素的处理会依赖前面记录的状态，或者拿到所有元素才能继续下去。如 <code>distinct()</code> 、 <code>sorted()</code> 、 <code>sorted(comparator)</code> 、 <code>limit()</code> 、 <code>skip()</code>  等</li>\n</ul>\n</li>\n<li>终止操作 ( <code>Terminal Operations</code> )：使用  <code>TerminalOp</code>  表示。\n<ul>\n<li>非短路操作：处理完所有数据才能得到结果。如 <code>collect()</code> 、 <code>count()</code> 、 <code>forEach()</code> 、 <code>forEachOrdered()</code> 、 <code>max()</code> 、 <code>min()</code> 、 <code>reduce()</code> 、 <code>toArray()</code>  等。</li>\n<li>短路（ <code>short-circuiting</code> ）操作：拿到符合预期的结果就会停下来，不一定会处理完所有数据。如 <code>anyMatch()</code> 、 <code>allMatch()</code> 、 <code>noneMatch()</code> 、 <code>findFirst()</code> 、 <code>findAny()</code>  等。</li>\n</ul>\n</li>\n</ul>\n<p>在深入探讨 <code>stream</code>  之前，我们需要储备些知识点。</p>\n<ul>\n<li>\n<p>函数式接口  <code>FunctionInterface</code></p>\n<p><code>JDK</code>  提供了很多的函数式接口，包路径是： <code>java.util.function</code> . 函数式接口的作用是 Java8 对一类特定类型接口的称呼。这类接口只有一个抽象方法，并且使用  <code>@FunctionInterface</code>  注解进行注明。在 <code>Java Lambda</code>  的实现中， 开发组不想再为 <code>Lambda</code>  表达式单独定义一种特殊的 <code>Structural</code>  函数类型，称之为箭头类型（ <code>arrow type</code> ）， 依然想采用 Java 既有的类型系统 ( <code>class</code> ,  <code>interface</code> ,  <code>method</code>  等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的 <code>Java</code>  类型，并对成千上万的 <code>Java</code>  类库造成严重的影响。 权衡利弊， 因此最终还是利用 <code>SAM</code>  接口 ( <code>Single Abstract Method</code> ) 作为  <code>Lambda</code>  表达式的目标类型。</p>\n<p>函数式接口其实在 <code>Jdk8</code>  之前就已存在了，比如 <code>java.lang.Runnable</code> , <code>java.util.concurrent.Callable</code> , <code>java.util.Comparator</code>  等等。只是没有使用  <code>@FunctionInterface</code>  注解而已。在 <code>JDK1.8</code>  之后加上了这个注解，并且在 <code>java.util.function</code>  包下新增很多个函数式接口。 其中，我们需要知道的只有六个:</p>\n<ul>\n<li><code>Predicate</code> : 传入一个参数，返回一个 <code>bool</code>  结果， 方法为 <code>boolean test(T t)</code></li>\n<li><code>Consumer</code> : 传入一个参数，无返回值，纯消费。 方法为 <code>void accept(T t)</code></li>\n<li><code>Function&lt;T,R&gt;</code> : 传入一个参数，返回一个结果，方法为 <code>R apply(T t)</code></li>\n<li><code>Supplier</code> : 无参数传入，返回一个结果，方法为 <code>T get()</code></li>\n<li><code>UnaryOperator</code> : 一元操作符， 继承 <code>Function&lt;T,T&gt;</code> , 传入参数的类型和返回类型相同。</li>\n<li><code>BinaryOperator</code> : 二元操作符， 传入的两个参数的类型和返回类型相同， 继承 <code>BiFunction&lt;T,T,T&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>为什么要了解这个 函数式接口呢？</p>\n<p>因为 在 <code>Stream</code>  的方法中，大部分的参数都是使用 函数式接口 接受参数的。所以，如果要探究其实现原理和设计原则的话，这个是必须要知道的。</p>\n<blockquote>\n<p>注意:<br>\n <code>lambda</code>  表达式，是一种语法的表现形式，使代码表现更加整洁  <code>lambda</code>  和  <code>stream</code>  是两个不相关的概念。</p>\n</blockquote>\n<h2 id=\"查术理-查看源码明晰基本的类结构\"><a class=\"markdownIt-Anchor\" href=\"#查术理-查看源码明晰基本的类结构\">#</a> 查 &quot;术&quot; 理: (查看源码，明晰基本的类结构)</h2>\n<p>先来看下 和  <code>Stream</code>  直接相关的类。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E7%B1%BB%E5%9B%BE%E8%B0%B1.png\" alt=\"\"></p>\n<p><code>Stream</code>  接口继承了 <code>BaseStream</code>  接口.</p>\n<p><span class=\"label success\">✔️ BaseStream 接口表示流的基本接口，而流是支持顺序和并行聚合操作的元素序列。</span><br>\n <code>Stream</code>  接口有很多实现类。其主要的一个实现类是  <code>ReferencePipeline</code>  类。除此之外 <code>ReferencePipeline</code>  类还继承了 <code>AbstractPipeline</code>  抽象类. <span class=\"label success\">✔️ AbstractPipeline 表示 “管道” 类的抽象基类，它们是 Stream 接口及其原始特化的核心实现。</span>再看 <code>AbstractPipeline</code>  类的父类 <code>PipelineHelper</code> ,<span class=\"label success\">✔️ AbstractPipeline 的作用是：用于执行流管道的辅助类，将有关流管道的所有信息（输出形状、中间操作、流标志、并行度等）集中在一个地方。</span></p>\n<p><code>ReferencePipeline</code>  类有三个子类:  <code>StatefulOp</code>  表示有状态的操作， <code>StatelessOp</code>  表示无状态的操作，  <code>Head</code>  表示  <code>ReferencePipeline</code>  的起始阶段。 当然了，这三个子类也是 流。</p>\n<h3 id=\"从创建流开始\"><a class=\"markdownIt-Anchor\" href=\"#从创建流开始\">#</a> 从创建流开始</h3>\n<p>不管是使用  <code>Stream.of(T t)</code>  还是  <code>Collection.stream()</code> ，还是 <code>Arrays.stream()</code> , 底层的实现都是通过  <code>StreamSupport.stream()</code>  来实现的。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.of%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p><span class=\"label success\">✔️ StreamSupport 类的作用是：用于创建和操作流的底层实用方法。</span></p>\n<p><img data-src=\"/images/java/jdk/stream/StreamSupport.stream%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到 直接返回的是  <code>ReferencePipeline.Head</code>  对象。 首先  <code>Head</code>  是一种 <code>Stream</code>  的实现。 接着去看  <code>Head</code>  的构造方法，可以看到其实调用的是： <code>AbstractPipeline</code>  的构造方法.</p>\n<h3 id=\"流的中间操作\"><a class=\"markdownIt-Anchor\" href=\"#流的中间操作\">#</a> 流的中间操作</h3>\n<p>文中已经谈及了 中间操作分为有状态的中间操作和无状态的中间操作。那我们以一个案例来说明操作与操作之间执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">          .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">          .sorted((n1, n2) -&gt; n2 - n1)</span><br><span class=\"line\">          .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p><code>Stream.of()</code>  方法上文已经简单的说明了，接下来我们来看  <code>map()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到， <code>map()</code>  返回了一个 <code>StatelessOp</code>  对象，并且重写了 <code>AbstractPipeline</code>  的 <code>opWrapSink</code>  方法。 之前也说过：它表示流的无状态中间阶段的基类。 还有一个 <code>Sink</code>  类型.  <code>Sink</code>  类表示  <code>Consumer</code>  接口的扩展，用于在流管道的各个阶段传递值，以及管理大小信息、控制流等的附加方法。</p>\n<p>我们再仔细看一下这个方法。首先这个方法并没有进行任何的计算，只是将  <code>item -&gt; item + 5</code>  这个操作进行三层的封装， 1. 将 <code>map</code>  方法的返回值重新封装成了流对象，2. 把我们的 <code>item -&gt; item + 5</code>  这个操作封装成了  <code>StatelessOp</code> ， 并重写了 <code>opWrapSink</code>  这个方法，并在终止操作时进行调用。 3. 使用 <code>sink</code> ( <code>Sink.ChainedReference)</code>  将管道的各个阶段连接起来。即赋值 <code>downStream</code> . 使用 <code>downstream</code>  这个 <code>Consumer</code>  完成 <code>accept</code>  调用。</p>\n<p>这里需要注意一下:  <code>StatelessOp</code>  类的构造方法的实体参传输了一个  <code>this</code>  字段。仔细翻看源码就会返现它一直调用到  <code>AbstractPipeline</code>  的构造方法中。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.png\" alt=\"\"></p>\n<p>可以看到  <code>AbstractPipeline</code>  中有两个字段  <code>nextStage</code>  和  <code>previousStage</code>  字段，分别表示的是上一阶段和下一阶段。其中  <code>nextStage</code>  是 当前阶段。  <code>previousStage</code>  则应该 当前阶段的上一个阶段，其实就是调用当前方法的对象。</p>\n<p>不知道你是否发现 通过这种方法， <code>stream</code>  组成了一个 流各个阶段的双向链表。节点就是流操作的各个阶段。</p>\n<p>ps: 这样一次流操作会创建两个链表:  <code>Stream</code>  阶段的双向链表，和 在终止操作时，根据双向链表生成的  <code>Sink</code>  链表。</p>\n<p>再次说明：到目前为止， <code>map()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n<p>接着来看  <code>sorted()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/stream.sorted%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>sorted</code>  方法比较简单，通过调用 <code>SortedOps</code>  类的 <code>makeRef</code>  方法，创建了 <code>OfRef</code>  对象。  <code>OfRef</code>  类的作用是：用于对流进行排序的专用子类型。  <code>OfRef</code>  类继承了  <code>ReferencePipeline.StatefulOp</code>  ，所以 <code>OfRef</code>  是一个有状态操作。那自然它也会有  <code>opWrapSink</code>  方法。也就是说它也会返回一个 Sink 对象，只是这个 <code>Sink</code>  对象的实现类不一样的。</p>\n<blockquote>\n<p>说明：到目前为止， <code>sorted()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>同理去看 <code>limit</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.limit%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这个方法的内部是直接创建了一个  <code>ReferencePipeline.StatefulOp</code>  对象，也是重写了其中的方法:  <code>opWrapSink</code> .</p>\n<p>不知道你是否有好奇，我为什么每次都会提到  <code>opWrapSink</code>  这个方法呢？因为这个方法非常的重要！其重要性我们在 <a href=\"#%E6%8E%A2%E2%80%9D%E6%B3%95%E2%80%9C%E6%8B%A9\">探” 法 “择</a> 这部分会完整的说明。</p>\n<blockquote>\n<p>再三说明：到目前为止， <code>limit()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>书行至此，案例中的中间操作都已经简单的分析完成了。我们就知道这里  <code>jdk</code>  为了完成 流操作为每个中间操作都封装了很多的对象，而这些对象只是散列在了内存中。接下来，就要看  <code>jdk</code>  是如何把他们组装到一起的。</p>\n<h3 id=\"终止操作\"><a class=\"markdownIt-Anchor\" href=\"#终止操作\">#</a> 终止操作</h3>\n<p>以 <code>Collect</code>  方法为例，去探究一下终止操作的流程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.collect%E6%96%B9%E6%B3%95.png\" alt=\"\"><br>\n可以看到在 <code>collect</code>  方法中，分为并行执行方式和串行执行方法，我们看串行执行时，会创建  <code>ReduceOps</code>  终止操作对象。<br>\n<img data-src=\"/images/java/jdk/stream/AbstractPipeline.evaluate%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>将 终止操作 传递给 evaluate 方法，然后调用终止操作的 evaluate 方法，当然这个方法也分成了串行执行和并行执行两种。</p>\n<p><img data-src=\"/images/java/jdk/stream/ReduceOps.evaluateSequential%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>helper</code>  其实是  <code>limit(3)</code>  中间操作返回的对象。这其实中间操作的最后一个 <code>Stage</code>  (阶段)。返回的对象是 <code>AbstractPipeline</code>  和  <code>Stream</code>  的子类实例。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapAndCopyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这里包含两个方法:  <code>wrapSink()</code>  和  <code>copyInfo()</code> .</p>\n<p>这是两个非常重要的方法.  <code>wrapSink()</code>  是将中间的操作组成  <code>SinkChain</code>  。  <code>copyInfo()</code>  这是执行真正的计算逻辑。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapSink%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>方法中的形参  <code>sink</code>  就是最后的阶段的终止操作。方法通过循环将  <code>sink</code>  分装到 <code>Sink</code>  中。  <code>Sink</code>  接口 的一个实现类是  <code>ChainedReference</code>  ， 类中定义了一个  <code>downStream</code>  字段。 会将 <code>sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</code>   中的  <code>sink</code>  赋值给  <code>downStream</code> . 这样就形成了 <b>套娃</b>。 最后返回一个  <code>wrapSink</code>  , 即整个流操作中所有的操作的 封装 <code>Sink</code> .</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.copyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>图中所示的即为上面提及的 封装 <code>Sink</code> . 可中断和不可中断的区别是：可中断如果获取值，就不必再取所有的结果了。反之，就需要计算出所有阶段的结果。</p>\n<p>非可中断的终止操作时，会执行  <code>begin()</code> , <code>forEachRemaining()</code> , <code>end()</code> , 三个方法。  这个三个方法对应的是： <code>Sink</code>  接口中提供的三个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Sink开始之前调用该方法，通知sink做好准备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历元素时使用，接受一个待处理元素，并对元素进行处理。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Double i)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 通知sink没有元素进行处理了。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，</p>\n<ul>\n<li><code>begin()</code>  方法，会调用每个 <code>Sink</code>  子类的 <code>begin</code>  方法。</li>\n<li><code>forEachRemaining()</code>  方法对应的执行内容如下图:<br>\n<img data-src=\"/images/java/jdk/stream/forEachRemaining%E6%96%B9%E6%B3%95.png\" alt=\"\"></li>\n<li><code>end()</code>  方法，会调用每个 <code>Sink</code>  字段的 <code>end</code>  方法。</li>\n</ul>\n<p>书行至此。或许你会对  <code>forEachRemaining</code>  方法感到好奇。后面我会写一篇文章来专门分享: 《 <code>Stream</code>  的高级迭代器》, 希望你能继续关注支持我～</p>\n<h2 id=\"探法择\"><a class=\"markdownIt-Anchor\" href=\"#探法择\">#</a> 探” 法 “择</h2>\n<p>我们从一个案例出发，在细节之处分析了一个 <code>Stream</code>  的执行过程。现在我们需要从全局来看一下  <code>Stream</code>  的执行过程是什么样子的.</p>\n<p>上文中我们知道了  <code>Stream</code>  的 所有计算都是在 终止操作时 触发的。 所有的中间操作都是封装了一些对象。我们用一张图来描述下 <code>Stream</code>  的执行过程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"\"></p>\n<ul>\n<li><code>stream</code>  将创建的流做为第一个  <code>Stage</code>  , 用来代表流的开始， 每个 <code>Stage</code>  都是 <code>AbstractPipeline</code>  的子类。 第一个 <code>Stage</code>  是 <code>AbstractPipeline.Head</code>  对象。</li>\n<li>然后将中间操作封装成后面的 n 个  <code>stage</code> . 并组成 双向链表的形式，并且存储了 <code>stage0</code> . 每个 <code>Stage</code>  都是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .</li>\n<li>终止操作通过 <code>wrapSink()</code>  方法 会触发将 每个阶段的操作封装成  <code>Sink</code> . 并且 <code>sink</code>  都会做为参数传递到上一个阶段的 <code>opWrapSink()</code>  方法中，从而组成一个  <code>sink</code>  链表。</li>\n<li>然后，通过  <code>copyInfo()</code>  方法将，交于 <code>Spilterator</code>  进行迭代。计算的结果可以分为四种\n<ul>\n<li>返回 <code>boolean</code>  类型的结果：比如 <code>anyMatch()</code>   <code>allMatch()</code>   <code>noneMatch()</code>  方法。</li>\n<li>返回 <code>Optional</code>  类型的结果： 比如 <code>findFirst()</code>   <code>findAny()</code>  方法</li>\n<li>还有归约操作:\t <code>reduce()</code>   <code>collect()</code></li>\n<li>返回数组的： <code>toArray()</code> <br>\n 对于表中返回 <code>boolean</code>  或者 <code>Optional</code>  的操作（ <code>Optional</code>  是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 <code>Sink</code>  中记录这个值，等到执行结束时返回就可以了。<br>\n对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。 <code>collect()</code> ,  <code>reduce()</code> ,  <code>max()</code> ,  <code>min()</code>  都是归约操作，虽然 <code>max()</code>  和 <code>min()</code>  也是返回一个 <code>Optional</code> ，但事实上底层是通过调用 <code>reduce()</code>  方法实现的。<br>\n对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做 <code>Node</code>  的数据结构中的。 <code>Node</code>  是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于  <code>Stream</code>  的并行计算，我后面会继续分享。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"明道义\"><a class=\"markdownIt-Anchor\" href=\"#明道义\">#</a> 明 &quot;道&quot; 义</h2>\n<p><code>JDK</code>  提供的  <code>Stream</code>  具有如下特点:</p>\n<ul>\n<li>无存储。 <code>stream</code>  不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组， <code>Java</code>  容器或 <code>I/O channel</code>  等。</li>\n<li>为函数式编程而生。对 <code>stream</code>  的任何修改都不会修改背后的数据源，比如对 <code>stream</code>  执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新 <code>stream</code> 。</li>\n<li>惰式执行。 <code>stream</code>  上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li>可消费性。 <code>stream</code>  只能被 “消费” 一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n<blockquote>\n<p>在这一趴，我就围绕两个点来简单的聊聊。</p>\n</blockquote>\n<ul>\n<li><code>JDK8</code>  为什么要加入  <code>Stream</code> .</li>\n</ul>\n<p>除了上面四个特点之外， <code>Java8</code>  中的 <code>Stream</code>  是对集合对象的增强，当然不仅仅是集合对象。 <code>Stream</code>  为开发者提供了简洁的编码方式和编码风格，极大的提高了开发的效率。</p>\n<p>另外一个更重要的点在于  <code>Stream</code>  为我们下篇文章要分享的 <b> <code>Stream</code>  并行计算流</b> 提供了实现，请期待。</p>\n<ul>\n<li><code>Stream</code>  为什么要这么设计？</li>\n</ul>\n<p>我这里给一份我的回答，这个问题也留给看文章的你，也希望能看到你的回答。</p>\n<p>根据上文所说的内容， <code>Stream</code>  体系是一组接口家族， <code>AbstractPipeline </code> 是接口的实现， <code>PipelineHelper</code>  是管道的辅助类， <code>StreamSupport</code>  是流的底层工具类</p>\n<p><code>Stream</code>  使用 <code>stage</code>  来抽象流水线上的每个操作，其实每个 <code>stage</code>  就是一个 <code>stream</code>  子类的实例， 也就是 <code>AbstractPipeline</code>  几个子类的内部子类即 <code>Head</code>   <code>StatelessOp</code>   <code>statefulOp</code> ;</p>\n<p><code>StreamSupport</code>  用于创建生成 <code>Stream</code>  对应的是 <code>Head</code>  类，其他的中间操作分为有状态和无状态的，中间操作通过方法比如  <code>filter</code>   <code>map</code>  等返回的是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .  多个 <code>stage</code>  组合称为双向链表的形式 从而成了整个流水线</p>\n<p>有了流水线，相邻两个操作阶段之间如何协调运算？</p>\n<p>于是又有了 <code>Sink</code>  的概念，又来协调相邻的 <code>stage</code>  之间计算运行</p>\n<p>他的模式是 <code>begin</code>    <code>accept</code>   <code>end</code>  还有短路标记</p>\n<p>他的 <code>accept</code>  就是封装了回调方法，所以说每个操作 <code>stage</code> ,  <code>StatelessOp</code>   或者  <code>statefulOp</code>  中又封装了 <code>Sink</code> . 通过 <code>AbstractPipeline</code>  提供的 <code>opWrapSink</code>  方法可以获取这个 <code>Sink</code></p>\n<p>调用这个 <code>sink</code>  的 <code>accept</code>  方法就可以调用当前操作的方法</p>\n<p>那么如何串联起来呢？</p>\n<p>关键点在于 <code>opWrapSink</code>  方法，他接收一个 <code>Sink</code>  作为参数，在调用 <code>accept</code>  方法中。可以调用这个入参 <code>Sink</code>  的 <code>accept</code>  方法</p>\n<p>这样子从当前就能调用下一个，也就是说有了推动的动作。那么只需要找到开始，每个处理了之后都推动下一个，就顺序完成了所欲的操作了。</p>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\">#</a> 结语</h2>\n<p>通过看  <code>Stream</code>  相关的知识点，发现一篇文章是没法讲清楚的。</p>\n<p>这一次，我又果不其然的留下了两篇文章</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\"><label for=\"cbx_0\">  <code>Stream</code>  并行计算流</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\"><label for=\"cbx_1\">  <code>Stream</code>  的高级迭代器</label></li>\n</ul>\n<p>请给我记代办～</p>\n<p>在分享 <code>并行计算流</code> 的时候，我们需要以  <code>JDK1.7</code>  中的  <code>forkJoin</code>  框架为前提，来分析  <code>Stream</code>  的  <code>parallelStream</code> .</p>\n<p>在分享 <code>迭代器</code> 的时候，我们也会分析一下 <code>JDK</code>  中提供的 普通迭代器，比如  <code>ForEach</code> ,  <code>iterator</code> , 以及 <code>Stream</code>  的高级迭代器  <code>spliterator</code> . 也会由浅入深的分析一下，各种迭代器的优缺点。 也会自定义实现一个迭代器。</p>\n<p>敬请期待，防止走丢见文末。关注我，期望和你一起遇见更好的自己.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/java/jdk/stream/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "Java",
                "JDK",
                "Stream"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/String/String/",
            "url": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/String/String/",
            "title": "String类源码解析",
            "date_published": "2021-07-15T06:48:55.000Z",
            "content_html": "<p>一、签名：</p>\n<p><code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</code></p>\n<ul>\n<li>String 不能被继承，</li>\n<li>实现了 Serializable：可被序列化。</li>\n<li>实现了 Comparable：可以比较，排序，</li>\n<li>实现了 CharSequence：值是可读序列。</li>\n</ul>\n<p>二、成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];  <span class=\"comment\">// 存储字符。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash;     <span class=\"comment\">// 缓存字符串的hash值。</span></span><br><span class=\"line\">Private <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectStreamField[] serialPersistentFields = <span class=\"keyword\">new</span> ObjectStreamFiled[<span class=\"number\">0</span>];  <span class=\"comment\">// 字符串类被指定转化序列化流协议中。</span></span><br><span class=\"line\"><span class=\"comment\">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">6849794470754667710L</span>;</span><br></pre></td></tr></table></figure>\n<p><code>Value</code>  是 <code>final</code>  的，所以 <code>String</code>  一旦定义之后，就不可变的。</p>\n<p>三、构造函数：</p>\n<p>四、常用方法：</p>\n<p>由于 String 中重载的方法太多了，所以就只写方法名了。</p>\n<p>1.   <code>getBytes</code> :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] getBytes() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> StringCoding.encode(value, <span class=\"number\">0</span>, value.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上面的这个方法为例：它交给了 <code>StringCoding.encode</code>  去获取 <code>bytes</code> 。然而 <code>StringEncoder</code>  去调用了 <code>StringEncoder</code>  的相应方法获取 <code>bytes</code> 、</p>\n<p>2.  equals</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;   <span class=\"comment\">// 如果地址都相同的话，那肯定就是同一个了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">//不错的编码风格。比for要好一点？</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>3.  equalsIgnoreCase:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equalsIgnoreCase</span><span class=\"params\">(String anotherString)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == anotherString) ? <span class=\"keyword\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">          : (anotherString != <span class=\"keyword\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">          &amp;&amp; (anotherString.value.length == value.length)</span><br><span class=\"line\"></span><br><span class=\"line\">          &amp;&amp; regionMatches(<span class=\"keyword\">true</span>, <span class=\"number\">0</span>, anotherString, <span class=\"number\">0</span>, value.length);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">regionMatches</span><span class=\"params\">(<span class=\"keyword\">boolean</span> ignoreCase, <span class=\"keyword\">int</span> toffset,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            String other, <span class=\"keyword\">int</span> ooffset, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> ta[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = toffset;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> pa[] = other.value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> po = ooffset;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ooffset &lt; <span class=\"number\">0</span>) || (toffset &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">                || (toffset &gt; (<span class=\"keyword\">long</span>)value.length - len)</span><br><span class=\"line\"></span><br><span class=\"line\">                || (ooffset &gt; (<span class=\"keyword\">long</span>)other.value.length - len)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">char</span> c1 = ta[to++];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">char</span> c2 = pa[po++];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c1 == c2) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ignoreCase) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// If characters don&#x27;t match but case may be ignored,</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// try converting both characters to uppercase.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// If the results match, then the comparison scan should</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// continue.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">char</span> u1 = Character.toUpperCase(c1);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">char</span> u2 = Character.toUpperCase(c2);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (u1 == u2) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// conversion.  So we need to make one last check before</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// exiting.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 regionMatches 中首先对传入的参数，进行合法性判断。然后取出每一个字符，比较一下，相同就下个字符，不同，都转换成大写，比较一次，如果相同就比较下一个字符，如果不相同就都转化成小写在比较一下。解释是说：有时候，转大写不一定每次都会正确。</p>\n<p>4.  startsWith:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix, <span class=\"keyword\">int</span> toffset)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> ta[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = toffset;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">char</span> pa[] = prefix.value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> po = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pc = prefix.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((toffset &lt; <span class=\"number\">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (--pc &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>5.  endsWith</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">endsWith</span><span class=\"params\">(String suffix)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6.  重点来了：hashCode</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = hash;  <span class=\"comment\">///先获取缓存中的hash值。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">               h = <span class=\"number\">31</span> * h + val[i];   <span class=\"comment\">// hash值算法。31</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hash = h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>7.  replace</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">char</span> oldChar, <span class=\"keyword\">char</span> newChar)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldChar != newChar) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = value.length;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">char</span>[] val = value; <span class=\"comment\">/* avoid getfield opcode */</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++i &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val[i] == oldChar) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> buf[] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[len];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                    buf[j] = val[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; len) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> c = val[i];</span><br><span class=\"line\">                    buf[i] = (c == oldChar) ? newChar : c;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(buf, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h3>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "源码",
                "String",
                "JDK",
                "JDK8"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap%E7%9A%84Hash%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/",
            "url": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap%E7%9A%84Hash%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/",
            "title": "HashMap的Hash函数到底有什么意义",
            "date_published": "2021-07-15T06:48:55.000Z",
            "content_html": "<h2 id=\"jdk18-hashmap中hash值计算源码\"><a class=\"markdownIt-Anchor\" href=\"#jdk18-hashmap中hash值计算源码\">#</a> jdk1.8 HashMap 中 hash 值计算源码</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 扰动函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中的key.hashCode调用的是底层的native方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Q: 为什么不直接使用 key 的 hashCode 值呢？</li>\n</ul>\n<p>如果直接使用 key 的 hashCode () 函数的时候，将 hash 值作下标访问 Map 的数组的话，由于 2 进制的取值范围是 [-2<sup>31,2</sup>31), 加起来大于有 40 亿的映射空间。只要 hash 函数散列的比较松散，那么久很难出现碰撞。当然，40 亿的数据，内存也是放不下的。所以不能直接拿 key 的 hashCode。</p>\n<ul>\n<li>Q: 为什么要进行  <code>h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>  这个运算呢？</li>\n</ul>\n<p>这个问题就要从计算出的 hash 值的作用上来切入了，hashMap 计算这个 hash 值就是为了什么？增删改查的时候确定元素在数组中的位置。那么 hashMap 是怎么确定位置的呢？我们知道 HashMap 中的数组是 tab 字段。根据 tab 找到，在 <code>final HashMap.Node&lt;K,V&gt; getNode(int hash, Object key)</code>  方法中，有这么 <code>tab[(n - 1) &amp; hash]</code>  使用。 n 是数组的长度.<br>\n 这里 n-1 相当于一个 <code>低位掩码</code> ，和 hash 进行与操作的结果就是散列值的高位全部归零，保留低位，用来做下标访问。这么看，就算我们的 hash 散列分布再松散，冲突也会很严重。以默认长度 16 为例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  11111111  11111111 11110000 11101010  # native方法 HashCode()</span><br><span class=\"line\">&amp; 00000000  00000000 00000000 00001111  # 默认初始长度 15 = 16 -1</span><br><span class=\"line\">  -------------------------------------</span><br><span class=\"line\">  00000000  00000000 00000000 00001010  # 进行&amp;操作，计算出的下标为10</span><br></pre></td></tr></table></figure>\n<p>我们看下使用扰动函数计算后的结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 扰动函数计算过程:</span><br><span class=\"line\">   h=hashCode():  11111111  11111111  11110000  11101010  # native方法 HashCode()</span><br><span class=\"line\">   -------------------------------------------------------------------------------</span><br><span class=\"line\">              h:  11111111  11111111  11110000  11101010  # native方法 HashCode()计算出的值。</span><br><span class=\"line\">   ^     h&gt;&gt;&gt;16:  00000000  00000000  11111111  11111111  # hashCode左移16位=&gt;高16位变低位</span><br><span class=\"line\">   -----------------------------------------------------------------------------------</span><br><span class=\"line\">hash=h^(h&gt;&gt;&gt;16):  11111111  11111111  00001111  00010101  # 扰动函数计算出的值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 与掩码做&amp;运算=&gt;计算数组下标</span><br><span class=\"line\">hash=h^(h&gt;&gt;&gt;16):  11111111  11111111  00001111  00010101  # 扰动函数计算出的值</span><br><span class=\"line\">            &amp;  :  00000000  00000000  00000000  00001111  # 低位掩码=&gt; hashMap中数组的长度</span><br><span class=\"line\">    -----------------------------------------------------------------------------------</span><br><span class=\"line\">                             ....                  00101  # =&gt;计算出的下标为5.</span><br></pre></td></tr></table></figure>\n<h3 id=\"peter-lawley的一篇专栏文章an-introduction-to-optimising-a-hashing-strategy里的的一个实验\"><a class=\"markdownIt-Anchor\" href=\"#peter-lawley的一篇专栏文章an-introduction-to-optimising-a-hashing-strategy里的的一个实验\">#</a> Peter Lawley 的一篇专栏文章《An introduction to optimising a hashing strategy》里的的一个实验</h3>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/hashMap%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8.png\" alt=\"hashMap扰动函数的作用.png\"></p>\n<p>结果显示，当 HashMap 数组长度为 512 的时候，也就是用掩码取低 9 位的时候，在没有扰动函数的情况下，发生了 103 次碰撞，接近 30%。而在使用了扰动函数之后只有 92 次碰撞。碰撞减少了将近 10%。看来扰动函数确实还是有功效的。</p>\n<h2 id=\"jdk7中的hashmap计算hash的方式\"><a class=\"markdownIt-Anchor\" href=\"#jdk7中的hashmap计算hash的方式\">#</a> JDK7 中的 HashMap 计算 hash 的方式</h2>\n<h2 id=\"参考文章\"><a class=\"markdownIt-Anchor\" href=\"#参考文章\">#</a> 参考文章</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhlbmd3YW5nL3AvODEzNjE2NC5odG1s\">HashMap 中的 hash 函数</span></p>\n<h3 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h3>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "源码",
                "JDK",
                "JDK8",
                "HashMap"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/",
            "url": "https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/",
            "title": "全网最全的 HashMap 源码解读",
            "date_published": "2021-07-15T06:48:55.000Z",
            "content_html": "<h2 id=\"要思考的问题\"><a class=\"markdownIt-Anchor\" href=\"#要思考的问题\">#</a> 要思考的问题</h2>\n<ul>\n<li>HashMap 的底层数据结构 (节点结构，这种结构有什么优点)</li>\n<li>如何处理 hash 冲突</li>\n<li>怎么扩容？扩展机制是什么？</li>\n<li>增删改查过程</li>\n<li>链表到红黑树的转换过程，反之？</li>\n<li>红黑树相关 (见另一篇数据结构之红黑树)</li>\n<li>hash 计算</li>\n</ul>\n<h2 id=\"达到的目标\"><a class=\"markdownIt-Anchor\" href=\"#达到的目标\">#</a> 达到的目标</h2>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"><label for=\"cbx_0\"> 掌握底层数据结构</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\"><label for=\"cbx_1\"> 掌握扩容原理</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\"><label for=\"cbx_2\"> 掌握 hash 冲突的处理过程</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\"><label for=\"cbx_3\"> 掌握增删改查过程</label></li>\n</ul>\n<h2 id=\"看之前要掌握的知识点\"><a class=\"markdownIt-Anchor\" href=\"#看之前要掌握的知识点\">#</a> 看之前要掌握的知识点</h2>\n<h3 id=\"红黑树\"><a class=\"markdownIt-Anchor\" href=\"#红黑树\">#</a> 红黑树</h3>\n<h2 id=\"看之前大体了解的知识点\"><a class=\"markdownIt-Anchor\" href=\"#看之前大体了解的知识点\">#</a> 看之前大体了解的知识点</h2>\n<h3 id=\"hash算法\"><a class=\"markdownIt-Anchor\" href=\"#hash算法\">#</a> hash 算法</h3>\n<h3 id=\"poisson分布\"><a class=\"markdownIt-Anchor\" href=\"#poisson分布\">#</a> Poisson 分布</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2lzc29uX2Rpc3RyaWJ1dGlvbg==\">poisson 分布</span></p>\n<h2 id=\"开始\"><a class=\"markdownIt-Anchor\" href=\"#开始\">#</a> 开始</h2>\n<h3 id=\"hashmap的继承体系\"><a class=\"markdownIt-Anchor\" href=\"#hashmap的继承体系\">#</a> HashMap 的继承体系</h3>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/HashMap01-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png\" alt=\"HashMap01-继承体系.png\"></p>\n<ul>\n<li>AbstractMap: map 的抽象类，以最大限度的减少实现 Map 接口的类的工作量。</li>\n</ul>\n<h3 id=\"hashmap结构\"><a class=\"markdownIt-Anchor\" href=\"#hashmap结构\">#</a> hashMap 结构</h3>\n<h3 id=\"字段解释\"><a class=\"markdownIt-Anchor\" href=\"#字段解释\">#</a> 字段解释</h3>\n<h4 id=\"常量字段默认值字段\"><a class=\"markdownIt-Anchor\" href=\"#常量字段默认值字段\">#</a> 常量字段 (默认值字段)</h4>\n<ul>\n<li>DEFAULT_INITIAL_CAPACITY=1&lt;&lt;4: 默认的初始容量，默认是为 16, 必须是 2 的 n 次方。为什么呢？见扩容的方法。</li>\n<li>DEFAULT_LOAD_FACTOR=0.75f: 默认的负载因子。它和哈希表的容量的乘积是决定是否重新 hash 的阈值。</li>\n<li>TREEIFY_THRESHOLD=8: 使用树而不是链表的计数阈值。当桶的元素添加到具有至少这么多节点时，桶被转换为树。</li>\n<li>UNTREEIFY_THRESHOLD=6: 用于在调整大小操作期间解除（拆分）桶的桶计数阈值。(untreeifying 不是一个英语单词，这里的以是非树化，即转换成普通列表的过程). 也就是说从树转换成普通的桶 (链表) 的阈值。</li>\n<li>MAXIMUM_CAPACITY=1&lt;&lt;30: 最大的容量:  <code>1&lt;&lt;30</code> ，如果具有参数的任一构造函数隐式指定更高的值，则使用此参数。必须是 2 的 n 次方，小于等于 <code>1&lt;&lt;30</code></li>\n<li>MIN_TREEIFY_CAPACITY=64: 容器可以树化的最小容量 (否则，如果 bin 中的节点太多，则会调整表的大小.) 应该至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突.</li>\n</ul>\n<h4 id=\"类属性\"><a class=\"markdownIt-Anchor\" href=\"#类属性\">#</a> 类属性</h4>\n<ul>\n<li>table:  <code>transient HashMap.Node&lt;K,V&gt;[] table</code> ; table 在首次使用时初始化，并根据需要调整大小。分配时，长度始终是 2 的幂。(我们还在一些操作中容忍长度为零，以允许当前不需要的自举机制)</li>\n<li>entrySet:  <code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code> ; 保存缓存的 entrySet.</li>\n<li>size:  <code>transient int size</code> ; map 中元素的数量。结构修改是那些改变 HashMap 中映射数量或以其他方式修改其内部结构（例如，rehash）的修改。此字段用于在 HashMap 的 Collection-views 上快速生成迭代器 (见 ConcurrentModificationException)</li>\n</ul>\n<hr>\n<p>注意：这些字段都是  <code>transient</code>  的？为什么呢？</p>\n<ul>\n<li>loadFactor:  <code>final float loadFactor;</code>  hash 表的负载因子，在实例化 hashTable 的时候指定，该对象内不能变更 (final);</li>\n<li>threshold:  <code>int threshold;</code> , 下一次调整容器大小的阈值. threshold=capacity * load factor</li>\n</ul>\n<h4 id=\"hashmap的两种节点\"><a class=\"markdownIt-Anchor\" href=\"#hashmap的两种节点\">#</a> HashMap 的两种节点</h4>\n<ul>\n<li>基本的哈希桶的节点 (链表的结点) Node</li>\n</ul>\n<p><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</code>  它继承了 Map 的 Entry, 是对子类的行为规范。要求提供了 getKey (),getValue () 等常用方法。</p>\n<p>链表节点的结构如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 避免重复计算key的hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个节点的指针</span></span><br><span class=\"line\">    HashMap.Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, HashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">&quot;=&quot;</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// todo 没有找到在哪里使用了这个方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                    Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Tree 的节点 TreeNode</li>\n</ul>\n<p><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;</code>  继承了其子类的 Entry, 子类的 Entry 继承了父类的 Node. 注意了，这里乍一看还挺乱。来张图吧。<br>\n<img data-src=\"/images/JavaSourceCode/HashMap/hashMap%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%BE.png\" alt=\"hashMap的节点的继承图.png\"></p>\n<p>这里呢，TreeNode 其实是 Node 的孙子，也就是说 HashMap 的树节点是链表节点的孙子辈儿的。<br>\n为什么要使两种节点有继承关系呢？为什么 TreeNode 不直接继承 Node 节点呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    HashMap.TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, HashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hashmap增加方法-hashmapput\"><a class=\"markdownIt-Anchor\" href=\"#hashmap增加方法-hashmapput\">#</a> HashMap 增加方法 HashMap#put ()</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  将指定的value和key关联在map中。</span></span><br><span class=\"line\"><span class=\"comment\">*  如果map中已经存在了key,那么将会替换掉老的value。</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> key key 指定的key</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> value value 和指定key关联的value</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> 如果返回了value，就说明map中原来和key关联是有值的。如果返回null就说明没有value。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就比较有看点了，1. 这里是 hashMap 的增加方法，增加方法里必然会遇到 hash 冲突的问题，我们等会看下 hash 冲突是如何处理的，还会涉及到扩容的问题，我们也要来看看他是怎么扩容的，扩容的过程中还会遇到普通的桶转换成树的过程。我们先来看下 hash 值是怎么计算出来的。</p>\n<ul>\n<li TODO=\"\" 和jdk1.7中的比较=\"\"><code>hash</code>  值的计算</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算key的hashCode并且和hashCode值高16位进行异或运算。(异或: 相同为0，不同为1)</span></span><br><span class=\"line\"><span class=\"comment\"> * 混和低位和高位，就是为了加大低位的随机性,而且混合后的低位掺杂了高位的部分特征,</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样高位的信息也被变相的保留了下来。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么这么做呢？见<a href=\"/2021/07/15/source%20code/HashMap/HashMap%E7%9A%84Hash%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/\"> HashMap 的 Hash 函数到底有什么意义</a></p>\n<ul>\n<li>那我们接下接着看 <code>putVal()</code>  方法。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Map.put相关的方法。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> *                     如果是true的,不会修改存在的值。返回老的值。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> *              如果为false的时候,表属于创建模式,第一次新增元素的时候。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    HashMap.Node&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    HashMap.Node&lt;K,V&gt; p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果数组为null,或者数组长度为0的时候，数组需要调整大小。</span></span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 定位到数组的桶为null的时候,创建桶内的第一个元素。next=null;</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果桶不为null，则创建链表</span></span><br><span class=\"line\">        HashMap.Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// p表示当前桶的第一个元素。</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果新增的元素和第一个元素相等的话(出现hash冲突),暂存已经存在的元素到变量e中。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> HashMap.TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 如果是树节点。</span></span><br><span class=\"line\">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 链表元素新增的过程了。</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>)</span><br><span class=\"line\">                        <span class=\"comment\">// 如果桶内的元素数量达到树化的阈值,将链表转换成树。</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 如果第一个元素和要新增的元素hash,key都相等的话,直接进行新增操作。</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果原来的元素不为空,保留原来的值。</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 覆盖掉原来的value;</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 留一个无方法体的方法，供子类扩展</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// failFast计数</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        <span class=\"comment\">// 如果table中的桶的数量超过了阈值。扩容。</span></span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 供子类扩展的方法。</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码里中有三处重要的地方， <code>resize()</code> , <code>treeifyBin()</code> , <code>putTreeNode()</code> , 接下来我们依次看下这三个方法。</p>\n<h4 id=\"resize\"><a class=\"markdownIt-Anchor\" href=\"#resize\">#</a> resize</h4>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化，或者加倍表格的大小</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果为null时候，根据字段threshold的初始容量进行分配</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则，因为我们正在使用二次幂扩展，所以每个bin中的元素必须保持相同的索引，或者在新表中以两个偏移的幂移动</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table 新的表</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HashMap.Node&lt;K, V&gt;[] resize() &#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果旧表的大小大于0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hash表达到最大容量</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果翻倍后旧表大小&lt;最大表长度，并且旧表长度&gt;默认初始化长度。</span></span><br><span class=\"line\">            <span class=\"comment\">// 扩容的阈值也翻倍。 还是等级 table.length*loadFactor</span></span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        <span class=\"comment\">// 旧表长度&lt;=0,旧的threshold&gt;0,</span></span><br><span class=\"line\">        <span class=\"comment\">// 就把threshold设置为表长度。</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置为默认值。</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果新的扩缩容阈值等于0,设置新的扩缩容阈值为新的容量*负载因子.</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>) newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>) MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                (<span class=\"keyword\">int</span>) ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重新创建新的hash表</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] newTab = (HashMap.Node&lt;K, V&gt;[]) <span class=\"keyword\">new</span> HashMap.Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"comment\">// 如果旧表不为空,进行扩容.</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则(旧表为空)就进行初始化过程.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            HashMap.Node&lt;K, V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果当前桶只有一个节点。</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果当前桶是棵红黑树</span></span><br><span class=\"line\">                    ((HashMap.TreeNode&lt;K, V&gt;) e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// 桶是链表,将该桶内的元素重新分配到表中。</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    HashMap.Node&lt;K, V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    HashMap.Node&lt;K, V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    HashMap.Node&lt;K, V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 遍历桶内的元素，将元素重新分配到hash表内的各个桶中。</span></span><br><span class=\"line\">                    <span class=\"comment\">// 具体的实现过程是: 将当前的元素的hash值和容量取&amp;,如果&gt;0,那就说明该元素应该分配到新的桶内。</span></span><br><span class=\"line\">                    <span class=\"comment\">// 桶的位置就是: oldCap+j.即桶原来容器+该元素所在的桶的下标。(hiHead所标识的位置)</span></span><br><span class=\"line\">                    <span class=\"comment\">// 反之如果hash值是==0的,那么该元素就应该还在当前桶内。(loHead所标识的位置)</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里所说的位置都是指桶的下标,整个表都是新的了,位置肯定都变了。</span></span><br><span class=\"line\">                    <span class=\"comment\">// 为什么可以这么实现呢？</span></span><br><span class=\"line\">                    <span class=\"comment\">// 因为扩容的时候，使用的是原来容量的2倍进行扩容的。所以就可以使用(oldCap+j)的方式来确定元素的新位置了。</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 还在原桶中</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 位置最后一个节点为空,使用e=next的时候，next为null的情况。</span></span><br><span class=\"line\">                                <span class=\"comment\">// 在桶内元素遍历完成后,会把桶的最后一个元素的next置为null。</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 放置到新的桶内。</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// 位置最后一个节点为空,使用e=next的时候，next为null的情况。</span></span><br><span class=\"line\">                                <span class=\"comment\">// 在桶内元素遍历完成后,会把桶的最后一个元素的next置为null。</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 原来桶的位置。</span></span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 确定新桶的位置</span></span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一个散列还算非常均匀的例子来看扩容过程。</p>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/hashMap04-Put%E6%96%B9%E6%B3%95%E8%BF%87%E7%A8%8B01.png\" alt=\"hashMap04-Put方法过程01.png\"></p>\n<p>那么进行扩容的过程是怎么样的呢？</p>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/hashMap05-resize%E6%96%B9%E6%B3%9501.png\" alt=\"hashMap05-resize方法01.png\"></p>\n<p>以元素 1 和 12 为例，看扩容过程:<br>\n 元素 1 的 hash 值为 49.(以 hashMap 计算 hash 值的方式得出。)， 与 15 取 &amp; 计算桶的下标为 1, 扩容后，与 31 取 &amp;, 计算桶的下标为 17. 所以扩容前位置是 0，扩容后元素 1 的存放位置是 17。<br>\n代码中是怎么完成这个过程的呢？<br>\n和扩容前 hash 表的容量取 &amp;, 得  <code>49 &amp; 16 = 16 &gt; 0</code>  (代码第 86-96 行), 新的桶的头节点 (对应代码里的 hiHead) 就是当前节点 1，尾节点 (hiTail) 赋为当前节点。然后进行下一次 <code>do...while</code>  循环，处理节点 12, 计算出节点 12 的 hash 值为 <code>1569</code> , 进行计算 <code>1569 &amp; 16 = 0 == 0</code>  原来桶的头结点是节点 12, 尾节点也是节点 12 (对应着代码第 76-86 行), 这样 hitail 和 loTail 均不为 null, 所以然后直接使用 <code>newTab[j] = loHead;</code>  和  <code>newTab[j + oldCap] = hiHead;</code>  的方式确定桶的位置。这个案例里，处理完节点 12 才会确定桶的位置。因为原来的表中下标为 1 的桶中有两个元素 1 和 12. 那桶里只有一个元素的怎么处理的呢？ <code>newTab[e.hash &amp; (newCap - 1)] = e;</code>  e 是当前节点，newCap 是新表的容量。</p>\n<blockquote>\n<p>如果你想问为什么能使用   <code>hash &amp; olcCap==0?</code>  来决定是 <code>newTab[j]</code>  还是  <code>newTab[j+oldCap]</code>  这种方式来确定新的桶的下标的话。 那么原因就是扩容使用的是 2 次幂的方式，容量是原来容量的 2 倍。所以就可以使用  <code>hash &amp; olcCap==0?</code>  来判断了。</p>\n</blockquote>\n<p>这个例子呢，演示了扩容过程中的链表的新增和扩容过程。再回头看 resize 方法，还有一种情况我们没有分析过。那就是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前桶是棵红黑树</span></span><br><span class=\"line\">    ((HashMap.TreeNode&lt;K, V&gt;) e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 将原来树桶中的节点拆分为更低或更高的树桶,如果太小的话就转化成链表</span></span><br><span class=\"line\"><span class=\"comment\">    * 只被resize方法调用</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> map   hash表</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> tab   表中的指定的桶的头结点(桶是一个棵树)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> index 要拆分的hash表的节点</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> bit   the bit of hash to split on 要分裂的hash位</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> bit)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; b = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Relink into lo and hi lists, preserving order</span></span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// lc代表的是原来的桶的元素的数量</span></span><br><span class=\"line\">    <span class=\"comment\">// hc代表新的桶中的元素的数量, 用来和UNTREEIFY_THRESHOLD比较决定是否要转换结构.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lc = <span class=\"number\">0</span>, hc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里还是当做链表去处理，把桶内的元素重新散列。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.TreeNode&lt;K, V&gt; e = b, next; e != <span class=\"keyword\">null</span>; e = next) &#123;</span><br><span class=\"line\">        next = (HashMap.TreeNode&lt;K, V&gt;) e.next;</span><br><span class=\"line\">        e.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.hash &amp; bit) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.prev = loTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">            loTail = e;</span><br><span class=\"line\">            ++lc;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.prev = hiTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">            hiTail = e;</span><br><span class=\"line\">            ++hc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  散列完后，判断原来的桶(lo)和新的桶中的元素个数</span></span><br><span class=\"line\">    <span class=\"comment\">//  然后决定转换为树还是链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">            tab[index] = loHead.untreeify(map);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tab[index] = loHead;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) <span class=\"comment\">// (else is already treeified)</span></span><br><span class=\"line\">                loHead.treeify(tab);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tab[index + bit] = hiHead;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead.treeify(tab);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将树重新穿换成链表的过程就比较简单了：</p>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class=\"line\"><span class=\"comment\">    * this node.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">Node&lt;K, V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Node&lt;K, V&gt; q = <span class=\"keyword\">this</span>; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replacementNode:将TreeNode转成Node</span></span><br><span class=\"line\">        HashMap.Node&lt;K, V&gt; p = map.replacementNode(q, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hd = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tl.next = p;</span><br><span class=\"line\">        tl = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是和红黑树相关的内容了，这里关键的是 split 调用了一个 treeify 的方法。这个方法同时也被 treeifyBin 调用了。所以 treeify 方法就和 treeifyBin 方法一块分享。<br>\n顺便提一嘴，他们有如下的关系:</p>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/hashMap06-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png\" alt=\"hashMap06-红黑树相关方法调用关系.png\"><br>\n 其中蓝色的是红黑树的方法，黄色的是 HashMap 调用的方法。</p>\n<h4 id=\"treeifybin\"><a class=\"markdownIt-Anchor\" href=\"#treeifybin\">#</a> treeifyBin</h4>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将链表转换成树。</span></span><br><span class=\"line\"><span class=\"comment\">* 替换给定hash值的索引处的桶的所有节点，如果表太小(table.length小于64),就调整大小.这里其实是对hash表的一种优化,防止因为表长度太小而转换成树,造成性能浪费</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> hash 用于确定桶的位置。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(HashMap.Node&lt;K, V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">    <span class=\"comment\">// 链表的节点</span></span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">// 如果hash表为空或者hash表的长度小于最小化的树化容量(64)，这时会重调整大小。</span></span><br><span class=\"line\">    <span class=\"comment\">// 将容量扩大为原来的两倍。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        `HashMap.TreeNode&lt;K, V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 构建一个树的节点。</span></span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 如果尾为null,说明这个节点是该桶中的第一个元素，</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以要将其赋于头节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                hd = p;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将该节点放在尾节点后。</span></span><br><span class=\"line\">                p.prev = tl;</span><br><span class=\"line\">                tl.next = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点作为尾节点。</span></span><br><span class=\"line\">            tl = p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果该桶中有元素，则进行树化。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            hd.treeify(tab);</span><br><span class=\"line\">        &#125;`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实呢，这个 <code>treeifyBin</code>  方法还是做了一些将桶树化的前置操作，然后将装有 <code>TreeNode</code>  节点的桶交给了 <code>treeify</code>  方法去真正的转换为一棵红黑树。那我们接下来看下 <code>treeify</code>  方法。注意这个方法定义在 <code>HashMap.TreeNode#treeify()</code></p>\n<h5 id=\"treeify方法\"><a class=\"markdownIt-Anchor\" href=\"#treeify方法\">#</a> treeify () 方法</h5>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Forms tree of the nodes linked from this node.</span></span><br><span class=\"line\"><span class=\"comment\"> * 把该节点连接的所有节点组成一棵树。(树化的过程)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(HashMap.Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该棵树的根节点。</span></span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// x是遍历的每个节点。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.TreeNode&lt;K, V&gt; x = <span class=\"keyword\">this</span>, next; x != <span class=\"keyword\">null</span>; x = next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存下下一个节点。(指向下一个节点的指针)</span></span><br><span class=\"line\">        next = (HashMap.TreeNode&lt;K, V&gt;) x.next;</span><br><span class=\"line\">        x.left = x.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 对根节点就行赋值(无父节点,黑色)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            x.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            x.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            root = x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            K k = x.key;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = x.hash;</span><br><span class=\"line\">            Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (HashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dir,负值和0为左子树，正值为右子树。</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">                K pk = p.key;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">/*************判断节点在左子树还是右子树 -start***************/</span></span><br><span class=\"line\">                <span class=\"comment\">// h为当前节点的hash值。</span></span><br><span class=\"line\">                <span class=\"comment\">// p是父节点, ph是父节点的hash值。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 放在左子树</span></span><br><span class=\"line\">                    dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 放在又子树</span></span><br><span class=\"line\">                    dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果当前节点和父节点的hash值相等:</span></span><br><span class=\"line\">                <span class=\"comment\">//如果节点的key实现了Comparable, 或者 父节点和当前节点的key为一个。</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                        (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// k是当前节点的key，pk是父节点的key</span></span><br><span class=\"line\">                    <span class=\"comment\">// 根据hashMap定义的规则,判断当前节点应该位于左子树还是右子树。</span></span><br><span class=\"line\">                    dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/*************判断节点在左子树还是右子树 -end***************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">                HashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class=\"line\">                <span class=\"comment\">// p==null,代表着遍历到了叶子节点。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// xp是当前节点的父节点。</span></span><br><span class=\"line\">                    x.parent = xp;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        xp.left = x;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        xp.right = x;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 平衡插入的红黑树(完成插入后，红黑树的性质可能被破坏,这里进行重新平衡)</span></span><br><span class=\"line\">                    root = balanceInsertion(root, x);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//确保红黑树的根节点是桶的第一个节点。</span></span><br><span class=\"line\">    moveRootToFront(tab, root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里呢，有 3 个方法没有仔细去说明，分别是 tieBreakOrder (),balanceInsertion () 和 moveRootToFront (tab, root), 注意，这三个方法在下面的 PutTreeVal 中也有调用。当然包括调整平衡的左旋 (rotateLeft), 右旋 (rotateRight) 方法。我们接着往下看吧。</p>\n<h5 id=\"balanceinsertion方法\"><a class=\"markdownIt-Anchor\" href=\"#balanceinsertion方法\">#</a> balanceInsertion 方法</h5>\n<p>在说这个方法之前，先总结下红黑树变换的 5 条规则。</p>\n<ul>\n<li>规则 1: 红黑树为空树 ==&gt; {<mark>直接插入当前节点，节点涂为黑色。</mark>}</li>\n<li>规则 2: 插入节点的父节点是黑色 ==&gt; {<mark>直接插入当前节点.</mark>}</li>\n<li>规则 3: 当前节点的父节点是红色，并且叔叔节点是红色。==&gt; {<mark>父节点涂黑，叔叔节点涂黑，祖父节点涂红.</mark>}</li>\n<li>规则 4: 当前节点的父节点是红色，叔叔是黑色，当前节点是父节点的右子树. ==&gt; {<mark>当前节点的父节点作为新的当前节点，以新的当前节点左旋。</mark>}</li>\n<li>规则 5: 当前节点的父节点是红色，叔叔节点是黑色，当前节点是父节点的左子树. ==&gt; {<mark>父节点变为黑色，祖父节点变为红色，以祖父节点为支点右旋.</mark>}<br>\n 下面结合代码看 HashMap 是怎么实现上面这个 5 个规则的:</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 调整红黑树</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> x 当前节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K, V&gt; HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">balanceInsertion</span><span class=\"params\">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                                        HashMap.TreeNode&lt;K, V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    x.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// xp: 当前节点的父节点(父节点)</span></span><br><span class=\"line\">    <span class=\"comment\">// xpp: 当前节点的父节点的父节点(祖父节点)</span></span><br><span class=\"line\">    <span class=\"comment\">// xppl: 当前节点的父节点的父节点的左子树(叔叔节点)</span></span><br><span class=\"line\">    <span class=\"comment\">// xppr: 当前节点的父节点的父节点的右子树(叔叔节点)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.TreeNode&lt;K, V&gt; xp, xpp, xppl, xppr; ; ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规则1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((xp = x.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            x.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 父节点为黑色 或者祖父节点为空==&gt;规则2</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!xp.red || (xpp = xp.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 父节点是左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 父节点是左子树,且祖父节点存在右子树(叔叔节点为右子树)，并且叔叔为红色。 ==&gt; 父节点是右子树时的性质1.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((xppr = xpp.right) != <span class=\"keyword\">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 叔叔节点涂黑</span></span><br><span class=\"line\">                xppr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 父节点涂黑</span></span><br><span class=\"line\">                xp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 祖父节点涂红</span></span><br><span class=\"line\">                xpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 以祖父节点为新的当前节点</span></span><br><span class=\"line\">                x = xpp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 祖父节点没有右子树或者有右子树,颜色为黑色。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前节点是父节点的右子树==&gt; 规则4</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x == xp.right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 左旋</span></span><br><span class=\"line\">                    root = rotateLeft(root, x = xp);</span><br><span class=\"line\">                    <span class=\"comment\">// 设置祖父节点要么为空要么是父节点。</span></span><br><span class=\"line\">                    xpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 规则5</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 父节点涂成黑色</span></span><br><span class=\"line\">                    <span class=\"comment\">// 此时xp可能为root.</span></span><br><span class=\"line\">                    xp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果xp不是root的时候。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 祖父节点涂成红色,右旋。</span></span><br><span class=\"line\">                        xpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        root = rotateRight(root, xpp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 父节点不是左子树==&gt; 父节点是右子树。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 叔叔节点(祖父节点的左子树),叔叔为红色 ==&gt; 规则3</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xppl != <span class=\"keyword\">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 叔叔涂黑</span></span><br><span class=\"line\">                xppl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 父节点涂黑</span></span><br><span class=\"line\">                xp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 祖父节点涂红</span></span><br><span class=\"line\">                xpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 以祖父节点为新的当前节点</span></span><br><span class=\"line\">                x = xpp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 祖父节点没有右子树或者有右子树,颜色为黑色。 ==&gt; 规则4</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前节点是左子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x == xp.left) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 右旋</span></span><br><span class=\"line\">                    root = rotateRight(root, x = xp);</span><br><span class=\"line\">                    <span class=\"comment\">// 设置祖父节点要么为空要么是父节点。</span></span><br><span class=\"line\">                    xpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// ==&gt; 规则5</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    xp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果有祖父</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 祖父节点涂成红色,右旋。</span></span><br><span class=\"line\">                        xpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        root = rotateLeft(root, xpp);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"rotateleft-左旋\"><a class=\"markdownIt-Anchor\" href=\"#rotateleft-左旋\">#</a> rotateLeft 左旋</h5>\n<p>这里的代码不能用语言描述，真的是只能意会不能言传啊。</p>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;K, V&gt; HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">rotateLeft2</span><span class=\"params\">(HashMap.TreeNode&lt;K, V&gt; root, HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; r, pp, rl;</span><br><span class=\"line\">            <span class=\"comment\">// p是父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 右孩子</span></span><br><span class=\"line\">        r = p.right;</span><br><span class=\"line\">        <span class=\"comment\">// 右孩子有左孩子的话.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 右孩子变成右孩子的左孩子。即rl变成了p的右孩子。</span></span><br><span class=\"line\">            p.right = r.left;</span><br><span class=\"line\">            rl = r.left;</span><br><span class=\"line\">            rl.parent = p;</span><br><span class=\"line\">            <span class=\"comment\">// 注意此时r没有关联。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pp = p.parent;</span><br><span class=\"line\">        <span class=\"comment\">// 如果p没有有父节点的话。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将r的父节点置为null</span></span><br><span class=\"line\">            r.parent = p.parent;</span><br><span class=\"line\">            <span class=\"comment\">// 颜色涂成黑色，并且r就是根节点。</span></span><br><span class=\"line\">            (root = r).red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  如果p节点有父节点，并且p是左子树的话</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pp.left == p) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将祖父节点的左子树置为r,</span></span><br><span class=\"line\">            pp.left = r;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将祖父节点的右子树置为r,</span></span><br><span class=\"line\">            pp.right = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将r和p连接起来。</span></span><br><span class=\"line\">        r.left = p;</span><br><span class=\"line\">        p.parent = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意下，这里的代码是我修改之后，JDK 的源码看起来很精简，理解起来，啧啧啧。</p>\n<p>MD, 来张图:</p>\n<p><img data-src=\"/images/JavaSourceCode/HashMap/HashMap07-%E5%B7%A6%E6%97%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png\" alt=\"HashMap07-左旋的过程.md\"></p>\n<p>这里假设右孩子是有左孩子的。如果没有的话，那就直接去掉绿色的 rl 就好了。</p>\n<h5 id=\"rotateright\"><a class=\"markdownIt-Anchor\" href=\"#rotateright\">#</a> rotateRight</h5>\n<p>右旋的过程同理:</p>\n<figure class=\"highlight java\"><figcaption><span>&#123;,.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;K, V&gt; HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">rotateRight</span><span class=\"params\">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                                         HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; l, pp, lr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (l = p.left) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((lr = p.left = l.right) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lr.parent = p;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pp = l.parent = p.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            (root = l).red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pp.right == p)</span><br><span class=\"line\">            pp.right = l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pp.left = l;</span><br><span class=\"line\">        l.right = p;</span><br><span class=\"line\">        p.parent = l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这图啊，有空再做吧。今天太累了。</p>\n<p>还有一个方法:</p>\n<h5 id=\"moveroottofront\"><a class=\"markdownIt-Anchor\" href=\"#moveroottofront\">#</a> moveRootToFront</h5>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Ensures that the given root is the first node of its bin.</span></span><br><span class=\"line\"><span class=\"comment\">  * // 确保红黑树的根节点是桶的第一个节点。</span></span><br><span class=\"line\"><span class=\"comment\">  * 为什么不直接将tab[index]==root? 是为了树重新转换成链表的时候使用的。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K, V&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveRootToFront</span><span class=\"params\">(HashMap.Node&lt;K, V&gt;[] tab, HashMap.TreeNode&lt;K, V&gt; root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span> &amp;&amp; tab != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (n - <span class=\"number\">1</span>) &amp; root.hash;</span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; first = (HashMap.TreeNode&lt;K, V&gt;) tab[index];</span><br><span class=\"line\">        <span class=\"comment\">// 判断第一个节点和root是不是相等的,判断的是地址。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != first) &#123;</span><br><span class=\"line\">            HashMap.Node&lt;K, V&gt; rn;</span><br><span class=\"line\">            tab[index] = root;</span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; rp = root.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((rn = root.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// root的后一个节点的指向前的指针指向root的前一个节点。</span></span><br><span class=\"line\">                ((HashMap.TreeNode&lt;K, V&gt;) rn).prev = rp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// root的前一个节点的指向后的指针指向root的后一个节点。</span></span><br><span class=\"line\">                rp.next = rn;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一个元素的前指针指向root</span></span><br><span class=\"line\">                first.prev = root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// root的后向指针指向first</span></span><br><span class=\"line\">            root.next = first;</span><br><span class=\"line\">            <span class=\"comment\">// root的前向指针置为null</span></span><br><span class=\"line\">            root.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 递归不变检查</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">assert</span> <span class=\"title\">checkInvariants</span><span class=\"params\">(root)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"puttreenode\"><a class=\"markdownIt-Anchor\" href=\"#puttreenode\">#</a> putTreeNode</h4>\n<figure class=\"highlight java\"><figcaption><span>&#123;./line-bumbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                                <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> searched = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; root = (parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">        K pk;</span><br><span class=\"line\">        <span class=\"comment\">/***************判断 左右子树 ******************/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class=\"line\">            dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h) &#123;</span><br><span class=\"line\">            dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!searched) &#123;</span><br><span class=\"line\">                HashMap.TreeNode&lt;K, V&gt; q, ch;</span><br><span class=\"line\">                searched = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (((ch = p.left) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                        (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                        ((ch = p.right) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                                (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/***************判断 左右子树 end******************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            HashMap.Node&lt;K, V&gt; xpn = xp.next;</span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                xp.left = x;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                xp.right = x;</span><br><span class=\"line\">            xp.next = x;</span><br><span class=\"line\">            x.parent = x.prev = xp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xpn != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                ((HashMap.TreeNode&lt;K, V&gt;) xpn).prev = x;</span><br><span class=\"line\">            <span class=\"comment\">// 这里比较重要了，不过我们在treeify中已经说过了。</span></span><br><span class=\"line\">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，HashMap 的新增过程我们就处理完了。</p>\n<h3 id=\"hashmap删除方法-hashmapremove\"><a class=\"markdownIt-Anchor\" href=\"#hashmap删除方法-hashmapremove\">#</a> HashMap 删除方法 HashMap#remove ()</h3>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从map中删除指定的key,如果key存在的话</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key key whose mapping is to be removed from the map</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> value 如果key存在,返回key对应的Value,如果不存在返回null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中计算 hash 值的方法还是和之前的一样。</p>\n<h4 id=\"removenode\"><a class=\"markdownIt-Anchor\" href=\"#removenode\">#</a> removeNode</h4>\n<figure class=\"highlight java\"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.remove and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Map.remove相关的方法</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash       hashCode</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key       key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value     value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> matchValue 如果是true，仅在value相等的时候删除。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> movable   如果为false，则在删除节点的时候不移动其他节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 返回删除的节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">Node&lt;K, V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        HashMap.Node&lt;K, V&gt; node = <span class=\"keyword\">null</span>, e;</span><br><span class=\"line\">        K k;</span><br><span class=\"line\">        V v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            node = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 找到红黑树中的节点</span></span><br><span class=\"line\">                node = ((HashMap.TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 删除链表中的节点1: 查找到节点的位置。</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                            ((k = e.key) == key ||</span><br><span class=\"line\">                                    (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                        node = e;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 真正的去删除的过程。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 删除红黑树的节点</span></span><br><span class=\"line\">                ((HashMap.TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 桶中只有当前的节点。</span></span><br><span class=\"line\">                tab[index] = node.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 链表中节点的删除</span></span><br><span class=\"line\">                p.next = node.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 修改次数+1</span></span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">            --size;</span><br><span class=\"line\">            afterNodeRemoval(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个最难理解的方法落在了红黑树的移除上了。</p>\n<h4 id=\"hashmaptreenoderemovetreenode\"><a class=\"markdownIt-Anchor\" href=\"#hashmaptreenoderemovetreenode\">#</a> HashMap#TreeNode#removeTreeNode</h4>\n<p>还是先看下红黑树的删除是怎么回事。</p>\n<p>在删除方法调用之前必须要有存在的给定节点。<br>\n这比典型的红黑删除代码更混乱，因为我们不能将内部节点的内容与叶子后继交换，后者由遍历期间可独立访问的 “下一个” 指针固定。 所以我们交换树链接。 如果当前树似乎有太少的节点，则红黑树 (bin) 将转换回普通的链表 (普通 bin). （测试会在 2 到 6 个节点之间触发，具体取决于树结构）。<br>\n上面是 removeTreeNode 方法的解释。说实话，没理解…</p>\n<p>HashMap 的删除不同于普通的红黑树的删除，因为它其中还维护了，一个链表的指向. HashMap 采用的是将树中的两个节点进行换位，颜色也要进行互换，来保证红黑树的平衡，并不改变二者在链表中的位置，互换后，删除节点此时的左子树是空的，将问题转换成了对左子树为空的节点的删除。</p>\n<p>有一个简单的问题，千万不要弄混了，就是 TreeNode 中要删除的节点是谁？？</p>\n<p>删除的签名是这样的: <code> final void removeTreeNode(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,boolean movable)</code> , 并没有传 TreeNode 啊？是不是？？</p>\n<p>干吗呢！大兄嘚。要删除的节点是：this 啊。我们现在走到了 TreeNode 内部了！！它本身就是要被删除的节点啊。</p>\n<p>好了，那我现在要告诉你：删除自己！</p>\n<p>HashMap 删除红黑树的节点，实际上就是 TreeNode 自己删除自己。那么它是怎么删的呢？</p>\n<p>它分成了三步:</p>\n<ul>\n<li>1. 将删除节点从双链向链表中删除.</li>\n<li>2. 将删除节点与其右子树最小节点互换，之后平衡树</li>\n<li>3. 将树根节点，移动到 <code>tab[index]</code>  指针处</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">removeTreeNode</span><span class=\"params\">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意了： 这个时候被删除的节点是谁??</span></span><br><span class=\"line\">        <span class=\"comment\">// 是this.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 找到对应的索引(确定对应桶的位置), n 是当前表的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (n - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">        <span class=\"comment\">// first: 第一个树节点(当前为父节点),root，父节点。rl:</span></span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; first = (HashMap.TreeNode&lt;K, V&gt;) tab[index], root = first, rl;</span><br><span class=\"line\">        <span class=\"comment\">// succ:下一个节点(链表的指向)。pred, 前一个节点。</span></span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; succ = (HashMap.TreeNode&lt;K, V&gt;) next, pred = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前一个为空时，即当前接是父节点:(被删除的节点是根节点)</span></span><br><span class=\"line\">            tab[index] = first = succ;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否测,前一个节点的下一个执行当前节点的下一个。(意会)</span></span><br><span class=\"line\">            pred.next = succ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (succ != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点的后节点不为null,后一个节点的前节点指向当前节点的前节点(意会)</span></span><br><span class=\"line\">            succ.prev = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果删除当前节点，该桶变成了null的。就直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 重置table[index]处为树的根节点。</span></span><br><span class=\"line\">            root = root.root();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// PS: 说点没用， JDK除了部分ifelse不加括号之外，</span></span><br><span class=\"line\">        <span class=\"comment\">// 其实换行，还是用的挺多的，看起来也挺舒服的。</span></span><br><span class=\"line\">        <span class=\"comment\">// 值得借鉴</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span></span><br><span class=\"line\">                || (movable &amp;&amp; (root.right == <span class=\"keyword\">null</span></span><br><span class=\"line\">                || (rl = root.left) == <span class=\"keyword\">null</span></span><br><span class=\"line\">                || rl.left == <span class=\"keyword\">null</span>))) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 树太小了，将树转换成链表</span></span><br><span class=\"line\">            tab[index] = first.untreeify(map);  <span class=\"comment\">// too small</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*****注意！！！ 此时已经从双向链表中删除了, 第一步走完。******/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// p是待删除的节点，pl当前节点的左孩子节点,pr当前节点的右孩子节点,replacement,用来交换的节点。</span></span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; p = <span class=\"keyword\">this</span>, pl = left, pr = right, replacement;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span> &amp;&amp; pr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// s为右子树的最小的节点,sl为左子树(一下五行和源码略有不同)</span></span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; s = pr, sl = s.left;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sl != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// find successor</span></span><br><span class=\"line\">                s = sl;</span><br><span class=\"line\">                sl = s.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 交换颜色</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> c = s.red;</span><br><span class=\"line\">            s.red = p.red;</span><br><span class=\"line\">            p.red = c; <span class=\"comment\">// swap colors</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 交换节点连接</span></span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; sr = s.right;</span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class=\"line\">            <span class=\"comment\">// pr是当前节点的右孩子节点</span></span><br><span class=\"line\">            <span class=\"comment\">// s是当前节点的右子树的最小的节点</span></span><br><span class=\"line\">            <span class=\"comment\">// p的右子树,只有s这一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == pr) &#123; <span class=\"comment\">// p was s&#x27;s direct parent</span></span><br><span class=\"line\">                p.parent = s;</span><br><span class=\"line\">                s.right = p;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//</span></span><br><span class=\"line\">                <span class=\"comment\">// sp： 最小节点的父节点</span></span><br><span class=\"line\">                HashMap.TreeNode&lt;K, V&gt; sp = s.parent;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p.parent = sp) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s == sp.left)</span><br><span class=\"line\">                        sp.left = p;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        sp.right = p;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((s.right = pr) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    pr.parent = s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 置null孩子。</span></span><br><span class=\"line\">            p.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p.right = sr) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                sr.parent = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((s.left = pl) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                pl.parent = s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((s.parent = pp) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                root = s;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left) &#123;</span><br><span class=\"line\">                pp.left = s;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pp.right = s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 确定要交换的节点完毕，交换节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                replacement = sr;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                replacement = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前树只含有左子树</span></span><br><span class=\"line\">            replacement = pl;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前树，只有又子树</span></span><br><span class=\"line\">            replacement = pr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 无孩子</span></span><br><span class=\"line\">            replacement = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (replacement != p) &#123;</span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                root = replacement;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">                pp.left = replacement;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                pp.right = replacement;</span><br><span class=\"line\">            p.left = p.right = p.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 是否要进行重平衡树?</span></span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在平衡后删除该节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (replacement == p) &#123;  <span class=\"comment\">// detach</span></span><br><span class=\"line\">            HashMap.TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class=\"line\">            p.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">                    pp.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.right)</span><br><span class=\"line\">                    pp.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 参数moveable控制是否删除节点后确保树的根节点为链表的头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (movable) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将树根节点，移动到tab[index]指针处</span></span><br><span class=\"line\">            moveRootToFront(tab, r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这样呢，整个删除过程就完成了。<br>\n用官方中的话，比较混乱。尤其是涉及到红黑树的删除，这部分内容。还是需要好好消化，消化的。</p>\n<p>下面我们还剩下两个内容：修改和查找</p>\n<h3 id=\"hashmap的查找方法\"><a class=\"markdownIt-Anchor\" href=\"#hashmap的查找方法\">#</a> HashMap 的查找方法</h3>\n<p><code>HashMap</code>  的查找的方法，有 <code>get</code> , <code>getOrDefault</code> . 很明显，这两个方法前者不存在的时候返回的是 <code>null</code> ，后者返回的就是 <code>defaultValue</code> .</p>\n<p>先来看下这两个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据指定的key返回映射的Value，当没有包含key的映射时，会返回 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 更正式的情况下： 如果存在一个key(K)的映射 value (V),使得 key==null?K==null:key.equals(K),</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果等式的值为 true, 那么返回V</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则返回 null</span></span><br><span class=\"line\"><span class=\"comment\"> * 不能通过 返回值为null 来判断是否含有&lt;K,V&gt; 映射，因为HashMap允许value为null。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getOrDefault</span><span class=\"params\">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? defaultValue : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，它调用的都是同一个方法，顺藤摸瓜，我们看这个  <code>getNode</code>  方法.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">Node&lt;K, V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; first, e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    K k;</span><br><span class=\"line\">    <span class=\"comment\">// 数组不为空，并且对应的桶(bin)不为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查是否为桶内的第一个节点是否满足</span></span><br><span class=\"line\">        <span class=\"comment\">// 为什么要检测第一个节点，直接进入循环或者树节点的检测不行吗?</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设第一个节点是目的节点,可以直接返回，少执行一次if判断，来判断其是树节点还是链表节点。</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果不是第一个节点，循环也会少执行一次,树节点的遍历，也会少遍历一次。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">                ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//如果第一个节点不是要查找的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是树节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((HashMap.TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是链表,遍历查找。</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 jdk8 之后，有两种类型的节点，我们还说过，这两种节点是  <code>爷孙</code>  的关系.<br>\n 链表的节点遍历就不用看了，比较简单。我们看下 红黑树的节点的查找:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">getTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前节点不是根节点,找到根节点，调用find进行查找,</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果是根节点，调用find进行查找。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>).find(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 红黑树的查找，</span></span><br><span class=\"line\"><span class=\"comment\">* 从根节点开始, 直接判断hash值即可。</span></span><br><span class=\"line\"><span class=\"comment\">* 如果hash值，小于当前节点hash值，对其左子树进行遍历。</span></span><br><span class=\"line\"><span class=\"comment\">* 反之，对右子树进行遍历。</span></span><br><span class=\"line\"><span class=\"comment\">* key值相等直接返回.</span></span><br><span class=\"line\"><span class=\"comment\">* 注意: 这里有左右子树为null的情况。</span></span><br><span class=\"line\"><span class=\"comment\">* 对接k和k的类进行比较,判断其要遍历的树为左子树或者右子树。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HashMap.<span class=\"function\">TreeNode&lt;K, V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.TreeNode&lt;K, V&gt; p = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ph, dir;</span><br><span class=\"line\">        K pk;</span><br><span class=\"line\">        HashMap.TreeNode&lt;K, V&gt; pl = p.left, pr = p.right, q;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">                (kc = comparableClassFor(k)) != <span class=\"keyword\">null</span>) &amp;&amp;</span><br><span class=\"line\">                (dir = compareComparables(kc, k, pk)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            p = (dir &lt; <span class=\"number\">0</span>) ? pl : pr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((q = pr.find(h, k, kc)) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个查找关键因素在于判断对左子树还是右子树进行递归遍历匹配。</p>\n<p>以上就是红黑树的查找过程了。</p>\n<h3 id=\"hashmap的其他常用方法\"><a class=\"markdownIt-Anchor\" href=\"#hashmap的其他常用方法\">#</a> HashMap 的其他常用方法</h3>\n<p>这些方法中的实现，我们大部分都分享过了。接下来，我们简单的看下其是如何调用的就好了.</p>\n<h4 id=\"hashmapcontainskey-和-hashmapcontainsvalue\"><a class=\"markdownIt-Anchor\" href=\"#hashmapcontainskey-和-hashmapcontainsvalue\">#</a>  <code>HashMap.containsKey()</code>  和  <code>HashMap.containsValue()</code></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果Map中包含一个映射关系,则返回true,注意是包含映射关系就会返回ture.</span></span><br><span class=\"line\"><span class=\"comment\"> * hashMap.put(&quot;1&quot;,null),也会返回true</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getNode(hash(key), key) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果存在指定的Value,就会返回true</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">    V v;</span><br><span class=\"line\">    <span class=\"comment\">// 如果table的长度不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历每个bin</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历bin下的每个Node</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((v = e.value) == value ||</span><br><span class=\"line\">                        (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里为什么可以通过  <code>.next</code>  的方式去遍历呢？<br>\n 这个主要是考虑在转换成树节点和树节点的新增的时候。 <code>hashMap</code>  在这两个时刻都对 <code>HashMap</code>  的 <code>next</code>  &quot;指针&quot; 进行了维护。所以，在这里就可以明白了，为什么树化节点时候还要维护 <code>.next</code>  了.</p>\n<h4 id=\"hashmapsize\"><a class=\"markdownIt-Anchor\" href=\"#hashmapsize\">#</a>  <code>HashMap.size()</code></h4>\n<p><code>HashMap</code>   的  <code>size</code>  函数最简单了，因为  <code>HashMap</code>  内部本来就维护了一个  <code>size</code>  字段，来记录  <code>HashMap</code>  的元素数量.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回HashMap的映射数量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashmapisempty\"><a class=\"markdownIt-Anchor\" href=\"#hashmapisempty\">#</a>  <code>HashMap.isEmpty()</code></h4>\n<p>HashMap 的 isEmpty 同样简单，废话少说，看下它的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果为映射数量为0的时候，返回true</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashmapentryset\"><a class=\"markdownIt-Anchor\" href=\"#hashmapentryset\">#</a>  <code>HashMap.entrySet()</code></h4>\n<p>这个方法是我们在遍历的时候，常用的一个方法，它的实现有点小复杂。 我们来看下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回这个Map里映射关系的一个 Set 视图.</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改HashMap会影响这个 Set 视图, 同样的，在这个视图里修改, 也会影响HashMap</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果通过对视图的迭代过程来修改HashMap(除了迭代器自身的remove方法,或者对迭代器返回的Entry的setValue操作),</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改的结果是不确定的。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个 set 视图, 支持元素的删除, 也会从 HashMap 中删除对应的元素.</span></span><br><span class=\"line\"><span class=\"comment\"> *  支持 Iterator.remove, Set.remove,  Set.removeAll, Set.retainAll, Set.clear 等操作</span></span><br><span class=\"line\"><span class=\"comment\"> * 但是它不支持 add, addAll 操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class=\"line\">    Set&lt;Map.Entry&lt;K, V&gt;&gt; es;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (es = entrySet) == <span class=\"keyword\">null</span> ? (entrySet = <span class=\"keyword\">new</span> HashMap.EntrySet()) : es;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，如果 <code>entrySet</code>  这个属性的为 <code>null</code>  的时候，就会返回一个空的 <code>HashMap</code>  的 <code>entry</code> , 否则就返回 <code>entrySet(es)</code> .<br>\n 那么  <code>entrySet</code>  这个字段是怎么来的呢？</p>\n<p>最先 HashMap 定义了一个这样的字段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存缓存的 entrySet().</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意: 这个AbstractMap 的字段会被 keySet() 和 values()使用。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>\n<p>好了，我们接着来看  <code>HashMap.EntrySet()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * EntrySet 继承的是 AbstractSet,</span></span><br><span class=\"line\"><span class=\"comment\">    * 泛型传入</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntrySet</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 直接调用 HashMap 迭代器</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HashMap.EntryIterator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 判断是否存在,</span></span><br><span class=\"line\"><span class=\"comment\">        * 直接调用的是hashMap的getNode方法</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class=\"line\">        Object key = e.getKey();</span><br><span class=\"line\">        HashMap.Node&lt;K, V&gt; candidate = getNode(hash(key), key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate != <span class=\"keyword\">null</span> &amp;&amp; candidate.equals(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 直接调用的 HashMap的删除方法.</span></span><br><span class=\"line\"><span class=\"comment\">        * 从这个方法中也可以看出来, 我们在 set试图中删除元素是会直接影响Hashmap的。</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class=\"line\">            Object key = e.getKey();</span><br><span class=\"line\">            Object value = e.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> removeNode(hash(key), key, value, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * entrySet 的分隔器</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Spliterator&lt;Map.Entry&lt;K, V&gt;&gt; spliterator() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HashMap.EntrySpliterator&lt;&gt;(HashMap.<span class=\"keyword\">this</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * entrySet 的迭代器</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> Map.Entry&lt;K, V&gt;&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span> &amp;&amp; (tab = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mc = modCount;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next)</span><br><span class=\"line\">                    action.accept(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (modCount != mc)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashmapreplace\"><a class=\"markdownIt-Anchor\" href=\"#hashmapreplace\">#</a>  <code>HashMap.replace()</code></h4>\n<p>这个是  <code>HashMap</code>  覆盖掉 <code>JDK8</code>  版本中 的替换方法，将制定的 <code>K-V</code>  映射替换掉。这个方法也会匹配 <code>Value</code>  的值是否相等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">replace</span><span class=\"params\">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; e;</span><br><span class=\"line\">    V v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">            ((v = e.value) == oldValue || (v != <span class=\"keyword\">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class=\"line\">        e.value = newValue;</span><br><span class=\"line\">        afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个也是覆盖  <code>JDK8</code>  版本中  <code>Map</code>  的方法，返回原来的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">replace</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        V oldValue = e.value;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        afterNodeAccess(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashmapforeach\"><a class=\"markdownIt-Anchor\" href=\"#hashmapforeach\">#</a>  <code>HashMap.forEach()</code></h4>\n<p>这个也是一个常用的方法，实现也比较简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(BiConsumer&lt;? <span class=\"keyword\">super</span> K, ? <span class=\"keyword\">super</span> V&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span> &amp;&amp; (tab = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mc = modCount;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next)</span><br><span class=\"line\">                action.accept(e.key, e.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modCount != mc)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashmapclear\"><a class=\"markdownIt-Anchor\" href=\"#hashmapclear\">#</a>  <code>HashMap.clear()</code></h4>\n<p>清空方法也是很简单的，逐一置空 <code>null</code>   <code>HashMap</code>  的每个 <code>bin</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tab.length; ++i)</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解答\"><a class=\"markdownIt-Anchor\" href=\"#问题解答\">#</a> 问题解答</h2>\n<ul>\n<li>如果我的 HashMap 的初始大小设置为 <code>[3|9|12]</code> , 第一次扩容的时候，容量变为了多少？是如何进行扩容的？</li>\n<li>(有毒的问题) 假设 Hash 表的长度是 32, 已知某一个 bin 中的链表长度为 7, 如果新增一个元素还是在该 bin 中的时，会进行什么操作？  <code>resize</code>  还是 <code>treeifyBin</code> ? 假设完成这个操作后该 bin 中元素数量没变，又新增一个元素还是到该 bin 中，这时进行什么操作？</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>表中允许 null 的键和 null 值。</li>\n<li>线程不同步，</li>\n<li>不保证元素的顺序。</li>\n</ul>\n<h2 id=\"网上常见面试问题汇总以及参考解答\"><a class=\"markdownIt-Anchor\" href=\"#网上常见面试问题汇总以及参考解答\">#</a> 网上常见面试问题汇总以及参考解答</h2>\n<h2 id=\"冷门知识点\"><a class=\"markdownIt-Anchor\" href=\"#冷门知识点\">#</a> 冷门知识点</h2>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" disabled=\"true\"><label for=\"cbx_4\"> failFast 机制。</label></li>\n</ul>\n<h2 id=\"jdk变更历史说明\"><a class=\"markdownIt-Anchor\" href=\"#jdk变更历史说明\">#</a> JDK 变更历史说明</h2>\n<h2 id=\"课后娱乐\"><a class=\"markdownIt-Anchor\" href=\"#课后娱乐\">#</a> 课后娱乐</h2>\n<ul>\n<li>java 实现红黑树</li>\n<li>自定义实现 hashMap。</li>\n</ul>\n<h2 id=\"参考文档答谢\"><a class=\"markdownIt-Anchor\" href=\"#参考文档答谢\">#</a> 参考文档 &amp; 答谢</h2>\n<h2 id=\"感受\"><a class=\"markdownIt-Anchor\" href=\"#感受\">#</a> 感受</h2>\n<ul>\n<li>注释：新字段要加注释标注此字段的作用，该字段是什么含义。</li>\n</ul>\n<hr>\n<p>阅读之前记录</p>\n<p>1. 图解。遇到问题，画图说明。<br>\n2. 一定要有自己的理解。<br>\n3. 对比其他版本 JDK。</p>\n<h3 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h3>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "源码",
                "JDK",
                "JDK8",
                "HashMap"
            ]
        }
    ]
}