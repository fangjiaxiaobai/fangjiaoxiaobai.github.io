{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"jdk\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "title": "JDK的Stream之系列一 初窥流原理",
            "date_published": "2021-08-23T15:13:55.000Z",
            "content_html": "<p>学东西的时候最好是理论先行，为什么？没有理论，想当然的去干，干好了是 瞎猫碰上死耗子，干不好就瞎干，浪费时间，只会弄得身心俱疲。<br>\n可是在真正的工作中，很少工作会允许你先弄清原理再去实操。但是不管怎么说，欠下的债终究是需要还的。</p>\n<p>今天咱们的主题是  <code>stream</code> . 咱们就从 <code>Stream</code>  的 &quot;道，术，法，器&quot; 四个阶段来聊好好的聊聊这个  <code>Stream</code> .</p>\n<h2 id=\"以器始从使用开始\"><a class=\"markdownIt-Anchor\" href=\"#以器始从使用开始\">#</a> 以 &quot;器&quot; 始：从使用开始</h2>\n<blockquote>\n<p>你平时是怎么使用  <code>Stream</code>  的？</p>\n</blockquote>\n<p>比如我会使用 <code>Stream</code>  创建一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integerStream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// do somethings ..</span></span><br></pre></td></tr></table></figure>\n<p>或者把一种集合类型转成 <code>stream</code> ，然后做一些聚合操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; collect = list.stream()</span><br><span class=\"line\">        .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">        .filter(item -&gt; item &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">        .sorted()</span><br><span class=\"line\">        .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>那在 <code>jdk1.7</code>  及以前的时候，我们是怎么处理的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历list，所有元素+5</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    Integer integer = list.get(i);</span><br><span class=\"line\">    integer += <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正序排序</span></span><br><span class=\"line\">sort(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新List.存储10个元素</span></span><br><span class=\"line\">List&lt;Integer&gt; newList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (list.size() &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    System.arraycopy(list, list.size() - <span class=\"number\">11</span>, newList, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    System.arraycopy(list, <span class=\"number\">0</span>, newList, <span class=\"number\">0</span>, list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的对比，我们很明显的就能对比出来：<br>\n <code>stream</code>  的编码方式，使代码更加简洁，可读性也比较强。而且 <code>Stream</code>  提供了集合的常用操作，比如 <code>sort</code> , <code>过滤</code> ， <code>去重</code> ， <code>计数</code> ， <code>limit</code> , <code>skip</code>  等等，直接可以用，可以大大的提高开发效率。</p>\n<p>那  <code>Stream</code>  为我们提供了多少功能呢？</p>\n<p>从全局来看，所有和  <code>stream</code>  相关的类，都在  <code>java.lang.stream</code>  这包下。</p>\n<p>这个包下有很多的类。总体来说，</p>\n<p>流处理相关的操作分为两类:</p>\n<ul>\n<li>中间操作 ( <code>Intermediate Operations</code> )\n<ul>\n<li>无状态的中间操作 ( <code>Stateless</code> ): 使用  <code>StatelessOp</code>  表示。每个操作都是互不影响，不依赖的。这类的操作有:  <code>filter()</code> 、 <code>flatMap()</code> 、 <code>flatMapToDouble()</code> 、 <code>flatMapToInt()</code> 、 <code>flatMapToLong()</code> 、 <code>map()</code> 、 <code>mapToDouble()</code> 、 <code>mapToInt()</code> 、 <code>mapToLong()</code> 、 <code>peek()</code> 、 <code>unordered()</code>  等</li>\n<li>有状态操作（ <code>Stateful</code> ）：使用  <code>StatefulOp</code>  表示。处理时会记录状态，比如处理了几个。后面元素的处理会依赖前面记录的状态，或者拿到所有元素才能继续下去。如 <code>distinct()</code> 、 <code>sorted()</code> 、 <code>sorted(comparator)</code> 、 <code>limit()</code> 、 <code>skip()</code>  等</li>\n</ul>\n</li>\n<li>终止操作 ( <code>Terminal Operations</code> )：使用  <code>TerminalOp</code>  表示。\n<ul>\n<li>非短路操作：处理完所有数据才能得到结果。如 <code>collect()</code> 、 <code>count()</code> 、 <code>forEach()</code> 、 <code>forEachOrdered()</code> 、 <code>max()</code> 、 <code>min()</code> 、 <code>reduce()</code> 、 <code>toArray()</code>  等。</li>\n<li>短路（ <code>short-circuiting</code> ）操作：拿到符合预期的结果就会停下来，不一定会处理完所有数据。如 <code>anyMatch()</code> 、 <code>allMatch()</code> 、 <code>noneMatch()</code> 、 <code>findFirst()</code> 、 <code>findAny()</code>  等。</li>\n</ul>\n</li>\n</ul>\n<p>在深入探讨 <code>stream</code>  之前，我们需要储备些知识点。</p>\n<ul>\n<li>\n<p>函数式接口  <code>FunctionInterface</code></p>\n<p><code>JDK</code>  提供了很多的函数式接口，包路径是： <code>java.util.function</code> . 函数式接口的作用是 Java8 对一类特定类型接口的称呼。这类接口只有一个抽象方法，并且使用  <code>@FunctionInterface</code>  注解进行注明。在 <code>Java Lambda</code>  的实现中， 开发组不想再为 <code>Lambda</code>  表达式单独定义一种特殊的 <code>Structural</code>  函数类型，称之为箭头类型（ <code>arrow type</code> ）， 依然想采用 Java 既有的类型系统 ( <code>class</code> ,  <code>interface</code> ,  <code>method</code>  等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的 <code>Java</code>  类型，并对成千上万的 <code>Java</code>  类库造成严重的影响。 权衡利弊， 因此最终还是利用 <code>SAM</code>  接口 ( <code>Single Abstract Method</code> ) 作为  <code>Lambda</code>  表达式的目标类型。</p>\n<p>函数式接口其实在 <code>Jdk8</code>  之前就已存在了，比如 <code>java.lang.Runnable</code> , <code>java.util.concurrent.Callable</code> , <code>java.util.Comparator</code>  等等。只是没有使用  <code>@FunctionInterface</code>  注解而已。在 <code>JDK1.8</code>  之后加上了这个注解，并且在 <code>java.util.function</code>  包下新增很多个函数式接口。 其中，我们需要知道的只有六个:</p>\n<ul>\n<li><code>Predicate</code> : 传入一个参数，返回一个 <code>bool</code>  结果， 方法为 <code>boolean test(T t)</code></li>\n<li><code>Consumer</code> : 传入一个参数，无返回值，纯消费。 方法为 <code>void accept(T t)</code></li>\n<li><code>Function&lt;T,R&gt;</code> : 传入一个参数，返回一个结果，方法为 <code>R apply(T t)</code></li>\n<li><code>Supplier</code> : 无参数传入，返回一个结果，方法为 <code>T get()</code></li>\n<li><code>UnaryOperator</code> : 一元操作符， 继承 <code>Function&lt;T,T&gt;</code> , 传入参数的类型和返回类型相同。</li>\n<li><code>BinaryOperator</code> : 二元操作符， 传入的两个参数的类型和返回类型相同， 继承 <code>BiFunction&lt;T,T,T&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>为什么要了解这个 函数式接口呢？</p>\n<p>因为 在 <code>Stream</code>  的方法中，大部分的参数都是使用 函数式接口 接受参数的。所以，如果要探究其实现原理和设计原则的话，这个是必须要知道的。</p>\n<blockquote>\n<p>注意:<br>\n <code>lambda</code>  表达式，是一种语法的表现形式，使代码表现更加整洁  <code>lambda</code>  和  <code>stream</code>  是两个不相关的概念。</p>\n</blockquote>\n<h2 id=\"查术理-查看源码明晰基本的类结构\"><a class=\"markdownIt-Anchor\" href=\"#查术理-查看源码明晰基本的类结构\">#</a> 查 &quot;术&quot; 理: (查看源码，明晰基本的类结构)</h2>\n<p>先来看下 和  <code>Stream</code>  直接相关的类。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E7%B1%BB%E5%9B%BE%E8%B0%B1.png\" alt=\"\"></p>\n<p><code>Stream</code>  接口继承了 <code>BaseStream</code>  接口.</p>\n<p><span class=\"label success\">✔️ BaseStream 接口表示流的基本接口，而流是支持顺序和并行聚合操作的元素序列。</span><br>\n <code>Stream</code>  接口有很多实现类。其主要的一个实现类是  <code>ReferencePipeline</code>  类。除此之外 <code>ReferencePipeline</code>  类还继承了 <code>AbstractPipeline</code>  抽象类. <span class=\"label success\">✔️ AbstractPipeline 表示 “管道” 类的抽象基类，它们是 Stream 接口及其原始特化的核心实现。</span>再看 <code>AbstractPipeline</code>  类的父类 <code>PipelineHelper</code> ,<span class=\"label success\">✔️ AbstractPipeline 的作用是：用于执行流管道的辅助类，将有关流管道的所有信息（输出形状、中间操作、流标志、并行度等）集中在一个地方。</span></p>\n<p><code>ReferencePipeline</code>  类有三个子类:  <code>StatefulOp</code>  表示有状态的操作， <code>StatelessOp</code>  表示无状态的操作，  <code>Head</code>  表示  <code>ReferencePipeline</code>  的起始阶段。 当然了，这三个子类也是 流。</p>\n<h3 id=\"从创建流开始\"><a class=\"markdownIt-Anchor\" href=\"#从创建流开始\">#</a> 从创建流开始</h3>\n<p>不管是使用  <code>Stream.of(T t)</code>  还是  <code>Collection.stream()</code> ，还是 <code>Arrays.stream()</code> , 底层的实现都是通过  <code>StreamSupport.stream()</code>  来实现的。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.of%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p><span class=\"label success\">✔️ StreamSupport 类的作用是：用于创建和操作流的底层实用方法。</span></p>\n<p><img data-src=\"/images/java/jdk/stream/StreamSupport.stream%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到 直接返回的是  <code>ReferencePipeline.Head</code>  对象。 首先  <code>Head</code>  是一种 <code>Stream</code>  的实现。 接着去看  <code>Head</code>  的构造方法，可以看到其实调用的是： <code>AbstractPipeline</code>  的构造方法.</p>\n<h3 id=\"流的中间操作\"><a class=\"markdownIt-Anchor\" href=\"#流的中间操作\">#</a> 流的中间操作</h3>\n<p>文中已经谈及了 中间操作分为有状态的中间操作和无状态的中间操作。那我们以一个案例来说明操作与操作之间执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">          .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">          .sorted((n1, n2) -&gt; n2 - n1)</span><br><span class=\"line\">          .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p><code>Stream.of()</code>  方法上文已经简单的说明了，接下来我们来看  <code>map()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到， <code>map()</code>  返回了一个 <code>StatelessOp</code>  对象，并且重写了 <code>AbstractPipeline</code>  的 <code>opWrapSink</code>  方法。 之前也说过：它表示流的无状态中间阶段的基类。 还有一个 <code>Sink</code>  类型.  <code>Sink</code>  类表示  <code>Consumer</code>  接口的扩展，用于在流管道的各个阶段传递值，以及管理大小信息、控制流等的附加方法。</p>\n<p>我们再仔细看一下这个方法。首先这个方法并没有进行任何的计算，只是将  <code>item -&gt; item + 5</code>  这个操作进行三层的封装， 1. 将 <code>map</code>  方法的返回值重新封装成了流对象，2. 把我们的 <code>item -&gt; item + 5</code>  这个操作封装成了  <code>StatelessOp</code> ， 并重写了 <code>opWrapSink</code>  这个方法，并在终止操作时进行调用。 3. 使用 <code>sink</code> ( <code>Sink.ChainedReference)</code>  将管道的各个阶段连接起来。即赋值 <code>downStream</code> . 使用 <code>downstream</code>  这个 <code>Consumer</code>  完成 <code>accept</code>  调用。</p>\n<p>这里需要注意一下:  <code>StatelessOp</code>  类的构造方法的实体参传输了一个  <code>this</code>  字段。仔细翻看源码就会返现它一直调用到  <code>AbstractPipeline</code>  的构造方法中。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.png\" alt=\"\"></p>\n<p>可以看到  <code>AbstractPipeline</code>  中有两个字段  <code>nextStage</code>  和  <code>previousStage</code>  字段，分别表示的是上一阶段和下一阶段。其中  <code>nextStage</code>  是 当前阶段。  <code>previousStage</code>  则应该 当前阶段的上一个阶段，其实就是调用当前方法的对象。</p>\n<p>不知道你是否发现 通过这种方法， <code>stream</code>  组成了一个 流各个阶段的双向链表。节点就是流操作的各个阶段。</p>\n<p>ps: 这样一次流操作会创建两个链表:  <code>Stream</code>  阶段的双向链表，和 在终止操作时，根据双向链表生成的  <code>Sink</code>  链表。</p>\n<p>再次说明：到目前为止， <code>map()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n<p>接着来看  <code>sorted()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/stream.sorted%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>sorted</code>  方法比较简单，通过调用 <code>SortedOps</code>  类的 <code>makeRef</code>  方法，创建了 <code>OfRef</code>  对象。  <code>OfRef</code>  类的作用是：用于对流进行排序的专用子类型。  <code>OfRef</code>  类继承了  <code>ReferencePipeline.StatefulOp</code>  ，所以 <code>OfRef</code>  是一个有状态操作。那自然它也会有  <code>opWrapSink</code>  方法。也就是说它也会返回一个 Sink 对象，只是这个 <code>Sink</code>  对象的实现类不一样的。</p>\n<blockquote>\n<p>说明：到目前为止， <code>sorted()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>同理去看 <code>limit</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.limit%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这个方法的内部是直接创建了一个  <code>ReferencePipeline.StatefulOp</code>  对象，也是重写了其中的方法:  <code>opWrapSink</code> .</p>\n<p>不知道你是否有好奇，我为什么每次都会提到  <code>opWrapSink</code>  这个方法呢？因为这个方法非常的重要！其重要性我们在 <a href=\"#%E6%8E%A2%E2%80%9D%E6%B3%95%E2%80%9C%E6%8B%A9\">探” 法 “择</a> 这部分会完整的说明。</p>\n<blockquote>\n<p>再三说明：到目前为止， <code>limit()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>书行至此，案例中的中间操作都已经简单的分析完成了。我们就知道这里  <code>jdk</code>  为了完成 流操作为每个中间操作都封装了很多的对象，而这些对象只是散列在了内存中。接下来，就要看  <code>jdk</code>  是如何把他们组装到一起的。</p>\n<h3 id=\"终止操作\"><a class=\"markdownIt-Anchor\" href=\"#终止操作\">#</a> 终止操作</h3>\n<p>以 <code>Collect</code>  方法为例，去探究一下终止操作的流程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.collect%E6%96%B9%E6%B3%95.png\" alt=\"\"><br>\n可以看到在 <code>collect</code>  方法中，分为并行执行方式和串行执行方法，我们看串行执行时，会创建  <code>ReduceOps</code>  终止操作对象。<br>\n<img data-src=\"/images/java/jdk/stream/AbstractPipeline.evaluate%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>将 终止操作 传递给 evaluate 方法，然后调用终止操作的 evaluate 方法，当然这个方法也分成了串行执行和并行执行两种。</p>\n<p><img data-src=\"/images/java/jdk/stream/ReduceOps.evaluateSequential%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>helper</code>  其实是  <code>limit(3)</code>  中间操作返回的对象。这其实中间操作的最后一个 <code>Stage</code>  (阶段)。返回的对象是 <code>AbstractPipeline</code>  和  <code>Stream</code>  的子类实例。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapAndCopyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这里包含两个方法:  <code>wrapSink()</code>  和  <code>copyInfo()</code> .</p>\n<p>这是两个非常重要的方法.  <code>wrapSink()</code>  是将中间的操作组成  <code>SinkChain</code>  。  <code>copyInfo()</code>  这是执行真正的计算逻辑。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapSink%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>方法中的形参  <code>sink</code>  就是最后的阶段的终止操作。方法通过循环将  <code>sink</code>  分装到 <code>Sink</code>  中。  <code>Sink</code>  接口 的一个实现类是  <code>ChainedReference</code>  ， 类中定义了一个  <code>downStream</code>  字段。 会将 <code>sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</code>   中的  <code>sink</code>  赋值给  <code>downStream</code> . 这样就形成了 <b>套娃</b>。 最后返回一个  <code>wrapSink</code>  , 即整个流操作中所有的操作的 封装 <code>Sink</code> .</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.copyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>图中所示的即为上面提及的 封装 <code>Sink</code> . 可中断和不可中断的区别是：可中断如果获取值，就不必再取所有的结果了。反之，就需要计算出所有阶段的结果。</p>\n<p>非可中断的终止操作时，会执行  <code>begin()</code> , <code>forEachRemaining()</code> , <code>end()</code> , 三个方法。  这个三个方法对应的是： <code>Sink</code>  接口中提供的三个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Sink开始之前调用该方法，通知sink做好准备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历元素时使用，接受一个待处理元素，并对元素进行处理。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Double i)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 通知sink没有元素进行处理了。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，</p>\n<ul>\n<li><code>begin()</code>  方法，会调用每个 <code>Sink</code>  子类的 <code>begin</code>  方法。</li>\n<li><code>forEachRemaining()</code>  方法对应的执行内容如下图:<br>\n<img data-src=\"/images/java/jdk/stream/forEachRemaining%E6%96%B9%E6%B3%95.png\" alt=\"\"></li>\n<li><code>end()</code>  方法，会调用每个 <code>Sink</code>  字段的 <code>end</code>  方法。</li>\n</ul>\n<p>书行至此。或许你会对  <code>forEachRemaining</code>  方法感到好奇。后面我会写一篇文章来专门分享: 《 <code>Stream</code>  的高级迭代器》, 希望你能继续关注支持我～</p>\n<h2 id=\"探法择\"><a class=\"markdownIt-Anchor\" href=\"#探法择\">#</a> 探” 法 “择</h2>\n<p>我们从一个案例出发，在细节之处分析了一个 <code>Stream</code>  的执行过程。现在我们需要从全局来看一下  <code>Stream</code>  的执行过程是什么样子的.</p>\n<p>上文中我们知道了  <code>Stream</code>  的 所有计算都是在 终止操作时 触发的。 所有的中间操作都是封装了一些对象。我们用一张图来描述下 <code>Stream</code>  的执行过程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"\"></p>\n<ul>\n<li><code>stream</code>  将创建的流做为第一个  <code>Stage</code>  , 用来代表流的开始， 每个 <code>Stage</code>  都是 <code>AbstractPipeline</code>  的子类。 第一个 <code>Stage</code>  是 <code>AbstractPipeline.Head</code>  对象。</li>\n<li>然后将中间操作封装成后面的 n 个  <code>stage</code> . 并组成 双向链表的形式，并且存储了 <code>stage0</code> . 每个 <code>Stage</code>  都是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .</li>\n<li>终止操作通过 <code>wrapSink()</code>  方法 会触发将 每个阶段的操作封装成  <code>Sink</code> . 并且 <code>sink</code>  都会做为参数传递到上一个阶段的 <code>opWrapSink()</code>  方法中，从而组成一个  <code>sink</code>  链表。</li>\n<li>然后，通过  <code>copyInfo()</code>  方法将，交于 <code>Spilterator</code>  进行迭代。计算的结果可以分为四种\n<ul>\n<li>返回 <code>boolean</code>  类型的结果：比如 <code>anyMatch()</code>   <code>allMatch()</code>   <code>noneMatch()</code>  方法。</li>\n<li>返回 <code>Optional</code>  类型的结果： 比如 <code>findFirst()</code>   <code>findAny()</code>  方法</li>\n<li>还有归约操作:\t <code>reduce()</code>   <code>collect()</code></li>\n<li>返回数组的： <code>toArray()</code> <br>\n 对于表中返回 <code>boolean</code>  或者 <code>Optional</code>  的操作（ <code>Optional</code>  是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 <code>Sink</code>  中记录这个值，等到执行结束时返回就可以了。<br>\n对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。 <code>collect()</code> ,  <code>reduce()</code> ,  <code>max()</code> ,  <code>min()</code>  都是归约操作，虽然 <code>max()</code>  和 <code>min()</code>  也是返回一个 <code>Optional</code> ，但事实上底层是通过调用 <code>reduce()</code>  方法实现的。<br>\n对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做 <code>Node</code>  的数据结构中的。 <code>Node</code>  是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于  <code>Stream</code>  的并行计算，我后面会继续分享。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"明道义\"><a class=\"markdownIt-Anchor\" href=\"#明道义\">#</a> 明 &quot;道&quot; 义</h2>\n<p><code>JDK</code>  提供的  <code>Stream</code>  具有如下特点:</p>\n<ul>\n<li>无存储。 <code>stream</code>  不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组， <code>Java</code>  容器或 <code>I/O channel</code>  等。</li>\n<li>为函数式编程而生。对 <code>stream</code>  的任何修改都不会修改背后的数据源，比如对 <code>stream</code>  执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新 <code>stream</code> 。</li>\n<li>惰式执行。 <code>stream</code>  上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li>可消费性。 <code>stream</code>  只能被 “消费” 一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n<blockquote>\n<p>在这一趴，我就围绕两个点来简单的聊聊。</p>\n</blockquote>\n<ul>\n<li><code>JDK8</code>  为什么要加入  <code>Stream</code> .</li>\n</ul>\n<p>除了上面四个特点之外， <code>Java8</code>  中的 <code>Stream</code>  是对集合对象的增强，当然不仅仅是集合对象。 <code>Stream</code>  为开发者提供了简洁的编码方式和编码风格，极大的提高了开发的效率。</p>\n<p>另外一个更重要的点在于  <code>Stream</code>  为我们下篇文章要分享的 <b> <code>Stream</code>  并行计算流</b> 提供了实现，请期待。</p>\n<ul>\n<li><code>Stream</code>  为什么要这么设计？</li>\n</ul>\n<p>我这里给一份我的回答，这个问题也留给看文章的你，也希望能看到你的回答。</p>\n<p>根据上文所说的内容， <code>Stream</code>  体系是一组接口家族， <code>AbstractPipeline </code> 是接口的实现， <code>PipelineHelper</code>  是管道的辅助类， <code>StreamSupport</code>  是流的底层工具类</p>\n<p><code>Stream</code>  使用 <code>stage</code>  来抽象流水线上的每个操作，其实每个 <code>stage</code>  就是一个 <code>stream</code>  子类的实例， 也就是 <code>AbstractPipeline</code>  几个子类的内部子类即 <code>Head</code>   <code>StatelessOp</code>   <code>statefulOp</code> ;</p>\n<p><code>StreamSupport</code>  用于创建生成 <code>Stream</code>  对应的是 <code>Head</code>  类，其他的中间操作分为有状态和无状态的，中间操作通过方法比如  <code>filter</code>   <code>map</code>  等返回的是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .  多个 <code>stage</code>  组合称为双向链表的形式 从而成了整个流水线</p>\n<p>有了流水线，相邻两个操作阶段之间如何协调运算？</p>\n<p>于是又有了 <code>Sink</code>  的概念，又来协调相邻的 <code>stage</code>  之间计算运行</p>\n<p>他的模式是 <code>begin</code>    <code>accept</code>   <code>end</code>  还有短路标记</p>\n<p>他的 <code>accept</code>  就是封装了回调方法，所以说每个操作 <code>stage</code> ,  <code>StatelessOp</code>   或者  <code>statefulOp</code>  中又封装了 <code>Sink</code> . 通过 <code>AbstractPipeline</code>  提供的 <code>opWrapSink</code>  方法可以获取这个 <code>Sink</code></p>\n<p>调用这个 <code>sink</code>  的 <code>accept</code>  方法就可以调用当前操作的方法</p>\n<p>那么如何串联起来呢？</p>\n<p>关键点在于 <code>opWrapSink</code>  方法，他接收一个 <code>Sink</code>  作为参数，在调用 <code>accept</code>  方法中。可以调用这个入参 <code>Sink</code>  的 <code>accept</code>  方法</p>\n<p>这样子从当前就能调用下一个，也就是说有了推动的动作。那么只需要找到开始，每个处理了之后都推动下一个，就顺序完成了所欲的操作了。</p>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\">#</a> 结语</h2>\n<p>通过看  <code>Stream</code>  相关的知识点，发现一篇文章是没法讲清楚的。</p>\n<p>这一次，我又果不其然的留下了两篇文章</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\"><label for=\"cbx_0\">  <code>Stream</code>  并行计算流</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\"><label for=\"cbx_1\">  <code>Stream</code>  的高级迭代器</label></li>\n</ul>\n<p>请给我记代办～</p>\n<p>在分享 <code>并行计算流</code> 的时候，我们需要以  <code>JDK1.7</code>  中的  <code>forkJoin</code>  框架为前提，来分析  <code>Stream</code>  的  <code>parallelStream</code> .</p>\n<p>在分享 <code>迭代器</code> 的时候，我们也会分析一下 <code>JDK</code>  中提供的 普通迭代器，比如  <code>ForEach</code> ,  <code>iterator</code> , 以及 <code>Stream</code>  的高级迭代器  <code>spliterator</code> . 也会由浅入深的分析一下，各种迭代器的优缺点。 也会自定义实现一个迭代器。</p>\n<p>敬请期待，防止走丢见文末。关注我，期望和你一起遇见更好的自己.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/java/jdk/stream/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "JDK",
                "Java",
                "Stream"
            ]
        }
    ]
}