<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fangjiaxiaobai.github.io</id>
    <title>方家小白 • Posts by &#34;数组&#34; tag</title>
    <link href="https://fangjiaxiaobai.github.io" />
    <updated>2021-08-19T06:48:55.000Z</updated>
    <category term="全站地图" />
    <category term="目录" />
    <category term="源码" />
    <category term="Redis" />
    <category term="数据结构" />
    <category term="日常" />
    <category term="Springboot" />
    <category term="Netty" />
    <category term="雪花算法" />
    <category term="算法" />
    <category term="MySQL" />
    <category term="Elastic Search" />
    <category term="搜索" />
    <category term="git" />
    <category term="go" />
    <category term="go-error" />
    <category term="MachineLearn" />
    <category term="log" />
    <category term="go-log" />
    <category term="猫影视" />
    <category term="图片" />
    <category term="线程池" />
    <category term="面经" />
    <category term="RocketMQ" />
    <category term="消息队列" />
    <category term="HD" />
    <category term="BQ" />
    <category term="AC" />
    <category term="leetCode" />
    <category term="链表" />
    <category term="面经之算法题" />
    <category term="动态规划" />
    <category term="数组" />
    <category term="不做也罢的算法题" />
    <category term="有点难的算法题" />
    <category term="HashMap" />
    <category term="JDK" />
    <category term="JDK8" />
    <category term="数据结构与算法" />
    <category term="哈希算法" />
    <category term="String" />
    <category term="排序" />
    <category term="冒泡排序" />
    <category term="交换排序" />
    <category term="快速排序" />
    <category term="分支思想排序" />
    <category term="分治思想排序" />
    <category term="桶排序" />
    <category term="线性思想排序" />
    <category term="选择排序" />
    <category term="go-设计模式" />
    <category term="递归" />
    <category term="Java" />
    <category term="dubbo" />
    <category term="模型评估" />
    <category term="架构" />
    <category term="笔记" />
    <category term="go-runtimes" />
    <category term="KNN" />
    <category term="JDK版本" />
    <category term="JDK11" />
    <category term="OOM" />
    <category term="JVM" />
    <category term="Stream" />
    <entry>
        <id>https://fangjiaxiaobai.github.io/2021/08/19/BQ/LeetCode/0001-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
        <title>LC:反转数组</title>
        <link rel="alternate" href="https://fangjiaxiaobai.github.io/2021/08/19/BQ/LeetCode/0001-%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
        <content type="html">&lt;h2 id=&#34;题目&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#题目&#34;&gt;#&lt;/a&gt; 题目&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;p&gt;尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。&lt;br&gt;
你可以使用空间复杂度为 O (1) 的 原地 算法解决这个问题吗？&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3,4,5,6,7], k = 3&lt;br&gt;
 输出: [5,6,7,1,2,3,4]&lt;br&gt;
 解释:&lt;br&gt;
 向右旋转 1 步: [7,1,2,3,4,5,6]&lt;br&gt;
 向右旋转 2 步: [6,7,1,2,3,4,5]&lt;br&gt;
 向右旋转 3 步: [5,6,7,1,2,3,4]&lt;/p&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入：nums = [-1,-100,3,99], k = 2&lt;br&gt;
 输出：[3,99,-1,-100]&lt;br&gt;
 解释:&lt;br&gt;
 向右旋转 1 步: [99,-1,-100,3]&lt;br&gt;
 向右旋转 2 步: [3,99,-1,-100]&lt;/p&gt;
&lt;div class=&#34;note warning&#34;&gt;
&lt;p&gt;提示&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;1 &amp;lt;= nums.length &amp;lt;= 2 * 104&lt;br&gt;
-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&lt;br&gt;
0 &amp;lt;= k &amp;lt;= 105&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;links&#34;&gt;&lt;div class=&#34;item&#34; title=&#34;力扣（LeetCode）&#34; style=&#34;--block-color:#ffa015;&#34;&gt;&lt;span class=&#34;exturl image&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5&#34; data-background-image=&#34;https://static.leetcode-cn.com/cn-frontendx-assets/production/_next/static/images/lccn-logo-ce3d56eeedaae618e59e2ec5089e4834.svg&#34;&gt;&lt;/span&gt;
          &lt;div class=&#34;info&#34;&gt;
          &lt;span class=&#34;exturl title&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5&#34;&gt;力扣（LeetCode）&lt;/span&gt;
          &lt;p class=&#34;desc&#34;&gt;https://leetcode-cn.com/&lt;/p&gt;
          &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&#34;分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分析&#34;&gt;#&lt;/a&gt; 分析&lt;/h2&gt;
&lt;h3 id=&#34;解法1顺序后移法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法1顺序后移法&#34;&gt;#&lt;/a&gt; 解法 1: 顺序后移法&lt;/h3&gt;
&lt;p&gt;将最后一个元素赋值给临时变量，然后将其他元素顺序后移一个位置。重复此操作 k 次。&lt;/p&gt;
&lt;p&gt;但是需要注意的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度。这种算法在最优时时间复杂度是 O (n). 最差情况下是 O (n^2). 在 LeetCode 上是没法 AC 的。&lt;/li&gt;
&lt;li&gt;k 是会大于数组长度的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;rotate&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] nums, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nums == &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt; || k &amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nums.length &amp;lt; k) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 解决k&amp;gt;nums.length问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        k = k % nums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; length = nums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; k; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; temp = nums[length - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = length - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;; j &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; j--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            nums[j] = nums[j - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        nums[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种解决方法在数据量较大的情况下就会报错 &lt;code&gt;超出时间限制了&lt;/code&gt; 。&lt;br&gt;
即使 你在循环修改使用  &lt;code&gt;System.arraycopy(nums, 0, nums, 1, length - 1);&lt;/code&gt;  来替换掉内层循环，也是不可以 &lt;code&gt;AC&lt;/code&gt;  的。&lt;/p&gt;
&lt;h3 id=&#34;解法2-优化解法1空间换时间&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法2-优化解法1空间换时间&#34;&gt;#&lt;/a&gt; 解法 2: 优化解法 1, 空间换时间&lt;/h3&gt;
&lt;p&gt;按照规律将 nums 数组中的值，赋值到新数组中。然后使用新数组覆盖原数组。&lt;br&gt;
那规律是什么呢？&lt;br&gt;
 设：&lt;br&gt;
 &lt;code&gt;i&lt;/code&gt;  为数组的的下标。  &lt;code&gt;newArr&lt;/code&gt;  为新的数组， &lt;code&gt;n&lt;/code&gt;  为数组总长度，&lt;br&gt;
 那么&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;newArr[(i+k)%n] = nums[i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;AC&lt;/code&gt;  代码如下:&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;rotate&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] nums, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nums == &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt; || k &amp;lt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; n = nums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 新数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] newArr = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[n];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; k; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        newArr[(i + k) % n] = nums[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.arraycopy(newArr, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, nums, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;AC 之后显示：&lt;br&gt;
执行用时  &lt;code&gt;1 ms&lt;/code&gt; &lt;br&gt;
 内存消耗： &lt;code&gt;55.1 MB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种方式，时间复杂度得到显著的提升，但是带来了额外的空间消耗。而且这种空间消耗是等于原来占用的数据大小。&lt;/p&gt;
&lt;p&gt;那是否还有其他方式呢？&lt;/p&gt;
&lt;h3 id=&#34;解法3-反转&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法3-反转&#34;&gt;#&lt;/a&gt; 解法 3: 反转&lt;/h3&gt;
&lt;p&gt;这种方式是一种比较简单的方式，有点类似于脑筋急转弯的意思。抛开之前的环装思路。将这个数组看成具有方向的一组数据。将这组数据分成三组： &lt;code&gt;[0,k-1]&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;[k+1,length]&lt;/code&gt; . 先将  &lt;code&gt;[0,k-1]&lt;/code&gt;  反转，再把  &lt;code&gt;[k+1,length]&lt;/code&gt;  反转，最后把这个数组反转。这样操作之后，就是最后结果了。&lt;/p&gt;
&lt;p&gt;比如，数组： &lt;code&gt;[1,2,3,4,5,6,7]&lt;/code&gt; ,  &lt;code&gt;k=3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一步：把整体数组进行反转:  &lt;code&gt;[1,2,3,4,5,6,7]&lt;/code&gt;  =&amp;gt;  &lt;code&gt;[7,6,5,4,3,2,1]&lt;/code&gt; &lt;br&gt;
 第二步：把 &lt;code&gt;[0,k-1=2]&lt;/code&gt;  的元素进行反转:  &lt;code&gt;[7,6,5,4,3,2,1]&lt;/code&gt;  =&amp;gt; &lt;code&gt;[5,6,7,4,3,2,1]&lt;/code&gt; &lt;br&gt;
 第三步：把 &lt;code&gt;[k,n-1]&lt;/code&gt;  的元素进行反转:  &lt;code&gt;[5,6,7,4,3,2,1]&lt;/code&gt;  =&amp;gt; &lt;code&gt;[5,6,7,1,2,3,4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实现代码如下:&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;rotate&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] nums, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    k %= nums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    reverse(nums, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, nums.length - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    reverse(nums, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, k - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    reverse(nums, k, nums.length - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;reverse&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt;[] nums, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; start, &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (start &amp;lt; end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; temp = nums[start];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        nums[start] = nums[end];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        nums[end] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        start += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        end -= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;思考&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#思考&#34;&gt;#&lt;/a&gt; 思考&lt;/h2&gt;
&lt;p&gt;关于这道题目的一点小思考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这道题其实还有另外一种解法，就是通过公式去推导出元素应该最终所在的位置，直接进行位置交换。这种思路也是可行的。具体解决可以参照下官网的解题方法。&lt;/li&gt;
&lt;li&gt;这是一道很简单的题目，最后出奇的解法也是颇感意外的，总有一种豁然开朗的感觉。我一直在想此法的解题人是怎么想到的呢。&lt;span class=&#34;label warning&#34;&gt;这里面一定是蕴含一定的逻辑的。这种多次反转的逻辑，或许是一种规律？&lt;/span&gt; 我一直没有想通。&lt;/li&gt;
&lt;li&gt;当你想到这个可以用一个环去解决问题的时候，可能永远就想不出 &amp;quot;利用方向&amp;quot; 去解决这个问题了。反观题目来讲，一直都是说的数组，而 “环” 是我们自己强加的一个思维方式。确实，当我们从环的角度出发，看到的就不是题目本身了，看到的是你的题目。&lt;span class=&#34;label success&#34;&gt;✔️ 反观现实，你理解的现实就真正的是现实吗？你有没有陷入自己的 “环” 中去呢？不妨，重新看看你身边的人和事吧，尝试发现他们最真实的样子.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最后&#34;&gt;#&lt;/a&gt; 最后&lt;/h2&gt;
&lt;p&gt;希望与你一起遇见更好的自己&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/qrcode.jpg&#34; alt=&#34;期望与你一起遇见更好的自己&#34;&gt;&lt;/p&gt;
</content>
        <category term="数据结构" />
        <category term="leetCode" />
        <category term="面经之算法题" />
        <category term="数组" />
        <updated>2021-08-19T06:48:55.000Z</updated>
    </entry>
</feed>
