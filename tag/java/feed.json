{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"java\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/10/13/java%E7%B3%BB%E5%88%97/dubbo/01-%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BA%AFdubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/",
            "url": "https://fangjiaxiaobai.github.io/2021/10/13/java%E7%B3%BB%E5%88%97/dubbo/01-%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BA%AFdubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/",
            "title": "搭建第一个纯dubbo微服务应用",
            "date_published": "2021-10-13T14:58:55.000Z",
            "content_html": "<p>本文旨在快速搭建一个 <b>纯 dubbo 微服务</b> 应用。</p>\n<h2 id=\"创建一个项目\"><a class=\"markdownIt-Anchor\" href=\"#创建一个项目\">#</a> 创建一个项目</h2>\n<p><img data-src=\"/images/dubbo/chapter01-%E5%9B%BE1.png\" alt=\"\"></p>\n<ul>\n<li><code>consumer</code>  表示一个消费者。</li>\n<li><code>provider</code>  标识一个服务提供者。</li>\n<li><code>provider-api</code>  表示对外提供服务的 api.</li>\n</ul>\n<p>我们现实的开发中，往往是一个服务既充当服务提供者角色，又充当服务消费者的角色。所以，每个服务都会有一个两个模块， <code>1.provider</code> ，服务的实现逻辑模块，  <code>2.provider-api</code> : 服务对外暴露的 api 模块。</p>\n<h2 id=\"引入依赖\"><a class=\"markdownIt-Anchor\" href=\"#引入依赖\">#</a> 引入依赖</h2>\n<p>在 父级 <code>pom</code>  中加入如下依赖:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo.version</span>&gt;</span>3.0.3<span class=\"tag\">&lt;/<span class=\"name\">dubbo.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，我们使用的 <code>dubbo3.x</code>  版本。在这个版本中，开发者将 <code>dubbo</code>  的依赖进行拆分，所以，我们引入了  <code>dubbo</code>  和  <code>dubbo-dependencies-zookper</code>  这两个依赖。</p>\n<h2 id=\"创建服务提供者\"><a class=\"markdownIt-Anchor\" href=\"#创建服务提供者\">#</a> 创建服务提供者</h2>\n<p><img data-src=\"/images/dubbo/chapter01-%E5%9B%BE2.png\" alt=\"\"></p>\n<h3 id=\"设置api依赖\"><a class=\"markdownIt-Anchor\" href=\"#设置api依赖\">#</a> 设置 api 依赖</h3>\n<p>在服务提供者的具体实现模块中 ( <code>provider/pom.xml</code> )，加入 <code>api</code>  模块依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fxb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>provider-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"定义-服务间的交互协议契约规范\"><a class=\"markdownIt-Anchor\" href=\"#定义-服务间的交互协议契约规范\">#</a> 定义 服务间的交互协议 (契约 / 规范)</h3>\n<p>其实就是定义服务间的 <code>RPC</code>  接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义rpc的交互规范</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangjiaxiaobai</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-13 16:16</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IProviderService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * say hello</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &quot;hello dubbo&quot;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现服务提供者的业务逻辑\"><a class=\"markdownIt-Anchor\" href=\"#实现服务提供者的业务逻辑\">#</a> 实现服务提供者的业务逻辑</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现服务的具体逻辑</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangjiaxiaobai</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-13 16:00</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProviderServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IProviderService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello, dubbo!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对外提供服务\"><a class=\"markdownIt-Anchor\" href=\"#对外提供服务\">#</a> 对外提供服务</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 服务启动</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangjiaxiaobai</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-13 16:01</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProviderApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String zookeeperHost = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ServiceConfig&lt;IProviderService&gt; service = <span class=\"keyword\">new</span> ServiceConfig&lt;&gt;();</span><br><span class=\"line\">        service.setApplication(<span class=\"keyword\">new</span> ApplicationConfig(<span class=\"string\">&quot;first-dubbo-provider&quot;</span>));</span><br><span class=\"line\">        service.setRegistry(<span class=\"keyword\">new</span> RegistryConfig(<span class=\"string\">&quot;zookeeper://&quot;</span> + zookeeperHost + <span class=\"string\">&quot;:2181&quot;</span>));</span><br><span class=\"line\">        service.setInterface(IProviderService.class);</span><br><span class=\"line\">        service.setRef(<span class=\"keyword\">new</span> ProviderServiceImpl());</span><br><span class=\"line\">        service.export();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;dubbo service started&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>).await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建服务消费者\"><a class=\"markdownIt-Anchor\" href=\"#创建服务消费者\">#</a> 创建服务消费者</h2>\n<p><img data-src=\"/images/dubbo/chapter01-%E5%9B%BE3.png\" alt=\"\"></p>\n<h3 id=\"引入api依赖\"><a class=\"markdownIt-Anchor\" href=\"#引入api依赖\">#</a> 引入 api 依赖</h3>\n<p>在服务消费者的 <code>pom</code>  文件中 ( <code>comsumer/pom.xml</code> )，添加如下 <code>maven</code>  依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.fxb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>provider-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"消费逻辑\"><a class=\"markdownIt-Anchor\" href=\"#消费逻辑\">#</a> 消费逻辑</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 服务消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangjiaxiaobai</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-13 16:20</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String zookeeperHost = <span class=\"string\">&quot;127.0.0.1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReferenceConfig&lt;IProviderService&gt; reference = <span class=\"keyword\">new</span> ReferenceConfig&lt;&gt;();</span><br><span class=\"line\">        reference.setApplication(<span class=\"keyword\">new</span> ApplicationConfig(<span class=\"string\">&quot;first-dubbo-consumer&quot;</span>));</span><br><span class=\"line\">        reference.setRegistry(<span class=\"keyword\">new</span> RegistryConfig(<span class=\"string\">&quot;zookeeper://&quot;</span> + zookeeperHost + <span class=\"string\">&quot;:2181&quot;</span>));</span><br><span class=\"line\">        reference.setInterface(IProviderService.class);</span><br><span class=\"line\">        IProviderService service = reference.get();</span><br><span class=\"line\">        String message = service.sayHello();</span><br><span class=\"line\">        System.out.println(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"附录搭建zookeeper注册中心\"><a class=\"markdownIt-Anchor\" href=\"#附录搭建zookeeper注册中心\">#</a> 附录：搭建 <code>zookeeper</code>  注册中心</h2>\n<p>由于是单机演示，就简单的使用  <code>单机zookeeper</code>  就好了，</p>\n<p>通过  <code>https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz</code>  下载 <code>zookeeper</code>  的 <code>jar</code>  包，解压后，使用  <code>zkServer.sh(Mac OS) </code> 或者  <code>zkServer.cmd(Windows平台)</code>  启动就可以了。默认端口使用的是 <code>2181</code> .</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>希望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/dubbo/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "Java",
                "dubbo"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/",
            "title": "JDK的Stream之系列一 初窥流原理",
            "date_published": "2021-08-23T15:13:55.000Z",
            "content_html": "<p>学东西的时候最好是理论先行，为什么？没有理论，想当然的去干，干好了是 瞎猫碰上死耗子，干不好就瞎干，浪费时间，只会弄得身心俱疲。<br>\n可是在真正的工作中，很少工作会允许你先弄清原理再去实操。但是不管怎么说，欠下的债终究是需要还的。</p>\n<p>今天咱们的主题是  <code>stream</code> . 咱们就从 <code>Stream</code>  的 &quot;道，术，法，器&quot; 四个阶段来聊好好的聊聊这个  <code>Stream</code> .</p>\n<h2 id=\"以器始从使用开始\"><a class=\"markdownIt-Anchor\" href=\"#以器始从使用开始\">#</a> 以 &quot;器&quot; 始：从使用开始</h2>\n<blockquote>\n<p>你平时是怎么使用  <code>Stream</code>  的？</p>\n</blockquote>\n<p>比如我会使用 <code>Stream</code>  创建一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integerStream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// do somethings ..</span></span><br></pre></td></tr></table></figure>\n<p>或者把一种集合类型转成 <code>stream</code> ，然后做一些聚合操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; collect = list.stream()</span><br><span class=\"line\">        .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">        .filter(item -&gt; item &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">        .sorted()</span><br><span class=\"line\">        .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>那在 <code>jdk1.7</code>  及以前的时候，我们是怎么处理的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历list，所有元素+5</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    Integer integer = list.get(i);</span><br><span class=\"line\">    integer += <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正序排序</span></span><br><span class=\"line\">sort(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新List.存储10个元素</span></span><br><span class=\"line\">List&lt;Integer&gt; newList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (list.size() &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    System.arraycopy(list, list.size() - <span class=\"number\">11</span>, newList, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    System.arraycopy(list, <span class=\"number\">0</span>, newList, <span class=\"number\">0</span>, list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的对比，我们很明显的就能对比出来：<br>\n <code>stream</code>  的编码方式，使代码更加简洁，可读性也比较强。而且 <code>Stream</code>  提供了集合的常用操作，比如 <code>sort</code> , <code>过滤</code> ， <code>去重</code> ， <code>计数</code> ， <code>limit</code> , <code>skip</code>  等等，直接可以用，可以大大的提高开发效率。</p>\n<p>那  <code>Stream</code>  为我们提供了多少功能呢？</p>\n<p>从全局来看，所有和  <code>stream</code>  相关的类，都在  <code>java.lang.stream</code>  这包下。</p>\n<p>这个包下有很多的类。总体来说，</p>\n<p>流处理相关的操作分为两类:</p>\n<ul>\n<li>中间操作 ( <code>Intermediate Operations</code> )\n<ul>\n<li>无状态的中间操作 ( <code>Stateless</code> ): 使用  <code>StatelessOp</code>  表示。每个操作都是互不影响，不依赖的。这类的操作有:  <code>filter()</code> 、 <code>flatMap()</code> 、 <code>flatMapToDouble()</code> 、 <code>flatMapToInt()</code> 、 <code>flatMapToLong()</code> 、 <code>map()</code> 、 <code>mapToDouble()</code> 、 <code>mapToInt()</code> 、 <code>mapToLong()</code> 、 <code>peek()</code> 、 <code>unordered()</code>  等</li>\n<li>有状态操作（ <code>Stateful</code> ）：使用  <code>StatefulOp</code>  表示。处理时会记录状态，比如处理了几个。后面元素的处理会依赖前面记录的状态，或者拿到所有元素才能继续下去。如 <code>distinct()</code> 、 <code>sorted()</code> 、 <code>sorted(comparator)</code> 、 <code>limit()</code> 、 <code>skip()</code>  等</li>\n</ul>\n</li>\n<li>终止操作 ( <code>Terminal Operations</code> )：使用  <code>TerminalOp</code>  表示。\n<ul>\n<li>非短路操作：处理完所有数据才能得到结果。如 <code>collect()</code> 、 <code>count()</code> 、 <code>forEach()</code> 、 <code>forEachOrdered()</code> 、 <code>max()</code> 、 <code>min()</code> 、 <code>reduce()</code> 、 <code>toArray()</code>  等。</li>\n<li>短路（ <code>short-circuiting</code> ）操作：拿到符合预期的结果就会停下来，不一定会处理完所有数据。如 <code>anyMatch()</code> 、 <code>allMatch()</code> 、 <code>noneMatch()</code> 、 <code>findFirst()</code> 、 <code>findAny()</code>  等。</li>\n</ul>\n</li>\n</ul>\n<p>在深入探讨 <code>stream</code>  之前，我们需要储备些知识点。</p>\n<ul>\n<li>\n<p>函数式接口  <code>FunctionInterface</code></p>\n<p><code>JDK</code>  提供了很多的函数式接口，包路径是： <code>java.util.function</code> . 函数式接口的作用是 Java8 对一类特定类型接口的称呼。这类接口只有一个抽象方法，并且使用  <code>@FunctionInterface</code>  注解进行注明。在 <code>Java Lambda</code>  的实现中， 开发组不想再为 <code>Lambda</code>  表达式单独定义一种特殊的 <code>Structural</code>  函数类型，称之为箭头类型（ <code>arrow type</code> ）， 依然想采用 Java 既有的类型系统 ( <code>class</code> ,  <code>interface</code> ,  <code>method</code>  等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的 <code>Java</code>  类型，并对成千上万的 <code>Java</code>  类库造成严重的影响。 权衡利弊， 因此最终还是利用 <code>SAM</code>  接口 ( <code>Single Abstract Method</code> ) 作为  <code>Lambda</code>  表达式的目标类型。</p>\n<p>函数式接口其实在 <code>Jdk8</code>  之前就已存在了，比如 <code>java.lang.Runnable</code> , <code>java.util.concurrent.Callable</code> , <code>java.util.Comparator</code>  等等。只是没有使用  <code>@FunctionInterface</code>  注解而已。在 <code>JDK1.8</code>  之后加上了这个注解，并且在 <code>java.util.function</code>  包下新增很多个函数式接口。 其中，我们需要知道的只有六个:</p>\n<ul>\n<li><code>Predicate</code> : 传入一个参数，返回一个 <code>bool</code>  结果， 方法为 <code>boolean test(T t)</code></li>\n<li><code>Consumer</code> : 传入一个参数，无返回值，纯消费。 方法为 <code>void accept(T t)</code></li>\n<li><code>Function&lt;T,R&gt;</code> : 传入一个参数，返回一个结果，方法为 <code>R apply(T t)</code></li>\n<li><code>Supplier</code> : 无参数传入，返回一个结果，方法为 <code>T get()</code></li>\n<li><code>UnaryOperator</code> : 一元操作符， 继承 <code>Function&lt;T,T&gt;</code> , 传入参数的类型和返回类型相同。</li>\n<li><code>BinaryOperator</code> : 二元操作符， 传入的两个参数的类型和返回类型相同， 继承 <code>BiFunction&lt;T,T,T&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>为什么要了解这个 函数式接口呢？</p>\n<p>因为 在 <code>Stream</code>  的方法中，大部分的参数都是使用 函数式接口 接受参数的。所以，如果要探究其实现原理和设计原则的话，这个是必须要知道的。</p>\n<blockquote>\n<p>注意:<br>\n <code>lambda</code>  表达式，是一种语法的表现形式，使代码表现更加整洁  <code>lambda</code>  和  <code>stream</code>  是两个不相关的概念。</p>\n</blockquote>\n<h2 id=\"查术理-查看源码明晰基本的类结构\"><a class=\"markdownIt-Anchor\" href=\"#查术理-查看源码明晰基本的类结构\">#</a> 查 &quot;术&quot; 理: (查看源码，明晰基本的类结构)</h2>\n<p>先来看下 和  <code>Stream</code>  直接相关的类。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E7%B1%BB%E5%9B%BE%E8%B0%B1.png\" alt=\"\"></p>\n<p><code>Stream</code>  接口继承了 <code>BaseStream</code>  接口.</p>\n<p><span class=\"label success\">✔️ BaseStream 接口表示流的基本接口，而流是支持顺序和并行聚合操作的元素序列。</span><br>\n <code>Stream</code>  接口有很多实现类。其主要的一个实现类是  <code>ReferencePipeline</code>  类。除此之外 <code>ReferencePipeline</code>  类还继承了 <code>AbstractPipeline</code>  抽象类. <span class=\"label success\">✔️ AbstractPipeline 表示 “管道” 类的抽象基类，它们是 Stream 接口及其原始特化的核心实现。</span>再看 <code>AbstractPipeline</code>  类的父类 <code>PipelineHelper</code> ,<span class=\"label success\">✔️ AbstractPipeline 的作用是：用于执行流管道的辅助类，将有关流管道的所有信息（输出形状、中间操作、流标志、并行度等）集中在一个地方。</span></p>\n<p><code>ReferencePipeline</code>  类有三个子类:  <code>StatefulOp</code>  表示有状态的操作， <code>StatelessOp</code>  表示无状态的操作，  <code>Head</code>  表示  <code>ReferencePipeline</code>  的起始阶段。 当然了，这三个子类也是 流。</p>\n<h3 id=\"从创建流开始\"><a class=\"markdownIt-Anchor\" href=\"#从创建流开始\">#</a> 从创建流开始</h3>\n<p>不管是使用  <code>Stream.of(T t)</code>  还是  <code>Collection.stream()</code> ，还是 <code>Arrays.stream()</code> , 底层的实现都是通过  <code>StreamSupport.stream()</code>  来实现的。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.of%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p><span class=\"label success\">✔️ StreamSupport 类的作用是：用于创建和操作流的底层实用方法。</span></p>\n<p><img data-src=\"/images/java/jdk/stream/StreamSupport.stream%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到 直接返回的是  <code>ReferencePipeline.Head</code>  对象。 首先  <code>Head</code>  是一种 <code>Stream</code>  的实现。 接着去看  <code>Head</code>  的构造方法，可以看到其实调用的是： <code>AbstractPipeline</code>  的构造方法.</p>\n<h3 id=\"流的中间操作\"><a class=\"markdownIt-Anchor\" href=\"#流的中间操作\">#</a> 流的中间操作</h3>\n<p>文中已经谈及了 中间操作分为有状态的中间操作和无状态的中间操作。那我们以一个案例来说明操作与操作之间执行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">          .map(item -&gt; item + <span class=\"number\">5</span>)</span><br><span class=\"line\">          .sorted((n1, n2) -&gt; n2 - n1)</span><br><span class=\"line\">          .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p><code>Stream.of()</code>  方法上文已经简单的说明了，接下来我们来看  <code>map()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png\" alt=\"\"></p>\n<p>可以看到， <code>map()</code>  返回了一个 <code>StatelessOp</code>  对象，并且重写了 <code>AbstractPipeline</code>  的 <code>opWrapSink</code>  方法。 之前也说过：它表示流的无状态中间阶段的基类。 还有一个 <code>Sink</code>  类型.  <code>Sink</code>  类表示  <code>Consumer</code>  接口的扩展，用于在流管道的各个阶段传递值，以及管理大小信息、控制流等的附加方法。</p>\n<p>我们再仔细看一下这个方法。首先这个方法并没有进行任何的计算，只是将  <code>item -&gt; item + 5</code>  这个操作进行三层的封装， 1. 将 <code>map</code>  方法的返回值重新封装成了流对象，2. 把我们的 <code>item -&gt; item + 5</code>  这个操作封装成了  <code>StatelessOp</code> ， 并重写了 <code>opWrapSink</code>  这个方法，并在终止操作时进行调用。 3. 使用 <code>sink</code> ( <code>Sink.ChainedReference)</code>  将管道的各个阶段连接起来。即赋值 <code>downStream</code> . 使用 <code>downstream</code>  这个 <code>Consumer</code>  完成 <code>accept</code>  调用。</p>\n<p>这里需要注意一下:  <code>StatelessOp</code>  类的构造方法的实体参传输了一个  <code>this</code>  字段。仔细翻看源码就会返现它一直调用到  <code>AbstractPipeline</code>  的构造方法中。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.png\" alt=\"\"></p>\n<p>可以看到  <code>AbstractPipeline</code>  中有两个字段  <code>nextStage</code>  和  <code>previousStage</code>  字段，分别表示的是上一阶段和下一阶段。其中  <code>nextStage</code>  是 当前阶段。  <code>previousStage</code>  则应该 当前阶段的上一个阶段，其实就是调用当前方法的对象。</p>\n<p>不知道你是否发现 通过这种方法， <code>stream</code>  组成了一个 流各个阶段的双向链表。节点就是流操作的各个阶段。</p>\n<p>ps: 这样一次流操作会创建两个链表:  <code>Stream</code>  阶段的双向链表，和 在终止操作时，根据双向链表生成的  <code>Sink</code>  链表。</p>\n<p>再次说明：到目前为止， <code>map()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n<p>接着来看  <code>sorted()</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/stream.sorted%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>sorted</code>  方法比较简单，通过调用 <code>SortedOps</code>  类的 <code>makeRef</code>  方法，创建了 <code>OfRef</code>  对象。  <code>OfRef</code>  类的作用是：用于对流进行排序的专用子类型。  <code>OfRef</code>  类继承了  <code>ReferencePipeline.StatefulOp</code>  ，所以 <code>OfRef</code>  是一个有状态操作。那自然它也会有  <code>opWrapSink</code>  方法。也就是说它也会返回一个 Sink 对象，只是这个 <code>Sink</code>  对象的实现类不一样的。</p>\n<blockquote>\n<p>说明：到目前为止， <code>sorted()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>同理去看 <code>limit</code>  方法。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.limit%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这个方法的内部是直接创建了一个  <code>ReferencePipeline.StatefulOp</code>  对象，也是重写了其中的方法:  <code>opWrapSink</code> .</p>\n<p>不知道你是否有好奇，我为什么每次都会提到  <code>opWrapSink</code>  这个方法呢？因为这个方法非常的重要！其重要性我们在 <a href=\"#%E6%8E%A2%E2%80%9D%E6%B3%95%E2%80%9C%E6%8B%A9\">探” 法 “择</a> 这部分会完整的说明。</p>\n<blockquote>\n<p>再三说明：到目前为止， <code>limit()</code>  方法里只是进行了封装，没有进行任何计算！</p>\n</blockquote>\n<p>书行至此，案例中的中间操作都已经简单的分析完成了。我们就知道这里  <code>jdk</code>  为了完成 流操作为每个中间操作都封装了很多的对象，而这些对象只是散列在了内存中。接下来，就要看  <code>jdk</code>  是如何把他们组装到一起的。</p>\n<h3 id=\"终止操作\"><a class=\"markdownIt-Anchor\" href=\"#终止操作\">#</a> 终止操作</h3>\n<p>以 <code>Collect</code>  方法为例，去探究一下终止操作的流程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream.collect%E6%96%B9%E6%B3%95.png\" alt=\"\"><br>\n可以看到在 <code>collect</code>  方法中，分为并行执行方式和串行执行方法，我们看串行执行时，会创建  <code>ReduceOps</code>  终止操作对象。<br>\n<img data-src=\"/images/java/jdk/stream/AbstractPipeline.evaluate%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>将 终止操作 传递给 evaluate 方法，然后调用终止操作的 evaluate 方法，当然这个方法也分成了串行执行和并行执行两种。</p>\n<p><img data-src=\"/images/java/jdk/stream/ReduceOps.evaluateSequential%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p><code>helper</code>  其实是  <code>limit(3)</code>  中间操作返回的对象。这其实中间操作的最后一个 <code>Stage</code>  (阶段)。返回的对象是 <code>AbstractPipeline</code>  和  <code>Stream</code>  的子类实例。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapAndCopyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>这里包含两个方法:  <code>wrapSink()</code>  和  <code>copyInfo()</code> .</p>\n<p>这是两个非常重要的方法.  <code>wrapSink()</code>  是将中间的操作组成  <code>SinkChain</code>  。  <code>copyInfo()</code>  这是执行真正的计算逻辑。</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.wrapSink%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>方法中的形参  <code>sink</code>  就是最后的阶段的终止操作。方法通过循环将  <code>sink</code>  分装到 <code>Sink</code>  中。  <code>Sink</code>  接口 的一个实现类是  <code>ChainedReference</code>  ， 类中定义了一个  <code>downStream</code>  字段。 会将 <code>sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</code>   中的  <code>sink</code>  赋值给  <code>downStream</code> . 这样就形成了 <b>套娃</b>。 最后返回一个  <code>wrapSink</code>  , 即整个流操作中所有的操作的 封装 <code>Sink</code> .</p>\n<p><img data-src=\"/images/java/jdk/stream/AbstractPipeline.copyInfo%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>图中所示的即为上面提及的 封装 <code>Sink</code> . 可中断和不可中断的区别是：可中断如果获取值，就不必再取所有的结果了。反之，就需要计算出所有阶段的结果。</p>\n<p>非可中断的终止操作时，会执行  <code>begin()</code> , <code>forEachRemaining()</code> , <code>end()</code> , 三个方法。  这个三个方法对应的是： <code>Sink</code>  接口中提供的三个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Sink开始之前调用该方法，通知sink做好准备</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历元素时使用，接受一个待处理元素，并对元素进行处理。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Double i)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 通知sink没有元素进行处理了。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，</p>\n<ul>\n<li><code>begin()</code>  方法，会调用每个 <code>Sink</code>  子类的 <code>begin</code>  方法。</li>\n<li><code>forEachRemaining()</code>  方法对应的执行内容如下图:<br>\n<img data-src=\"/images/java/jdk/stream/forEachRemaining%E6%96%B9%E6%B3%95.png\" alt=\"\"></li>\n<li><code>end()</code>  方法，会调用每个 <code>Sink</code>  字段的 <code>end</code>  方法。</li>\n</ul>\n<p>书行至此。或许你会对  <code>forEachRemaining</code>  方法感到好奇。后面我会写一篇文章来专门分享: 《 <code>Stream</code>  的高级迭代器》, 希望你能继续关注支持我～</p>\n<h2 id=\"探法择\"><a class=\"markdownIt-Anchor\" href=\"#探法择\">#</a> 探” 法 “择</h2>\n<p>我们从一个案例出发，在细节之处分析了一个 <code>Stream</code>  的执行过程。现在我们需要从全局来看一下  <code>Stream</code>  的执行过程是什么样子的.</p>\n<p>上文中我们知道了  <code>Stream</code>  的 所有计算都是在 终止操作时 触发的。 所有的中间操作都是封装了一些对象。我们用一张图来描述下 <code>Stream</code>  的执行过程。</p>\n<p><img data-src=\"/images/java/jdk/stream/Stream%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"\"></p>\n<ul>\n<li><code>stream</code>  将创建的流做为第一个  <code>Stage</code>  , 用来代表流的开始， 每个 <code>Stage</code>  都是 <code>AbstractPipeline</code>  的子类。 第一个 <code>Stage</code>  是 <code>AbstractPipeline.Head</code>  对象。</li>\n<li>然后将中间操作封装成后面的 n 个  <code>stage</code> . 并组成 双向链表的形式，并且存储了 <code>stage0</code> . 每个 <code>Stage</code>  都是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .</li>\n<li>终止操作通过 <code>wrapSink()</code>  方法 会触发将 每个阶段的操作封装成  <code>Sink</code> . 并且 <code>sink</code>  都会做为参数传递到上一个阶段的 <code>opWrapSink()</code>  方法中，从而组成一个  <code>sink</code>  链表。</li>\n<li>然后，通过  <code>copyInfo()</code>  方法将，交于 <code>Spilterator</code>  进行迭代。计算的结果可以分为四种\n<ul>\n<li>返回 <code>boolean</code>  类型的结果：比如 <code>anyMatch()</code>   <code>allMatch()</code>   <code>noneMatch()</code>  方法。</li>\n<li>返回 <code>Optional</code>  类型的结果： 比如 <code>findFirst()</code>   <code>findAny()</code>  方法</li>\n<li>还有归约操作:\t <code>reduce()</code>   <code>collect()</code></li>\n<li>返回数组的： <code>toArray()</code> <br>\n 对于表中返回 <code>boolean</code>  或者 <code>Optional</code>  的操作（ <code>Optional</code>  是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 <code>Sink</code>  中记录这个值，等到执行结束时返回就可以了。<br>\n对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。 <code>collect()</code> ,  <code>reduce()</code> ,  <code>max()</code> ,  <code>min()</code>  都是归约操作，虽然 <code>max()</code>  和 <code>min()</code>  也是返回一个 <code>Optional</code> ，但事实上底层是通过调用 <code>reduce()</code>  方法实现的。<br>\n对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做 <code>Node</code>  的数据结构中的。 <code>Node</code>  是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于  <code>Stream</code>  的并行计算，我后面会继续分享。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"明道义\"><a class=\"markdownIt-Anchor\" href=\"#明道义\">#</a> 明 &quot;道&quot; 义</h2>\n<p><code>JDK</code>  提供的  <code>Stream</code>  具有如下特点:</p>\n<ul>\n<li>无存储。 <code>stream</code>  不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组， <code>Java</code>  容器或 <code>I/O channel</code>  等。</li>\n<li>为函数式编程而生。对 <code>stream</code>  的任何修改都不会修改背后的数据源，比如对 <code>stream</code>  执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新 <code>stream</code> 。</li>\n<li>惰式执行。 <code>stream</code>  上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li>可消费性。 <code>stream</code>  只能被 “消费” 一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n<blockquote>\n<p>在这一趴，我就围绕两个点来简单的聊聊。</p>\n</blockquote>\n<ul>\n<li><code>JDK8</code>  为什么要加入  <code>Stream</code> .</li>\n</ul>\n<p>除了上面四个特点之外， <code>Java8</code>  中的 <code>Stream</code>  是对集合对象的增强，当然不仅仅是集合对象。 <code>Stream</code>  为开发者提供了简洁的编码方式和编码风格，极大的提高了开发的效率。</p>\n<p>另外一个更重要的点在于  <code>Stream</code>  为我们下篇文章要分享的 <b> <code>Stream</code>  并行计算流</b> 提供了实现，请期待。</p>\n<ul>\n<li><code>Stream</code>  为什么要这么设计？</li>\n</ul>\n<p>我这里给一份我的回答，这个问题也留给看文章的你，也希望能看到你的回答。</p>\n<p>根据上文所说的内容， <code>Stream</code>  体系是一组接口家族， <code>AbstractPipeline </code> 是接口的实现， <code>PipelineHelper</code>  是管道的辅助类， <code>StreamSupport</code>  是流的底层工具类</p>\n<p><code>Stream</code>  使用 <code>stage</code>  来抽象流水线上的每个操作，其实每个 <code>stage</code>  就是一个 <code>stream</code>  子类的实例， 也就是 <code>AbstractPipeline</code>  几个子类的内部子类即 <code>Head</code>   <code>StatelessOp</code>   <code>statefulOp</code> ;</p>\n<p><code>StreamSupport</code>  用于创建生成 <code>Stream</code>  对应的是 <code>Head</code>  类，其他的中间操作分为有状态和无状态的，中间操作通过方法比如  <code>filter</code>   <code>map</code>  等返回的是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .  多个 <code>stage</code>  组合称为双向链表的形式 从而成了整个流水线</p>\n<p>有了流水线，相邻两个操作阶段之间如何协调运算？</p>\n<p>于是又有了 <code>Sink</code>  的概念，又来协调相邻的 <code>stage</code>  之间计算运行</p>\n<p>他的模式是 <code>begin</code>    <code>accept</code>   <code>end</code>  还有短路标记</p>\n<p>他的 <code>accept</code>  就是封装了回调方法，所以说每个操作 <code>stage</code> ,  <code>StatelessOp</code>   或者  <code>statefulOp</code>  中又封装了 <code>Sink</code> . 通过 <code>AbstractPipeline</code>  提供的 <code>opWrapSink</code>  方法可以获取这个 <code>Sink</code></p>\n<p>调用这个 <code>sink</code>  的 <code>accept</code>  方法就可以调用当前操作的方法</p>\n<p>那么如何串联起来呢？</p>\n<p>关键点在于 <code>opWrapSink</code>  方法，他接收一个 <code>Sink</code>  作为参数，在调用 <code>accept</code>  方法中。可以调用这个入参 <code>Sink</code>  的 <code>accept</code>  方法</p>\n<p>这样子从当前就能调用下一个，也就是说有了推动的动作。那么只需要找到开始，每个处理了之后都推动下一个，就顺序完成了所欲的操作了。</p>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\">#</a> 结语</h2>\n<p>通过看  <code>Stream</code>  相关的知识点，发现一篇文章是没法讲清楚的。</p>\n<p>这一次，我又果不其然的留下了两篇文章</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\"><label for=\"cbx_0\">  <code>Stream</code>  并行计算流</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\"><label for=\"cbx_1\">  <code>Stream</code>  的高级迭代器</label></li>\n</ul>\n<p>请给我记代办～</p>\n<p>在分享 <code>并行计算流</code> 的时候，我们需要以  <code>JDK1.7</code>  中的  <code>forkJoin</code>  框架为前提，来分析  <code>Stream</code>  的  <code>parallelStream</code> .</p>\n<p>在分享 <code>迭代器</code> 的时候，我们也会分析一下 <code>JDK</code>  中提供的 普通迭代器，比如  <code>ForEach</code> ,  <code>iterator</code> , 以及 <code>Stream</code>  的高级迭代器  <code>spliterator</code> . 也会由浅入深的分析一下，各种迭代器的优缺点。 也会自定义实现一个迭代器。</p>\n<p>敬请期待，防止走丢见文末。关注我，期望和你一起遇见更好的自己.</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望和你一起遇见更好的自己</p>\n<p><img data-src=\"/images/java/jdk/stream/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "Java",
                "JDK",
                "Stream"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/",
            "url": "https://fangjiaxiaobai.github.io/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/",
            "title": "JVM之你没见过的OOM",
            "date_published": "2021-08-19T09:13:55.000Z",
            "content_html": "<p>一文搞懂内存溢出，保内存平安，防止你被祭天:[手动滑稽]:</p>\n<h2 id=\"释义\"><a class=\"markdownIt-Anchor\" href=\"#释义\">#</a> 释义</h2>\n<p><code>OOM</code>  的含义，到底是什么意思？<br>\n 是 JVM 独有的吗？  <code>linux</code>  是否也会存在，那又是怎么肥事？</p>\n<p><code>OOM</code>  :  <code>Out Of Memory</code>  .  内存溢出。内存溢出来了，也就是说内存不够用了，就会发生这个问题了。</p>\n<h3 id=\"内存又是什么呢\"><a class=\"markdownIt-Anchor\" href=\"#内存又是什么呢\">#</a> 内存又是什么呢？</h3>\n<p>1、 内存 是计算机的重要部件之一。它用于暂时存放 CPU 中的运算数据，与硬盘等外部存储交换数据。是外存与 <code>CPU</code>  进行沟通的桥梁。</p>\n<p>2、 <code>Java</code>  内存。说到这里我们就不得说一下 java 的内存模型 (JMM) 了。如下图。</p>\n<p><img data-src=\"/images/java/jvm/JMM.png\" alt=\"JMM\"></p>\n<p>就这个一个图就很不下几十个面试考点：比如 <code>votitle</code>  关键字，内存栅栏，指令重排，5 项 <code>Happen-Before</code>  原则，内存原子操作，数据 <code>IO</code>  操作等等。</p>\n<p>闲话少扯，抛个问题， <code>OOM</code>  发生区域会上图中那个部分发生呢？</p>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p><code>java</code>  运行时内存区域  <code>JAVA RUNTIME MEMEORY AREA</code> , 注意区分 <code>JMM</code> .</p>\n<p>大家都知道的， <code>java</code>  运行时内存区域，分为程序计数器 (PC 寄存器)，java 虚拟机栈，本地方法栈，堆，方法区，运行时常量池，堆外内存 (直接内存)</p>\n<p>1、程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为 <code>Undefined</code> 。</p>\n<p>2、 <code>Java</code>  虚拟机栈是描述  <code>Java</code>  方法运行过程的内存模型。 <code>Java</code>  虚拟机栈会为每一个即将运行的  <code>Java</code>  方法创建一块叫做 “栈帧” 的区域，用于存放该方法运行过程中的一些信息，比如：局部变量表，操作数栈，动态链接，方法出口信息等，方法执行的过程即为栈帧压栈出栈的过程。</p>\n<p>3、本地方法栈是为  <code>JVM</code>  运行  <code>Native</code>  方法准备的空间，由于很多  <code>Native</code>  方法都是用  <code>C</code>  语言实现的，所以它通常又叫  <code>C</code>  栈。它与  <code>Java</code>  虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>\n<p>4、堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。这一区域是线程共享，整个  <code>Java</code>  虚拟机只有一个堆，所有的线程都访问同一个堆。堆又可划分为年轻代和老年代，年轻代内存又可以分为 <code>Eden</code> ,  <code>from Surivor</code> , <code>to Surivor</code> , 并且默认以 8:1:1 的比例进行分配。</p>\n<p>5、方法区： <code>Java</code>  虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：已经被虚拟机加载的类信息，常亮，静态变量，即时编译编译器编译后的代码。线程共享的区域。为了与堆区分，方法还有一个别名： <code>Non-Heap</code>  (非堆)。</p>\n<p>5.1 、运行时常量池：存放常量的区域。 在运行期间，可以向常量池中添加新的变量，如  <code>String</code>  类的 <code>intern()</code>  方法。</p>\n<p>6、堆外内存是 <code>java</code>  虚拟机之外的内容，但也可能被 <code>java</code>  使用。需要注意的是，这部分内容也会因内存不足而抛出  <code>OutOfMemoryError</code> 、</p>\n<p>知道了 <code>Java</code>  运行内存区域，那么可能发生  <code>OOM</code>  的区域有哪些呢？</p>\n<p>我们都知道 <code>OOM</code>  只的是内存溢出，所以 堆，非堆即方法区，本地方法栈，以及堆外内存 都是会发生  <code>OOM</code>  的。</p>\n<p>那 <code>java</code>  虚拟机栈呢？不会发生内容溢出吗？   会！但是 栈发生内容溢出的时候，报的错误是  <code>StackOverflowError</code> .</p>\n<p>那程序计数器呢？  程序计数器，是不会发送内容溢出的。 因为 存储的是：当前线程正在执行的那条字节码指令的地址啊。</p>\n<p>如下图：</p>\n<p><img data-src=\"/images/java/jvm/OOM%E5%8C%BA%E5%9F%9F%E5%9B%BE.png\" alt=\"OOM区域图\"></p>\n<p>在上图中还指定了各区域大小的参数配置：</p>\n<ul>\n<li>\n<p><code>-Xms</code>  设置堆的最小空间大小。</p>\n</li>\n<li>\n<p><code>-Xmx</code>  设置堆的最大空间大小。</p>\n</li>\n<li>\n<p><code>-XX:NewSize</code>  设置新生代最小空间大小。</p>\n</li>\n<li>\n<p><code>-XX:MaxNewSize</code>  设置新生代最大空间大小。</p>\n</li>\n<li>\n<p><code>-XX:PermSize</code>  设置永久代最小空间大小。</p>\n</li>\n<li>\n<p><code>-XX:MaxPermSize</code>  设置永久代最大空间大小。</p>\n</li>\n<li>\n<p><code>-Xss</code>  设置每个线程的堆栈大小。</p>\n</li>\n</ul>\n<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。  <code>老年代空间大小=堆空间大小-年轻代大空间大小</code></p>\n<h2 id=\"场景分析\"><a class=\"markdownIt-Anchor\" href=\"#场景分析\">#</a> 场景分析</h2>\n<p>我们挨个分析下发生 <code>OOM</code>  的 9 种场景</p>\n<p>什么时候会发生 <code>OOM</code>  呢？  当内存严重不够用的时候就会发生   <code>java.lang.OutOfMemoryError</code>  。</p>\n<p>我们来看下每个区域都有可能出现内存溢出问题.</p>\n<h3 id=\"javaheap-space\"><a class=\"markdownIt-Anchor\" href=\"#javaheap-space\">#</a>  <code>JavaHeap space</code></h3>\n<p>当堆内存（ <code>Heap Space</code> ）没有足够空间存放新创建的对象时，就会抛出  <code>java.lang.OutOfMemoryError:Javaheap space</code>  错误。</p>\n<p><code>Javaheap space</code>  错误产生的常见原因可以分为以下几类：</p>\n<p>1. 请求创建一个超大对象，通常是一个大数组。<br>\n2. 超出预期的访问量 / 数据量，通常是上游系统请求流量飙升，常见于各类促销 / 秒杀活动，可以结合业务流量指标排查是否有尖状峰值。<br>\n3. 过度使用终结器（ <code>Finalizer</code> ），该对象没有立即被  <code>GC</code> 。<br>\n4. 内存泄漏（ <code>Memory Leak</code> ），大量对象引用没有释放， <code>JVM</code>  无法对其自动回收，常见于使用了  <code>File</code>  等资源没有回收。</p>\n<h4 id=\"解决方案\"><a class=\"markdownIt-Anchor\" href=\"#解决方案\">#</a> 解决方案</h4>\n<p>针对大部分情况，通常只需要通过  <code>-Xmx</code>  参数调高  <code>JVM</code>  堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p>\n<p>1、如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。<br>\n2、如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。<br>\n3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</p>\n<h4 id=\"代码案例\"><a class=\"markdownIt-Anchor\" href=\"#代码案例\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示大对象</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bigObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 21 可以，22就会OOM</span></span><br><span class=\"line\">    <span class=\"comment\">// 4* 1024 * 1024 = 4M * 32 = 128M</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] integers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">32</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/heapSpaceError.png\" alt=\"\"></p>\n<h3 id=\"gc-overhead-limit-exceeded\"><a class=\"markdownIt-Anchor\" href=\"#gc-overhead-limit-exceeded\">#</a>  <code>GC overhead limit exceeded</code></h3>\n<p>当  <code>Java</code>  进程花费  <code>98%</code>  以上的时间执行  <code>GC</code> ，但只恢复了不到  <code>2%</code>  的内存，且该动作连续重复了  <code>5</code>  次，就会抛出  <code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>  错误。简单地说，就是应用程序已经基本耗尽了所有可用内存，  <code>GC</code>  也无法回收。</p>\n<h4 id=\"解决方案-2\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-2\">#</a> 解决方案</h4>\n<p>同  <code>JavaHeap space</code>  部分的异常解决方案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示 频繁GC</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">overHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        map.put(r.nextInt(), <span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:<br>\n<img data-src=\"/images/java/jvm/gcOverHead.png\" alt=\"\"></p>\n<h3 id=\"permgen-spacejdk8-已废弃-see-元空间\"><a class=\"markdownIt-Anchor\" href=\"#permgen-spacejdk8-已废弃-see-元空间\">#</a>  <code>Permgen space</code> ( <code>JDK8</code>  已废弃， <code>see</code>  元空间。)</h3>\n<div class=\"note info\">\n<p>为什么会废弃 永久代？     <code>see</code> ： <span class=\"exturl\" data-url=\"aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8xMjI=\">http://openjdk.java.net/jeps/122</span></p>\n</div>\n<p>该错误表示永久代（ <code>Permanent Generation</code> ）已用满，通常是因为加载的  <code>class</code>  数目太多或体积太大。</p>\n<p>永久代存储对象主要包括以下几类：</p>\n<p>加载 / 缓存到内存中的  <code>class</code>  定义，包括类的名称，字段，方法和字节码；<br>\n常量池；<br>\n对象数组 / 类型数组所关联的  <code>class</code> ；<br>\n <code>JIT</code>  编译器优化后的  <code>class</code>  信息。<br>\n <code>PermGen</code>  的使用量与加载到内存的  <code>class</code>  的数量 / 大小正相关。</p>\n<h4 id=\"解决方案-3\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-3\">#</a> 解决方案</h4>\n<p>根据  <code>Permgen space</code>  报错的时机，可以采用不同的解决方案，如下所示：</p>\n<ul>\n<li>程序启动报错，修改  <code>-XX:MaxPermSize</code>  启动参数，调大永久代空间。</li>\n<li>应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份  <code>class</code>  信息，只需重启 JVM 即可解决。</li>\n<li>运行时报错，应用程序可能会动态创建大量  <code>class</code> ，而这些  <code>class</code>  的生命周期很短暂，但是 JVM 默认不会卸载  <code>class</code> ，可以设置  <code>-XX:+CMSClassUnloadingEnabled</code>  和  <code>-XX:+UseConcMarkSweepGC</code>  这两个参数允许  <code>JVM</code>  卸载  <code>class</code> 。</li>\n<li>如果上述方法无法解决，可以通过  <code>jmap</code>  命令  <code>dump</code>  内存对象  <code>jmap-dump:format=b,file=dump.hprof</code>  ，然后利用  <code>Eclipse MAT https://www.eclipse.org/mat</code>  功能逐一分析开销最大的  <code>classloader</code>  和重复  <code>class</code> 。</li>\n</ul>\n<h3 id=\"metaspace\"><a class=\"markdownIt-Anchor\" href=\"#metaspace\">#</a>  <code>Metaspace</code></h3>\n<p><code>JDK 1.8</code>  使用  <code>Metaspace</code>  替换了永久代（ <code>Permanent Generation</code> ）</p>\n<p>该错误表示  <code>Metaspace</code>  已被用满，通常是因为加载的  <code>class</code>  数目太多或体积太大。</p>\n<p>此类问题的原因与解决方法跟  <code>PermGenspace</code>  非常类似，可以参考上文。</p>\n<p>需要特别注意的是调整  <code>Metaspace</code>  空间大小的启动参数为  <code>-XX:MaxMetaspaceSize</code> 。</p>\n<h4 id=\"代码案例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-2\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示  元数据区</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 在 `for` 循环中, 动态生成很多class, 最终将这些class加载到 Metaspace 中</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意配置: -XX:MaxMetaspaceSize=64m</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">metaSpace</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; ; i++) &#123;</span><br><span class=\"line\">        Class c = cp.makeClass(<span class=\"string\">&quot;eu.plumbr.demo.Generated&quot;</span> + i).toClass();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:</p>\n<p><img data-src=\"/images/java/jvm/metaSpace.png\" alt=\"\"></p>\n<h3 id=\"unable-to-create-new-native-thread\"><a class=\"markdownIt-Anchor\" href=\"#unable-to-create-new-native-thread\">#</a>  <code>Unable to create new native thread</code></h3>\n<p>每个  <code>Java</code>  线程都需要占用一定的内存空间，当  <code>JVM</code>  向底层操作系统请求创建一个新的  <code>native</code>  线程时，如果没有足够的资源分配就会报此类错误。</p>\n<h4 id=\"原因分析\"><a class=\"markdownIt-Anchor\" href=\"#原因分析\">#</a> 原因分析</h4>\n<p><code>JVM</code>  向  <code>OS</code>  请求创建  <code>native</code>  线程失败，就会抛出  <code>Unable to create new native thread</code> ，常见的原因包括以下几类：</p>\n<p>线程数超过操作系统最大线程数  <code>ulimit</code>  限制；<br>\n线程数超过  <code>kernel.pid_max</code> （只能重启）；<br>\n <code>native</code>  内存不足；</p>\n<p>该问题发生的常见过程主要包括以下几步：</p>\n<p><code>JVM</code>  内部的应用程序请求创建一个新的  <code>Java</code>  线程；<br>\n <code>JVM native</code>  方法代理了该次请求，并向操作系统请求创建一个  <code>native</code>  线程；<br>\n操作系统尝试创建一个新的  <code>native</code>  线程，并为其分配内存；<br>\n如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次  <code>native</code>  内存分配；<br>\n <code>JVM</code>  将抛出  <code>java.lang.OutOfMemoryError:Unableto createnewnativethread</code>  错误。</p>\n<h4 id=\"解决方案-4\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-4\">#</a> 解决方案</h4>\n<ul>\n<li>升级配置，为机器提供更多的内存；</li>\n<li>降低  <code>Java Heap Space</code>  大小；</li>\n<li>修复应用程序的线程泄漏问题；</li>\n<li>限制线程池大小；</li>\n<li>使用  <code>-Xss</code>  参数减少线程栈的大小；</li>\n<li>调高  <code>OS</code>  层面的线程最大数：执行  <code>ulimit -a</code>  查看最大线程数限制，使用  <code>ulimit -u xxx</code>  调整最大线程数限制。</li>\n</ul>\n<h4 id=\"代码案例-3\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-3\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示: Unable to create new native thread</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">nativeThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容:</p>\n<p><img data-src=\"/images/java/jvm/unableCreateNative.png\" alt=\"\"></p>\n<h3 id=\"out-of-swap-space\"><a class=\"markdownIt-Anchor\" href=\"#out-of-swap-space\">#</a>  <code>Out of swap space</code></h3>\n<p>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（ <code>Virtual Memory</code> ）由物理内存（ <code>Physical Memory</code> ）和交换空间（ <code>Swap Space</code> ）两部分组成。当运行时程序请求的虚拟内存溢出时就会报  <code>Outof swap space</code>  错误。</p>\n<p>这个错误通常是操作系统层面的原因。</p>\n<h4 id=\"原因分析-2\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-2\">#</a> 原因分析</h4>\n<p>该错误出现的常见原因包括以下几类：</p>\n<ul>\n<li>\n<ol>\n<li>地址空间不足；</li>\n</ol>\n</li>\n<li>2. 物理内存已耗光；</li>\n<li>3. 应用程序的本地内存泄漏（ <code>native leak</code> ），例如不断申请本地内存，却不释放。</li>\n<li>4. 执行  <code>jmap-histo:live</code>  命令，强制执行  <code>Full GC</code> ；如果几次执行后内存明显下降，则基本确认为  <code>Direct ByteBuffer</code>  问题。</li>\n</ul>\n<h4 id=\"解决方案-5\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-5\">#</a> 解决方案</h4>\n<p>根据错误原因可以采取如下解决方案：</p>\n<ul>\n<li>\n<ol>\n<li>升级地址空间为  <code>64 bit</code> ；</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>使用  <code>Arthas</code>  检查是否为  <code>Inflater/Deflater</code>  解压缩问题，如果是，则显式调用  <code>end</code>  方法。</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li><code>Direct ByteBuffer</code>  问题可以通过启动参数  <code>-XX:MaxDirectMemorySize</code>  调低阈值。</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>升级服务器配置 / 隔离部署，避免争用。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"kill-process-or-sacrifice-child\"><a class=\"markdownIt-Anchor\" href=\"#kill-process-or-sacrifice-child\">#</a>  <code>Kill process or sacrifice child</code></h3>\n<p>有一种内核作业（ <code>Kernel Job</code> ）名为  <code>Out of Memory Killer</code> ，它会在可用内存极低的情况下 “杀死”（ <code>kill</code> ）某些进程。 <code>OOM Killer</code>  会对所有进程进行打分，然后将评分较低的进程 “杀死”，具体的评分规则可以参考  <code>Surviving the Linux OOM Killer</code> 。</p>\n<p>不同于其他的  <code>OOM</code>  错误，  <code>Killprocessorsacrifice child</code>  错误不是由  <code>JVM</code>  层面触发的，而是由操作系统层面触发的。</p>\n<h4 id=\"原因分析-3\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-3\">#</a> 原因分析</h4>\n<p>默认情况下， <code>Linux</code>  内核允许进程申请的内存总量大于系统可用内存，通过这种 “错峰复用” 的方式可以更有效的利用系统资源。</p>\n<p>然而，这种方式也会无可避免地带来一定的 “超卖” 风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活  <code>OOM Killer</code> ，寻找评分低的进程，并将其 “杀死”，释放内存资源。</p>\n<h4 id=\"解决方案-6\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-6\">#</a> 解决方案</h4>\n<ul>\n<li>升级服务器配置 / 隔离部署，避免争用。</li>\n<li><code>OOM Killer</code>  调优。</li>\n</ul>\n<h4 id=\"代码案例-4\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-4\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示:Kill process or sacrifice child</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    java.util.List&lt;<span class=\"keyword\">int</span>[]&gt; l = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">10000</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            l.add(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">100000000</span>]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/killprocess.png\" alt=\"\"></p>\n<h3 id=\"requested-array-size-exceeds-vm-limit\"><a class=\"markdownIt-Anchor\" href=\"#requested-array-size-exceeds-vm-limit\">#</a>  <code>Requested array size exceeds VM limit</code></h3>\n<p>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。</p>\n<p>JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为  <code>Integer.MAX_VALUE-2</code> 。</p>\n<p>此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[Integer.MAX_VALUE-i];</span><br><span class=\"line\">            System.out.format(<span class=\"string\">&quot;Successfully initialized an array with %,d elements.\\n&quot;</span>, Integer.MAX_VALUE-i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容</p>\n<p><img data-src=\"/images/java/jvm/requestArraySize.png\" alt=\"\"></p>\n<h3 id=\"direct-buffer-memory\"><a class=\"markdownIt-Anchor\" href=\"#direct-buffer-memory\">#</a>  <code>Direct buffer memory</code></h3>\n<p><code>java</code>  允许应用程序通过  <code>Direct ByteBuffer</code>  直接访问堆外内存，许多高性能程序通过  <code>Direct ByteBuffer</code>  结合内存映射文件（ <code>Memory Mapped File</code> ）实现高速  <code>IO</code> 。</p>\n<h4 id=\"原因分析-4\"><a class=\"markdownIt-Anchor\" href=\"#原因分析-4\">#</a> 原因分析</h4>\n<p><code>Direct ByteBuffer</code>  的默认大小为  <code>64 MB</code> ，一旦使用超出限制，就会抛出  <code>Directbuffer memory</code>  错误。</p>\n<h4 id=\"解决方案-7\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-7\">#</a> 解决方案</h4>\n<ul>\n<li><code>Java</code>  只能通过  <code>ByteBuffer</code> . <code>allocateDirect</code>  方法使用  <code>Direct ByteBuffer</code> ，因此，可以通过  <code>Arthas</code>  等在线诊断工具拦截该方法进行排查。</li>\n<li>检查是否直接或间接使用了  <code>NIO</code> ，如  <code>netty</code> ， <code>jetty</code>  等。</li>\n<li>通过启动参数  <code>-XX:MaxDirectMemorySize</code>  调整  <code>Direct ByteBuffer</code>  的上限值。</li>\n<li>检查  <code>JVM</code>  参数是否有  <code>-XX:+DisableExplicitGC</code>  选项，如果有就去掉，因为该参数会使  <code>System.gc()</code>  失效。</li>\n<li>检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用  <code>sun.misc.Cleaner</code>  的  <code>clean()</code>  方法来主动释放被  <code>Direct ByteBuffer</code>  持有的内存空间。</li>\n<li>内存容量确实不足，升级配置。</li>\n</ul>\n<h4 id=\"代码案例-5\"><a class=\"markdownIt-Anchor\" href=\"#代码案例-5\">#</a> 代码案例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示对外内存溢出</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">error</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;maxDirectMemory : &quot;</span> + (sun.misc.VM.maxDirectMemory() / (<span class=\"keyword\">double</span>) (<span class=\"number\">1024</span> * <span class=\"number\">1024</span>)) + <span class=\"string\">&quot;MB&quot;</span>);</span><br><span class=\"line\">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class=\"number\">6</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\">    System.out.println(byteBuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>报错内容<br>\n<img data-src=\"/images/java/jvm/directBuffer.png\" alt=\"\"></p>\n<h2 id=\"排查思路\"><a class=\"markdownIt-Anchor\" href=\"#排查思路\">#</a> 排查思路</h2>\n<p>分享遇到 <code>OOM</code>  类问题如何快速定位问题，具体哪行代码发生了问题</p>\n<p>什么表现会发生 <code>OOM</code>  呢？</p>\n<p>最直接的～，有报错， <code>outOfMemoryError</code> 。 就是发生了。<br>\n有频繁 <code>GC</code>  的事件发生的时候，也要注意下，可能是在  <code>OOM</code>  的边缘疯狂试探。 比如  <code>FullGC</code> ，  <code>Young GC</code> , 等。<br>\n <code>CPU</code>  占用率较高。<br>\n先说一个思路哈～</p>\n<h3 id=\"止损\"><a class=\"markdownIt-Anchor\" href=\"#止损\">#</a> 止损。</h3>\n<p>如果你在线上遇到了这个问题， 请，务必！ 先将服务重启！立刻，马上。 及时止损。  <code>ps</code> : 可以留一台机器做案发现场，记得下掉该机器，不对外提供服务。</p>\n<h3 id=\"问题排查\"><a class=\"markdownIt-Anchor\" href=\"#问题排查\">#</a> 问题排查</h3>\n<p>注意观察线上服务情况，如果再次出现 <code>OOM</code> , 影响业务，再问题没有解决完成之前，还是采用重启的方式解决。<br>\n可以通过  <code>glowroot</code>  等可视化的监控工具，观察。<br>\n也可以通过在机器上 使用   <code>jstat -gc pid</code>  来查看 <code>GC</code>  情况。<br>\n分析造成 <code>OOM</code>  的问题。(具体如何排查，可参考案例模块)</p>\n<p>查到对应 <code>JVM</code>  进程 =&gt;  排查到占用内存打的 <code>jvm</code>  线程 =&gt; 查看对应线程栈信息 =&gt; 使用 <code>Jmap</code>  来生成线程堆栈信息文件 =&gt; 分析大对象 <code>or</code>  占用内存大的原因 =&gt;  基本上改代码或者 <code>jvm</code>  配置。</p>\n<p>其他排查问题思路和这个也是大差不差，使用的命令不同而已。</p>\n<h3 id=\"案例\"><a class=\"markdownIt-Anchor\" href=\"#案例\">#</a> 案例</h3>\n<details class=\"warning\"><summary>举个栗子🌰吧</summary><div>\n<p>比较常见的应该是：  <code>java.lang. outOfMemoryError: Java heap Space</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示OOM 排查过程</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSpaceError</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; bigObject());</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 演示大对象</span></span><br><span class=\"line\"><span class=\"comment\"> * -Xms128M -Xmx128M</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bigObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 21 可以，22就会OOM</span></span><br><span class=\"line\">    <span class=\"comment\">// 4* 1024 * 1024 = 4M * 32 = 128M</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] integers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">22</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后发现控制台打印出了 <code>OOM</code>  :  <code>java heap space</code> .  好吧，就装作看不见吧</p>\n<p>1、使用  <code>jps</code>  命令获取到  <code>jvm</code>  进程号</p>\n<p><img data-src=\"/images/java/jvm/oom%E6%A1%88%E4%BE%8Bjps.png\" alt=\"\"></p>\n<p>2、使用  <code>jmap</code>  命令 <code>dump</code>  出 堆栈信息。<br>\n<img data-src=\"/images/java/jvm/jdump.png\" alt=\"\"></p>\n<p>3、使用  <code>mat</code>  工具，分析 <code>dump</code>  文件内容。  (下载地址:  <code>https://www.eclipse.org/mat/downloads.php</code>    下载是真特🐴的慢啊，<span class=\"label success\">❤️一般人我不告诉他：公众号回复 <code>MAT</code>  就能直接获取</span>)</p>\n<blockquote>\n<p>如果下载之后无法启动的话，提示 无法创建虚拟机。需要简单配置下：<br>\n <code>-vm /Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/bin</code></p>\n</blockquote>\n<p>3.1、下载下 <code>dump</code>  文件，使用本地分析 <code>mat</code>  工具进行分析。</p>\n<p>启动 <code>mat</code> .<br>\n<img data-src=\"/images/java/jvm/mat.png\" alt=\"\"></p>\n<p><code>Open a  heap Dump</code>  之后，就可以愉快的分析了。</p>\n<p>具体分析方法请自行百度吧。</p>\n<p>3.2、如果 <code>dump</code>  文件较小，也可以 <code>java</code>  自带的工具 jhat 命令进行分析。<br>\n<img data-src=\"/images/java/jvm/jmap.png\" alt=\"\"></p>\n<p>然后访问本机的  <code>7000</code>  端口，就可以到看到分析的内容了。<br>\n<img data-src=\"/images/java/jvm/image2021-4-15_19-8-56.png\" alt=\"\"><br>\n进入之后，就可以看到堆内存占用情况的柱状图了。<br>\n<img data-src=\"/images/java/jvm/heapHistogram.png\" alt=\"\"><br>\n发现有  <code>Class[I</code>  占用最多，     <code>Class[I</code>  表示的是  <code>int</code>  数组。 那我们就查下代码里用到 <code>Class[I</code>  中的地方，</p>\n<p>哇，果然是在  <code>new</code>  了一个大的数据，撑爆了内存。</p>\n<p>补充下：</p>\n<p>先查看 jvm 进程号 <br>\n <code> jps </code>   注意：只能查看属于当前用户 <code>java</code>  进程<br>\n  <code>ps -ef| grep java</code>  找到对应服务的进程编号<br>\n <code>ps -ef| grep 服务名</code></p>\n<p>如下图:<br>\n<img data-src=\"/images/java/jvm/%E8%A1%A5%E5%85%85.png\" alt=\"\"><br>\n 需要注意下:</p>\n<p>1) 查看当前应用运行情况信息，查看是否配置了 <code>gc log：-Xloggc:/apps/srv/instance/damai.gaotu100.com/logs/damai.gaotu100.com-gc.log</code>   , 可以从 <code>gc</code>  日志中查到很多信息。</p>\n<p>2）查看是否有 <code>oom</code>  自动打印二进制 <code>dump</code>  文件：  <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/apps/srv/instance/damai.gaotu100.com/logs/heapdump.hprof</code>   。</p>\n<blockquote>\n<p>如果没有配置，可以通过命令自行打印:   <code>jmap -dump:format=b,file=/apps/srv/instance/test-kefu-web.baijiahulian.com/logs/22316.1.hprof pid</code></p>\n</blockquote>\n<p>这里推荐下，阿里开源的 jvm 排查工具  arthas（阿尔萨斯）  <code>https://arthas.aliyun.com/doc/</code> 。文档很全，需要的自行阅读吧～～</p>\n</div></details>\n<h2 id=\"解决方案-8\"><a class=\"markdownIt-Anchor\" href=\"#解决方案-8\">#</a> 解决方案</h2>\n<p>分享遇到 <code>OOM</code>  问题时怎样解决？</p>\n<blockquote>\n<p>长兄于病视神，未有形而除之，故名不出于家。中兄治病，其在毫毛，故名不出于闾。若扁鹊者，镵血脉，投毒药，副肌肤，闲而名出闻于诸侯。 所以才有凡此者不病病，治之无名，使之无形，至功之成，其下谓之自然。<br>\n这句话，用在我们这里就是  系统的整个生命周期中，不出现任何 <code>OOM</code> , 其 谓之自然。</p>\n</blockquote>\n<p>根据上述的排查过程，找到了问题根源之后，那就<br>\n 1. 改代码<br>\n 2. 调整内存配置</p>\n<p>大刀阔斧的干吧！</p>\n<div class=\"note success no-icon\">\n<p>大家有什么建议呢？</p>\n</div>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>我们看待 <code>OOM</code>  应该从全面来看，有可能是  <code>jvm</code>  内存确实盛不下要分配的对象，也有可能是 频繁 <code>GC</code> ，且收效甚低导致的，还有可能是宿主机上内存不够杀死 <code>jvm</code>  导致的，加载的类过大过多造成的，虚拟内存不够用等等。最后也不要忽略 堆外内存的内存溢出。</p>\n<p>线上遇到这类问题，第一要及时止损，方式很简单，重启就能解决。   保证线上可用之后，再去查问题，根治问题。  同时不用忘了监控线上服务是否有内存要溢出的情况，及时重启，为处理 <code>OOM</code>  问题争取时间。</p>\n<p>排查问题时，首先找到对应 <code>jvm</code>  进程，然后使用 <code>jmap</code>  打印出 内存映射文件，然后使用 <code>jhat</code>  或者  <code>mat</code>  工具进行分析，定位原因。解决问题。</p>\n<p>最后，我们在 <code>coding</code>  的时候，要注意下，不要编写导致 <code>OOM</code>  代码。“未有形而除之～”</p>\n<h2 id=\"抛个问题~\"><a class=\"markdownIt-Anchor\" href=\"#抛个问题~\">#</a> 抛个问题～</h2>\n<p>发生 OOM，程序会退出吗？</p>\n<blockquote>\n<p>下期见</p>\n</blockquote>\n<h4 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h4>\n<p>希望和你一起遇见更好的自己<br>\n<img data-src=\"/images/qrcode.jpg\" alt=\"\"></p>\n",
            "tags": [
                "Java",
                "OOM",
                "JVM"
            ]
        }
    ]
}