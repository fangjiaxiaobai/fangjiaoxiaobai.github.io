{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"递归\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/recursion/%E7%AE%97%E6%B3%9501-%E9%80%92%E5%BD%92/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/recursion/%E7%AE%97%E6%B3%9501-%E9%80%92%E5%BD%92/",
            "title": "递归",
            "date_published": "2021-09-01T04:33:55.000Z",
            "content_html": "<p>数据结构与算法 这一个模块 有两个最难的知识点，一个就是 递归，另一个就是 动态规划</p>\n<p>我们今天来学习下递归这种实现方式。</p>\n<p>个人认为，递归不是一种算法，就是一种语法。所以我就称它为一类问题的解决方法.</p>\n<h2 id=\"何为递归\"><a class=\"markdownIt-Anchor\" href=\"#何为递归\">#</a> 何为递归？</h2>\n<p>递归，去的过程叫递，回来的过程叫归。凡是递归类的问题，都能总结出一个递归公式.<br>\n 比如: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(n+1) = f(n) + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, 我们用代码实现就是:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n==<span class=\"number\">1</span>?<span class=\"number\">1</span>:f(n-<span class=\"number\">1</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断是否可用递归\"><a class=\"markdownIt-Anchor\" href=\"#判断是否可用递归\">#</a> 判断是否可用递归</h2>\n<p>要想使用递归来解决问题，要满足三个条件:</p>\n<ul>\n<li>一个问题的解可以分解为几个问题的解。</li>\n<li>这个问题和分解之后的问题，除了树据规模不一样，求解思路一模一样.</li>\n<li>存在递归终止条件。比如上例子中的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(n)=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ul>\n<h2 id=\"如何编写递归\"><a class=\"markdownIt-Anchor\" href=\"#如何编写递归\">#</a> 如何编写递归</h2>\n<h3 id=\"找出递推公式\"><a class=\"markdownIt-Anchor\" href=\"#找出递推公式\">#</a> 找出递推公式！</h3>\n<p>递归写法的话，最重要的就是写出递推公式，其次就是，找到终止条件.</p>\n<p>举个例子:</p>\n<p>人民币的组合方式.</p>\n<p>假设我有人民币 100 元，50 元，20 元，10 元，5 元，1 元的币种若干张，我想用这些花掉 70 元，我可以怎么花？</p>\n<p>这个问题就可以转换成了，70 元有多少中组合方式 (A) -&gt; 69 元有多少中组合方式 (B) + 65 元有几种组合方式 © + 60 元有几种组合方式 (D) + 50 元有几种组合方式 (E) + 20 元有几种组合方式 (F)。</p>\n<p>也就是说，我们把一个问题 A 分解成了若干子问题 B,C,D,E,F. 我们解决了子问题 B,C,D,E,F。 那么对应的 A 问题，也就解决了。而且，在这问题里，我们只要关心 A 与其子问题的关系即可，不用关系其他的子问题与子问题的关系。屏蔽掉递归细节。</p>\n<h2 id=\"递归实现方案的注意点\"><a class=\"markdownIt-Anchor\" href=\"#递归实现方案的注意点\">#</a> 递归实现方案的注意点</h2>\n<ul>\n<li>如果递归深度比较大的话，就会出现堆栈溢出的异常。</li>\n<li>递归的时候，要避免重复计算.<br>\n 这个的话，举个例子，就会很清晰了。斐波那契数列的计算.</li>\n</ul>\n<p>斐波那契数列就是 当前项等于前两项之和.</p>\n<p>以 fib (6) 为例，即求第 6 个数的数值。</p>\n<p>如下图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib.png\" alt=\"算法01-动态规划01-fib.png\"></p>\n<p>我们会发现: fib (4),fib (3),fib (2) 都是重复计算的。</p>\n<p>具体的解决方式呢，在 算法【动态规划】文章里，也有说过。</p>\n<p>加入一个数据，来记录就行了.<br>\n<img data-src=\"/images/dataStructuresAndAlgorithms/%E7%AE%97%E6%B3%9501-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201-fib02.png\" alt=\"算法01-动态规划01-fib02.png\"> 其中虚线边框的就不用再计算了。</p>\n<ul>\n<li>一定要明确终止条件。不然就是死循环！</li>\n</ul>\n<p>好了，以上就是递归的介绍。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "递归"
            ]
        }
    ]
}