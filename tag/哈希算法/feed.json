{
    "version": "https://jsonfeed.org/version/1",
    "title": "方家小白 • All posts by \"哈希算法\" tag",
    "description": "和你一起遇见更好的自己",
    "home_page_url": "https://fangjiaxiaobai.github.io",
    "items": [
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "一致性哈希算法的实现",
            "date_published": "2021-09-01T04:36:55.000Z",
            "content_html": "<p>上一篇介绍了 哈希算法和一致性哈希算法的原理，我们知道哈希算法在分布式场景应用中存在着定位问题。所有有一致性哈希算法。<br>\n今天我们就动手实现以下哈希算法。</p>\n<p>可选性 回顾一下 <b><a href=\"/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/\">哈希算法和一致性哈希算法</a></b></p>\n<h1 id=\"说明\"><a class=\"markdownIt-Anchor\" href=\"#说明\">#</a> 说明</h1>\n<p>以下多次出现服务端节点，客户端节点这两个名字，含义如下：</p>\n<p>服务端节点： 在实际场景中，比如分布式缓存，上一篇文章中的例子，服务端节点就是多个 Redis 机器。</p>\n<p>客户端节点： 就是要缓存的数据，这里使用这两个名词来代表不同的两个部分。</p>\n<h1 id=\"实现功能\"><a class=\"markdownIt-Anchor\" href=\"#实现功能\">#</a> 实现功能</h1>\n<p>以上篇中提及的分布式缓存的例子为背景实现一致性哈希算法，主要实现两个功能：</p>\n<ul>\n<li>\n<p>新增服务节点</p>\n<p>创建一个哈希环，然后可以存放服务端节点信息。后续新增节点也能正常存储。</p>\n</li>\n<li>\n<p>根据客户端节点找到对应的服务节点</p>\n<p>传入客户端的信息，我们可以根据 client 的信息或者其他的信息进行哈希运算，然后确定存储的服务端节点。</p>\n</li>\n<li>\n<p>实现根据服务端节点进行删除</p>\n<p>模拟实现部分服务端不可用。即例子中的缓存节点挂掉。</p>\n</li>\n</ul>\n<h1 id=\"实现方案\"><a class=\"markdownIt-Anchor\" href=\"#实现方案\">#</a> 实现方案</h1>\n<p>首先我们需要定义一个接口规范，规定好要实现的内容，比如，保存服务端节点信息，即新增操作，根据客户端节点找到服务节点的功能，即查询操作。</p>\n<h2 id=\"排序list的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#排序list的实现方式\">#</a> 排序 + List 的实现方式</h2>\n<p>主要思路如下： 将所有的节点保存到一个 List 中。然后对 List 进行<b>排序</b>，当获取服务端节点的时候，只需要找到第一个 哈希值比他大的服务端节点的就可以了。</p>\n<p>不考虑排序的时间复杂度： 最优时间复杂度：O (1)，第一个节点就是目标节点。最坏情况下：O (n+1), 招了一圈都没有找到。所以平均的时间复杂度是 O (N)。<br>\n那排序的时间复杂度呢？最快的就是 O (NlogN);</p>\n<p>综合下来，这种实现方案的时间复杂度就是： O (NlogN)。</p>\n<p>主要实现代码如下 (文末完整代码，注释颇多)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortListConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash环容器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;NodeBucket&gt; hashCircle = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认使用 &#123;<span class=\"doctag\">@link</span> ConsistentHash#hash &#125;算法实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(HashHandle&lt;Node&gt; hashHandle, Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortListConsistentHash</span><span class=\"params\">(Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新增服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hashCircle == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hashCircle = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            value.setVirtualNodeId(i);</span><br><span class=\"line\">            hashCircle.add(DefaultNodeBucket.of(value, (node) -&gt; hashHandle.hash(value)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        hashCircle.sort(Comparator.comparingInt(NodeBucket::getHash));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 找不到符合条件的第一个节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> clientNode 根据 客户端节点的Hash值获取到目标服务端节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Integer hash = hash(clientNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;NodeBucket&gt; first = hashCircle.stream().filter(item -&gt; item.getHash() &gt; hash).findFirst();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.map(NodeBucket::getNode).orElse(hashCircle.get(<span class=\"number\">0</span>).getNode());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取所有服务节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 所有服务端节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.hashCircle.stream().map(NodeBucket::getNode).collect(Collectors.toList());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> node 节点的信息,可能是客户端，也可能是服务端</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 哈希值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle.remove(DefaultNodeBucket.of((ServerNode) node, hashHandle));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性表遍历的实现方式\"><a class=\"markdownIt-Anchor\" href=\"#线性表遍历的实现方式\">#</a> 线性表遍历的实现方式</h2>\n<p>首先说明一下，这里使用的是线性表遍历的方式，并没有指定说使用的数组还是链表，根据具体场景来选择吧，实现方式略有不同。我用数组的形式来实现。</p>\n<p>上一种实现方式，使用了排序导致了时间复杂度为 O (NlogN)。那么我不用排序行不行？</p>\n<p>可以的！我们首先将服务端节点保存到数组中，然后根据客户端哈希值和服务端节点哈希值的差，找出最小的那个节点就可以了。每次遍历实现的话，遍历一次就可以了，时间复杂度为 O (N).</p>\n<p>主要实现逻辑代码如下（文末有完整实现代码，注释颇多）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraverseArrayConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用数组实现的哈希环</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> NodeBucket[] hashCircle = <span class=\"keyword\">new</span> NodeBucket[]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> defaultSize = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MaxSize = Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity, Integer virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">(Integer initialCapacity, Integer virtualNumber, HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = initialCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;initialCapacity must &gt; 0 &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TraverseArrayConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode serverNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查大小是否需要扩容</span></span><br><span class=\"line\">        checkSize();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            serverNode.setVirtualNodeId(i);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle[length++] = DefaultNodeBucket.of(serverNode, hashHandle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = defaultSize;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = <span class=\"keyword\">new</span> NodeBucket[size];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt;= MaxSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length + <span class=\"number\">1</span> &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.size = size &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hashCircle = Arrays.copyOf(<span class=\"keyword\">this</span>.hashCircle, size, NodeBucket[].class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.equals(hashCircle[index].getNode())) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(hashCircle, index+<span class=\"number\">1</span>, hashCircle, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        hashCircle[--size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        Integer hash = <span class=\"keyword\">this</span>.hashHandle.hash(clientNode);</span><br><span class=\"line\">        ServerNode findNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// 查找符合条件的服务端节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            NodeBucket nodeBucket = <span class=\"keyword\">this</span>.hashCircle[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> difference;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((difference = Math.abs(nodeBucket.getHash() - hash)) &lt; min) &#123;</span><br><span class=\"line\">                min = difference;</span><br><span class=\"line\">                findNode = nodeBucket.getNode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Stream.of(<span class=\"keyword\">this</span>.hashCircle).map(NodeBucket::getNode).collect(Collectors.toList());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"sortedmap实现方案\"><a class=\"markdownIt-Anchor\" href=\"#sortedmap实现方案\">#</a> SortedMap 实现方案</h2>\n<p>上面两种的实现方案，并非是最优的。根本原因就是<b>数据结构</b>的限制。 线性表决定了这一切。我们考虑换一种数据结构呢？</p>\n<p>考虑下使用<b>树</b>形结构</p>\n<p>最快的树形数据结构，就是二叉平衡树了。二叉平衡树有两种 AVL 树和红黑树。</p>\n<p>我们使用红黑树，因为红黑树的主要功能就是存储<b>有序的数据</b>，并且查询地效率是 O (logN)。</p>\n<p>考虑到手写实现一个红黑树，着实有点复杂，这种我们使用 JDK 中的 TreeMap 来实现。</p>\n<p>将所有的服务节点放到 TreeMap 中，这种结构天然支持排序的，所以我们只需要主要的实现找到服务节点的这个过程就好了。</p>\n<p>首先计算出客户端的哈希值，查询出大于该哈希值的服务节点的子序列，如果子序列为空返回原来哈希环的第一个元素，否则，返回子序列的第一个元素即可。</p>\n<p>主要实现代码如下 (文末有完整代码，注释真的多！)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedMapConsistentHash</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConsistentHash</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SortedMap&lt;Integer, ServerNode&gt; hashCircle = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashHandle&lt;Node&gt; hashHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 虚拟节点的数目,默认为1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Integer virtualNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">        hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">(<span class=\"keyword\">int</span> virtualNumber, HashHandle&lt;Node&gt; hashHandle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = hashHandle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SortedMapConsistentHash</span><span class=\"params\">(<span class=\"keyword\">int</span> virtualNumber)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.virtualNumber = virtualNumber;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashHandle = <span class=\"keyword\">this</span>::hash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(ServerNode serverNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现虚拟节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; virtualNumber; i++) &#123;</span><br><span class=\"line\">            serverNode.setVirtualNodeId(i);</span><br><span class=\"line\">            hashCircle.put(<span class=\"keyword\">this</span>.hashHandle.hash(serverNode), serverNode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">hash</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> ServerNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier() + <span class=\"string\">&quot;#&quot;</span> + ((ServerNode) node).getVirtualNodeId());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defaultStringHash(node.getIdentifier());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hashCircle.remove(hashHandle.hash(node));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">getFirstNode</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash = hash(clientNode);</span><br><span class=\"line\">        <span class=\"comment\">// 获取大于客户端哈希值的子序列</span></span><br><span class=\"line\">        SortedMap&lt;Integer, ServerNode&gt; subMap = hashCircle.tailMap(hash);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subMap.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子序列为空，获取哈希环的第一个节点</span></span><br><span class=\"line\">            Integer key = hashCircle.firstKey();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> hashCircle.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子序列不为空，获取子序列的第一个节点</span></span><br><span class=\"line\">            Integer key = subMap.firstKey();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> subMap.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ServerNode&gt; <span class=\"title\">getAllServerNodes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"keyword\">this</span>.hashCircle.values());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServerNode <span class=\"title\">process</span><span class=\"params\">(ClientNode clientNode)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirstNode(clientNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\">最后，我们测试一下,一致性哈希算法的结果:</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        testSortListConsistentHash();</span><br><span class=\"line\">        testSortedMapConsistentHash();</span><br><span class=\"line\">        testTraverseArrayConsistentHash();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用遍历的方式来实现一致性hash算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testTraverseArrayConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConsistentHash sortedMapConsistentHash = <span class=\"keyword\">new</span> TraverseArrayConsistentHash();</span><br><span class=\"line\">        testConsistentHashCommonPart(sortedMapConsistentHash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用SortMap实现的一致性哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSortedMapConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConsistentHash sortedMapConsistentHash = <span class=\"keyword\">new</span> SortedMapConsistentHash(<span class=\"number\">3</span>);</span><br><span class=\"line\">        testConsistentHashCommonPart(sortedMapConsistentHash);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试，使用数组和排序方式实现的 一致性哈希算法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSortListConsistentHash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SortListConsistentHash sortListConsistentHashMap = <span class=\"keyword\">new</span> SortListConsistentHash();</span><br><span class=\"line\">        testConsistentHashCommonPart(sortListConsistentHashMap);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试 consistentHash 算法，公共代码部分</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> consistentHash 一致性哈希实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testConsistentHashCommonPart</span><span class=\"params\">(ConsistentHash consistentHash)</span> </span>&#123;</span><br><span class=\"line\">        Stream.of(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.1&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain1.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.2&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain2.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.3&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain3.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.4&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain4.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.5&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain5.com&quot;</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ServerNode(<span class=\"string\">&quot;192.168.0.6&quot;</span>, UUID.randomUUID().toString(), <span class=\"string\">&quot;domain6.com&quot;</span>)</span><br><span class=\"line\">        ).forEach(consistentHash::add);</span><br><span class=\"line\">        String s1 = UUID.randomUUID().toString();</span><br><span class=\"line\">        ServerNode serverNode1 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(s1));</span><br><span class=\"line\">        out.println(serverNode1);</span><br><span class=\"line\">        ServerNode serverNode1_1 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(s1));</span><br><span class=\"line\">        out.println(serverNode1_1);</span><br><span class=\"line\">        ServerNode serverNode1_2 = consistentHash.process(<span class=\"keyword\">new</span> ClientNode(UUID.randomUUID().toString()));</span><br><span class=\"line\">        out.println(serverNode1_2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试完成之后，我还对各种方案就进行了性能相关的简单测试，硬件: windows 8 核 16G,i7.<br>\n 测试代码就不贴出来了，查看原文去看吧。</p>\n<p>总结如下：</p>\n<p>在节点数 小于 10000 的场景下： 数组遍历 &gt; SortedMap &gt; 排序。 即：方案 2 &gt; 方案 3 &gt; 方案 1。<br>\n在服务端节点数 大于 10000 的场景下： SortedMap &gt; 数组变量 &gt; 排序。即： 方案 3 &gt; 方案 2 &gt; 方案 1.</p>\n<h1 id=\"附录\"><a class=\"markdownIt-Anchor\" href=\"#附录\">#</a> 附录</h1>\n<div class=\"links\"><div class=\"item\" title=\"fangxiaobai\" style=\"--block-color:#e0b971;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2NvZGVfcmVwby90cmVlL21hc3Rlci8wM18lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTclOUIlQjglRTUlODUlQjMvJUU0JUI4JTgwJUU4JTg3JUI0JUU2JTgwJUE3JUU1JTkzJTg4JUU1JUI4JThDJUU3JUFFJTk3JUU2JUIzJTk1L2NvbnNpc3RlbnRfaGFzaC9zcmM=\" data-background-image=\"https://avatars.githubusercontent.com/u/22616214?v=4\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFpL2NvZGVfcmVwby90cmVlL21hc3Rlci8wM18lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTclOUIlQjglRTUlODUlQjMvJUU0JUI4JTgwJUU4JTg3JUI0JUU2JTgwJUE3JUU1JTkzJTg4JUU1JUI4JThDJUU3JUFFJTk3JUU2JUIzJTk1L2NvbnNpc3RlbnRfaGFzaC9zcmM=\">代码仓库 - 一致性Hash算法的实现</span>\n          <p class=\"desc\">欢迎star!! 期待你的加入~</p>\n          </div></div></div>\n<h1 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h1>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "哈希算法"
            ]
        },
        {
            "id": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/",
            "url": "https://fangjiaxiaobai.github.io/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/",
            "title": "哈希算法",
            "date_published": "2021-09-01T04:17:55.000Z",
            "content_html": "<h2 id=\"哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法\">#</a> 哈希算法</h2>\n<p>哈希算法，又称为：散列函数，散列算法。</p>\n<p>哈希算法是指将任意长度的二进制值串映射为固定长度的二进制串的这一规则。</p>\n<p>举个例子:  <code>Jdk</code>  的 <code>HashMap</code>  中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看似实现非常简单，但是设计一个优秀的哈希算法却不是简单的事情。优秀的 Hash 算法有什么要求？</p>\n<ul>\n<li>从 Hash 值不能反向推导出原始数据，所以哈希算法也叫单向哈希算法。</li>\n<li>对输入数据敏感，修改了原始数据中的一个 bit，最后得到的哈希值也大不相同。</li>\n<li>哈希冲突 (也叫哈希碰撞) 的概率要很小，对于不同的原始数据，哈希值相同的概率非常小。</li>\n<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>\n</ul>\n<p>我们再来看一个哈希算法的例子: MD5 () 函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MD5Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class=\"line\">        System.out.println(md5(<span class=\"string\">&quot;123456789&quot;</span>)); <span class=\"comment\">// 25f9e794323b453885f5181f1b624d0b</span></span><br><span class=\"line\">        System.out.println(md5(<span class=\"string\">&quot;123456788&quot;</span>)); <span class=\"comment\">// f5f091a697cd91c4170cda38e81f4b1a</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">md5</span><span class=\"params\">(String input)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class=\"line\">        MessageDigest md5 = MessageDigest.getInstance(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">        md5.update(input.getBytes());</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] digest = md5.digest();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">1</span>, digest).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从哈希后的串反推出原始字符串是非常困难的。在第二个字符串仅仅是将 9 改成了 8，但是 Hash 后的值是完全不一样的。<br>\n对于任何一种哈希算法我们都只能尽量的减少其冲突的概率，理论上是不可能做到完全不冲突的。在组合数学中有一个著名的理论就是：<span class=\"label success\">抽屉原理，也叫鸽巢原理。如果有 10 个鸽巢，但是有 11 只鸽子，那么肯定会有一个鸽巢中的鸽子数量多于一个。也就是肯定会有一个鸽巢里有两只鸽子</span>。同理而言，不管我们对什么样的数据进行哈希运算，得出的哈希值的长度是固定的，但是要哈希运算的原始数据确实无穷无尽的。以 MD5 算法为例。我们生成了 32 位的 16 进制数的字符串，那么我们生成串的可能性为 16^32 种。如果我们是第 16^32 + 1 个数据进行哈希运算肯定就会产生 哈希冲突。</p>\n<p>但是：我们可以轻易的得出这样一个结论:</p>\n<p><b>哈希值越长的哈希算法，散列冲突的概率越低</b></p>\n<p>那么哈希算法，主要应用在哪些方面呢？</p>\n<h2 id=\"哈希算法的应用\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法的应用\">#</a> 哈希算法的应用</h2>\n<h3 id=\"安全加密\"><a class=\"markdownIt-Anchor\" href=\"#安全加密\">#</a> 安全加密</h3>\n<p>上面我们提到了 MD5 算法，这个是老生常谈的加密算法了，据说已经被破解了。</p>\n<ul>\n<li>MD5 算法 : message digest Algorithm MD5 消息摘要算法。</li>\n<li>SHA 算法 : Secure Hash Algorithm 安全散列算法</li>\n<li>DES 算法 : data Encryption Standard 数据加密标准</li>\n<li>AES 算法 : Advanced Encryption Standard 高级加密标准。</li>\n</ul>\n<p>对用于加密的哈希算法，有两个特别重要的要求: 1. 很难通过 Hash 值推导出原始的字符串。2. 散列冲突的概率要很小。</p>\n<h3 id=\"唯一标识\"><a class=\"markdownIt-Anchor\" href=\"#唯一标识\">#</a> 唯一标识</h3>\n<ul>\n<li>md5: 例如：我们可以把每个图片的唯一标识，图片的路径都存储到散列表中，要查看什么图片的时候可以根据唯一标识去查到对应的图片。</li>\n</ul>\n<h3 id=\"数据校验\"><a class=\"markdownIt-Anchor\" href=\"#数据校验\">#</a> 数据校验</h3>\n<ul>\n<li>我们常说的，检验一个文件是否被修改过，要检验下 md5 值。我们可以通过对比，来校验数据的完整性和正确性。</li>\n</ul>\n<h3 id=\"散列函数\"><a class=\"markdownIt-Anchor\" href=\"#散列函数\">#</a> 散列函数</h3>\n<ul>\n<li>Java 中 HashMap 等用来计算哈希值。对散列的平均性和哈希算法的执行效率要求较高。</li>\n</ul>\n<h3 id=\"负载均衡\"><a class=\"markdownIt-Anchor\" href=\"#负载均衡\">#</a> 负载均衡</h3>\n<ul>\n<li>负载均衡算法，有很多，比如轮询算法，随机算法，加权轮询算法。</li>\n</ul>\n<h3 id=\"数据分片\"><a class=\"markdownIt-Anchor\" href=\"#数据分片\">#</a> 数据分片</h3>\n<ul>\n<li>典型的数据库的分库分表等海量数据的查询场景</li>\n</ul>\n<h3 id=\"分布式存储\"><a class=\"markdownIt-Anchor\" href=\"#分布式存储\">#</a> 分布式存储</h3>\n<ul>\n<li>这种的就是对海量数据的存储场景。比如分布式缓存 (Redis)，如何判断该条数据分配在哪台 Redis 中。</li>\n</ul>\n<p><b>哈希算法的几种使用场景，介绍完毕，我们重新来看看这种 Hash 算法在应用中有什么缺陷</b></p>\n<h2 id=\"一致性哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希算法\">#</a> 一致性哈希算法</h2>\n<p>在负载均衡，数据分片，分布式存储三种场景中，都有一个明显的特点就是，通过分布式集群的方式来对海量数据进行处理。</p>\n<p>这时，假设在集群中突然一台机器宕机，被迫下线。这时会出现什么问题呢？</p>\n<p>我再来详细的描述下这个场景。</p>\n<p>以分布式缓存为例：</p>\n<p>假设我们使用 Redis 集群做图片资源的缓存，Redis 的 key 是图片的名称，value 是对应服务器的路径。如果数据是 1000w，那么我们用 5 台服务器进行缓存，每台服务器大于 200w 数据，并且是都是主从的架构。<br>\n如下图：</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash1.png\" alt=\"\"></p>\n<p>很简单的存储方式： 我们对没他图片的名称进行哈希运算，并对得出的哈希值和 5 进行取模运算，得到这个图片资源所在的服务器，去获取数据。<br>\n比如： hash (2020053000001.png) % 5 = 3，表示位于第 4 台服务器上。</p>\n<p><b>很不幸！！！，突然有台机器宕机了，并且这台机器被踢下线了，集群中机器由 5 台 变成了 4 台 (减)</b></p>\n<p>那么这时会有什么问题呢？ 我们会发现所有的图片资源都无法命中缓存资源了。这时就出现所谓的 “缓存雪崩”。</p>\n<p>为什么呢？本来 hash (2020053000001.png) % 5 = 3，由于集群中只有 4 台机器了，那么 hash (2020053000001.png) % 4 = 3 就一定不会是 3 了吧！</p>\n<p>这时候你就说了，我们还是对 5 取模不就行了？这样至少其他 4 台缓存服务器还可以正常提供服务。但是这样所有命中宕机服务器的缓存都会打到数据库，这样还是有可能直接导致数据库宕机的！</p>\n<p>怎么办呢？</p>\n<p><b>一波不平，一波又起！随着访问量的增大，缓存服务器不堪重负！缓存服务器要从 5 台增加到 8 台！(增)</b></p>\n<p>同样的问题： hash (2020053000001.png) % 5 = 3 ，但是 hash (2020053000001.png) % 8 = ?? , 有一次 “雪崩！”</p>\n<p>怎么办呢？</p>\n<p><b>第三波！经过长时间的监控，发现缓存服务器的压力主要集中在晚上的 7:00 - 10:00 之间，其他时间段的压力就很小！(假)</b></p>\n<p>要求实现可以动态的扩张和缩小集群的数量。</p>\n<p>怎么办呢？</p>\n<p><b>重要嘉宾： 一致性哈希算法</b></p>\n<p>什么是一致性哈希算法呢？</p>\n<p>刚才在第一波的时候，说过我们可以对 5 取模啊。这个思路是可以的，但是不能根据集群中服务器数量来进行取模运算，而是要对一个固定大的数来取模运算（2^32=4294947297（最大的非符号整形数））。 那哈希值对应的位置上没有机器怎么办？我来解释下，一致性哈希算法的整体逻辑：</p>\n<p>一致性哈希算法是将整个哈希值空间组织成一个虚拟的圆环。而且这个哈希值空间的大小为  <code>[0, 2^32-1]</code> , 如下图。</p>\n<p>从 0 开始，顺时针计数，直到 2^32-1, 这 2^32 个点组成的圆环称为 Hash 环。</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash2.png\" alt=\"哈希图\"></p>\n<p>还是以上面的场景， 5 台服务器随机分布在环上，如下图，</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash3.png\" alt=\"哈希图\"></p>\n<p>常量 MAX_VALUE = 2 ^ 32;</p>\n<ul>\n<li>假设图片资源: hash (20200530004562.png) = 4；如果第 4 个位置上正好有一台服务器，就直接将这个条数据缓存到该台服务器上。</li>\n<li>假设图片资源：hash (20200530015456.png) = 46581；在第 46581 上并没有服务器，那么以顺时针的方向，进行遍历，直到遇到第一台服务器 58941，缓存到该台服务器 58941 上。</li>\n</ul>\n<p>如下图:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash4.png\" alt=\"哈希图\"></p>\n<p>我们再来看看我们的三波:</p>\n<ul>\n<li><b>突然有一台机器宕机！</b></li>\n</ul>\n<p>假设 65594 这台机器宕机，那么就无法查询缓存在 65594 这台机器上的数据，程序会顺时针方向进行查找，找到 73214 这台机器，获取缓存为空，查询数据库后将数据缓存到 73214 这台机器上。</p>\n<ul>\n<li><b>新增机器到集群中</b></li>\n</ul>\n<p>假设 在集群节点号 73214 和 138956 之间插入一台机器 100354 。那么原来 hash 在 (73214,100354] 之前的数据，就不会缓存到 138956 节点了，</p>\n<ul>\n<li><b>动态</b></li>\n</ul>\n<p>在新增和删除完成之后，动态，理论上也是 OK 的。具体实现的话，就是监控访问流量，根据流量阈值设置动态的扩展和 “踢下线机器”(将机器给其他业务用)。</p>\n<h3 id=\"一致性哈希缺点\"><a class=\"markdownIt-Anchor\" href=\"#一致性哈希缺点\">#</a> 一致性哈希缺点</h3>\n<h4 id=\"数据倾斜\"><a class=\"markdownIt-Anchor\" href=\"#数据倾斜\">#</a> 数据倾斜</h4>\n<p>一致性哈希算法，当在服务器节点数量太少的时候，容易出现分配不均而导致数据倾斜。比如，我们有三台服务器，如下图分布:</p>\n<p><img data-src=\"/images/dataStructuresAndAlgorithms/%E4%B8%80%E8%87%B4%E6%80%A7Hash5.png\" alt=\"哈希图\"></p>\n<p>假设大量数据哈希后的值在 [C,MaxValue] 之间，那么所有的数据都会散列到第 1 个节点上。</p>\n<p>这种问题，怎么解决呢？</p>\n<p><b>虚拟节点</b></p>\n<p>假设我们有 5 台服务器节点，防止各节点分布不均匀的问题，我们可以一台服务其进行多次哈希运算，从而虚拟出个节点。</p>\n<p>假设我们原来对服务器 1 的 IP (192.168.0.1) 进行哈希，我们使用虚拟节点的方式进行哈希的时候，我们可以对（192.168.0.1#1），（192.168.0.1#2），（192.168.0.1#3），（192.168.0.1#4）。这样 5 台机器，就可以有 20 个节点。从而加大了哈希后分布的随机性。解决了服务节点少时数据倾斜的问题。实际应用中，至少要大于 32 。</p>\n<p>好了，关于一致性哈希的相关内容，本篇文章就介绍到这里。</p>\n<p><b>下一篇文章《一致性 Hash 算法的实现》请期待 </b></p>\n<p>如果有什么问题，欢迎你私信我，我们一起交流哇。</p>\n<h2 id=\"最后\"><a class=\"markdownIt-Anchor\" href=\"#最后\">#</a> 最后</h2>\n<p>期望与你一起遇见更好的自己</p>\n<p><img data-src=\"/images/qrcode.jpg\" alt=\"期望与你一起遇见更好的自己\"></p>\n",
            "tags": [
                "算法",
                "数据结构与算法",
                "哈希算法"
            ]
        }
    ]
}