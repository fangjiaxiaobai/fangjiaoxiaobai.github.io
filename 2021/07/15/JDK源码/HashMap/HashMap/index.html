



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF"> 
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="方家小白" href="https://fangjiaxiaobai.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="方家小白" href="https://fangjiaxiaobai.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="方家小白" href="https://fangjiaxiaobai.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.loli.net/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="源码,HashMap,JDK,JDK8" />


<link rel="canonical" href="https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/">



  <title>
全网最全的 HashMap 源码解读 - JDK 源码 |
方家小白 = 和你一起遇见更好的自己</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">全网最全的 HashMap 源码解读
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-07-15 14:48:55">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-07-15T14:48:55+08:00">2021-07-15</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>34k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>31 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">方家小白</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitzannuj20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/JDK%E6%BA%90%E7%A0%81/" itemprop="item" rel="index" title="分类于 JDK 源码"><span itemprop="name">JDK 源码</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="方小白">
    <meta itemprop="description" content="和你一起遇见更好的自己, 和你一起遇见更好的自己">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="方家小白">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <div id="fxb_container" class="fxb_container_style">
      <h2 id="要思考的问题"><a class="markdownIt-Anchor" href="#要思考的问题">#</a> 要思考的问题</h2>
<ul>
<li>HashMap 的底层数据结构 (节点结构，这种结构有什么优点)</li>
<li>如何处理 hash 冲突</li>
<li>怎么扩容？扩展机制是什么？</li>
<li>增删改查过程</li>
<li>链表到红黑树的转换过程，反之？</li>
<li>红黑树相关 (见另一篇数据结构之红黑树)</li>
<li>hash 计算</li>
</ul>
<h2 id="达到的目标"><a class="markdownIt-Anchor" href="#达到的目标">#</a> 达到的目标</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_0" checked="true" disabled="true"><label for="cbx_0"> 掌握底层数据结构</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_1" checked="true" disabled="true"><label for="cbx_1"> 掌握扩容原理</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_2" checked="true" disabled="true"><label for="cbx_2"> 掌握 hash 冲突的处理过程</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_3" checked="true" disabled="true"><label for="cbx_3"> 掌握增删改查过程</label></li>
</ul>
<h2 id="看之前要掌握的知识点"><a class="markdownIt-Anchor" href="#看之前要掌握的知识点">#</a> 看之前要掌握的知识点</h2>
<h3 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树">#</a> 红黑树</h3>
<h2 id="看之前大体了解的知识点"><a class="markdownIt-Anchor" href="#看之前大体了解的知识点">#</a> 看之前大体了解的知识点</h2>
<h3 id="hash算法"><a class="markdownIt-Anchor" href="#hash算法">#</a> hash 算法</h3>
<h3 id="poisson分布"><a class="markdownIt-Anchor" href="#poisson分布">#</a> Poisson 分布</h3>
<p><span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2lzc29uX2Rpc3RyaWJ1dGlvbg==">poisson 分布</span></p>
<h2 id="开始"><a class="markdownIt-Anchor" href="#开始">#</a> 开始</h2>
<h3 id="hashmap的继承体系"><a class="markdownIt-Anchor" href="#hashmap的继承体系">#</a> HashMap 的继承体系</h3>
<p><img data-src="/images/JavaSourceCode/HashMap/HashMap01-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="HashMap01-继承体系.png"></p>
<ul>
<li>AbstractMap: map 的抽象类，以最大限度的减少实现 Map 接口的类的工作量。</li>
</ul>
<h3 id="hashmap结构"><a class="markdownIt-Anchor" href="#hashmap结构">#</a> hashMap 结构</h3>
<h3 id="字段解释"><a class="markdownIt-Anchor" href="#字段解释">#</a> 字段解释</h3>
<h4 id="常量字段默认值字段"><a class="markdownIt-Anchor" href="#常量字段默认值字段">#</a> 常量字段 (默认值字段)</h4>
<ul>
<li>DEFAULT_INITIAL_CAPACITY=1&lt;&lt;4: 默认的初始容量，默认是为 16, 必须是 2 的 n 次方。为什么呢？见扩容的方法。</li>
<li>DEFAULT_LOAD_FACTOR=0.75f: 默认的负载因子。它和哈希表的容量的乘积是决定是否重新 hash 的阈值。</li>
<li>TREEIFY_THRESHOLD=8: 使用树而不是链表的计数阈值。当桶的元素添加到具有至少这么多节点时，桶被转换为树。</li>
<li>UNTREEIFY_THRESHOLD=6: 用于在调整大小操作期间解除（拆分）桶的桶计数阈值。(untreeifying 不是一个英语单词，这里的以是非树化，即转换成普通列表的过程). 也就是说从树转换成普通的桶 (链表) 的阈值。</li>
<li>MAXIMUM_CAPACITY=1&lt;&lt;30: 最大的容量:  <code>1&lt;&lt;30</code> ，如果具有参数的任一构造函数隐式指定更高的值，则使用此参数。必须是 2 的 n 次方，小于等于 <code>1&lt;&lt;30</code></li>
<li>MIN_TREEIFY_CAPACITY=64: 容器可以树化的最小容量 (否则，如果 bin 中的节点太多，则会调整表的大小.) 应该至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突.</li>
</ul>
<h4 id="类属性"><a class="markdownIt-Anchor" href="#类属性">#</a> 类属性</h4>
<ul>
<li>table:  <code>transient HashMap.Node&lt;K,V&gt;[] table</code> ; table 在首次使用时初始化，并根据需要调整大小。分配时，长度始终是 2 的幂。(我们还在一些操作中容忍长度为零，以允许当前不需要的自举机制)</li>
<li>entrySet:  <code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code> ; 保存缓存的 entrySet.</li>
<li>size:  <code>transient int size</code> ; map 中元素的数量。结构修改是那些改变 HashMap 中映射数量或以其他方式修改其内部结构（例如，rehash）的修改。此字段用于在 HashMap 的 Collection-views 上快速生成迭代器 (见 ConcurrentModificationException)</li>
</ul>
<hr>
<p>注意：这些字段都是  <code>transient</code>  的？为什么呢？</p>
<ul>
<li>loadFactor:  <code>final float loadFactor;</code>  hash 表的负载因子，在实例化 hashTable 的时候指定，该对象内不能变更 (final);</li>
<li>threshold:  <code>int threshold;</code> , 下一次调整容器大小的阈值. threshold=capacity * load factor</li>
</ul>
<h4 id="hashmap的两种节点"><a class="markdownIt-Anchor" href="#hashmap的两种节点">#</a> HashMap 的两种节点</h4>
<ul>
<li>基本的哈希桶的节点 (链表的结点) Node</li>
</ul>
<p><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</code>  它继承了 Map 的 Entry, 是对子类的行为规范。要求提供了 getKey (),getValue () 等常用方法。</p>
<p>链表节点的结构如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 避免重复计算key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    HashMap.Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, HashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 没有找到在哪里使用了这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Tree 的节点 TreeNode</li>
</ul>
<p><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;</code>  继承了其子类的 Entry, 子类的 Entry 继承了父类的 Node. 注意了，这里乍一看还挺乱。来张图吧。<br>
<img data-src="/images/JavaSourceCode/HashMap/hashMap%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="hashMap的节点的继承图.png"></p>
<p>这里呢，TreeNode 其实是 Node 的孙子，也就是说 HashMap 的树节点是链表节点的孙子辈儿的。<br>
为什么要使两种节点有继承关系呢？为什么 TreeNode 不直接继承 Node 节点呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; left;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; right;</span><br><span class="line">    HashMap.TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, HashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashmap增加方法-hashmapput"><a class="markdownIt-Anchor" href="#hashmap增加方法-hashmapput">#</a> HashMap 增加方法 HashMap#put ()</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  将指定的value和key关联在map中。</span></span><br><span class="line"><span class="comment">*  如果map中已经存在了key,那么将会替换掉老的value。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key key 指定的key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value value 和指定key关联的value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果返回了value，就说明map中原来和key关联是有值的。如果返回null就说明没有value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较有看点了，1. 这里是 hashMap 的增加方法，增加方法里必然会遇到 hash 冲突的问题，我们等会看下 hash 冲突是如何处理的，还会涉及到扩容的问题，我们也要来看看他是怎么扩容的，扩容的过程中还会遇到普通的桶转换成树的过程。我们先来看下 hash 值是怎么计算出来的。</p>
<ul>
<li TODO="" 和jdk1.7中的比较=""><code>hash</code>  值的计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算key的hashCode并且和hashCode值高16位进行异或运算。(异或: 相同为0，不同为1)</span></span><br><span class="line"><span class="comment"> * 混和低位和高位，就是为了加大低位的随机性,而且混合后的低位掺杂了高位的部分特征,</span></span><br><span class="line"><span class="comment"> * 这样高位的信息也被变相的保留了下来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这么做呢？见<a href="/2021/07/15/source%20code/HashMap/HashMap%E7%9A%84Hash%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/"> HashMap 的 Hash 函数到底有什么意义</a></p>
<ul>
<li>那我们接下接着看 <code>putVal()</code>  方法。</li>
</ul>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Map.put相关的方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> *                     如果是true的,不会修改存在的值。返回老的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> *              如果为false的时候,表属于创建模式,第一次新增元素的时候。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab;</span><br><span class="line">    HashMap.Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果数组为null,或者数组长度为0的时候，数组需要调整大小。</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 定位到数组的桶为null的时候,创建桶内的第一个元素。next=null;</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果桶不为null，则创建链表</span></span><br><span class="line">        HashMap.Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// p表示当前桶的第一个元素。</span></span><br><span class="line">        <span class="comment">// 如果新增的元素和第一个元素相等的话(出现hash冲突),暂存已经存在的元素到变量e中。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">            <span class="comment">// 如果是树节点。</span></span><br><span class="line">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 链表元素新增的过程了。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        <span class="comment">// 如果桶内的元素数量达到树化的阈值,将链表转换成树。</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 如果第一个元素和要新增的元素hash,key都相等的话,直接进行新增操作。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 如果原来的元素不为空,保留原来的值。</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 覆盖掉原来的value;</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 留一个无方法体的方法，供子类扩展</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// failFast计数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 如果table中的桶的数量超过了阈值。扩容。</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 供子类扩展的方法。</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里中有三处重要的地方， <code>resize()</code> , <code>treeifyBin()</code> , <code>putTreeNode()</code> , 接下来我们依次看下这三个方法。</p>
<h4 id="resize"><a class="markdownIt-Anchor" href="#resize">#</a> resize</h4>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，或者加倍表格的大小</span></span><br><span class="line"><span class="comment"> * 如果为null时候，根据字段threshold的初始容量进行分配</span></span><br><span class="line"><span class="comment"> * 否则，因为我们正在使用二次幂扩展，所以每个bin中的元素必须保持相同的索引，或者在新表中以两个偏移的幂移动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table 新的表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧表的大小大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// hash表达到最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 如果翻倍后旧表大小&lt;最大表长度，并且旧表长度&gt;默认初始化长度。</span></span><br><span class="line">            <span class="comment">// 扩容的阈值也翻倍。 还是等级 table.length*loadFactor</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 旧表长度&lt;=0,旧的threshold&gt;0,</span></span><br><span class="line">        <span class="comment">// 就把threshold设置为表长度。</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 设置为默认值。</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新的扩缩容阈值等于0,设置新的扩缩容阈值为新的容量*负载因子.</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新创建新的hash表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] newTab = (HashMap.Node&lt;K, V&gt;[]) <span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果旧表不为空,进行扩容.</span></span><br><span class="line">    <span class="comment">// 否则(旧表为空)就进行初始化过程.</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前桶只有一个节点。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前桶是棵红黑树</span></span><br><span class="line">                    ((HashMap.TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 桶是链表,将该桶内的元素重新分配到表中。</span></span><br><span class="line"></span><br><span class="line">                    HashMap.Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    HashMap.Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    HashMap.Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历桶内的元素，将元素重新分配到hash表内的各个桶中。</span></span><br><span class="line">                    <span class="comment">// 具体的实现过程是: 将当前的元素的hash值和容量取&amp;,如果&gt;0,那就说明该元素应该分配到新的桶内。</span></span><br><span class="line">                    <span class="comment">// 桶的位置就是: oldCap+j.即桶原来容器+该元素所在的桶的下标。(hiHead所标识的位置)</span></span><br><span class="line">                    <span class="comment">// 反之如果hash值是==0的,那么该元素就应该还在当前桶内。(loHead所标识的位置)</span></span><br><span class="line">                    <span class="comment">// 这里所说的位置都是指桶的下标,整个表都是新的了,位置肯定都变了。</span></span><br><span class="line">                    <span class="comment">// 为什么可以这么实现呢？</span></span><br><span class="line">                    <span class="comment">// 因为扩容的时候，使用的是原来容量的2倍进行扩容的。所以就可以使用(oldCap+j)的方式来确定元素的新位置了。</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 还在原桶中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 位置最后一个节点为空,使用e=next的时候，next为null的情况。</span></span><br><span class="line">                                <span class="comment">// 在桶内元素遍历完成后,会把桶的最后一个元素的next置为null。</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 放置到新的桶内。</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 位置最后一个节点为空,使用e=next的时候，next为null的情况。</span></span><br><span class="line">                                <span class="comment">// 在桶内元素遍历完成后,会把桶的最后一个元素的next置为null。</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 原来桶的位置。</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 确定新桶的位置</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一个散列还算非常均匀的例子来看扩容过程。</p>
<p><img data-src="/images/JavaSourceCode/HashMap/hashMap04-Put%E6%96%B9%E6%B3%95%E8%BF%87%E7%A8%8B01.png" alt="hashMap04-Put方法过程01.png"></p>
<p>那么进行扩容的过程是怎么样的呢？</p>
<p><img data-src="/images/JavaSourceCode/HashMap/hashMap05-resize%E6%96%B9%E6%B3%9501.png" alt="hashMap05-resize方法01.png"></p>
<p>以元素 1 和 12 为例，看扩容过程:<br>
 元素 1 的 hash 值为 49.(以 hashMap 计算 hash 值的方式得出。)， 与 15 取 &amp; 计算桶的下标为 1, 扩容后，与 31 取 &amp;, 计算桶的下标为 17. 所以扩容前位置是 0，扩容后元素 1 的存放位置是 17。<br>
代码中是怎么完成这个过程的呢？<br>
和扩容前 hash 表的容量取 &amp;, 得  <code>49 &amp; 16 = 16 &gt; 0</code>  (代码第 86-96 行), 新的桶的头节点 (对应代码里的 hiHead) 就是当前节点 1，尾节点 (hiTail) 赋为当前节点。然后进行下一次 <code>do...while</code>  循环，处理节点 12, 计算出节点 12 的 hash 值为 <code>1569</code> , 进行计算 <code>1569 &amp; 16 = 0 == 0</code>  原来桶的头结点是节点 12, 尾节点也是节点 12 (对应着代码第 76-86 行), 这样 hitail 和 loTail 均不为 null, 所以然后直接使用 <code>newTab[j] = loHead;</code>  和  <code>newTab[j + oldCap] = hiHead;</code>  的方式确定桶的位置。这个案例里，处理完节点 12 才会确定桶的位置。因为原来的表中下标为 1 的桶中有两个元素 1 和 12. 那桶里只有一个元素的怎么处理的呢？ <code>newTab[e.hash &amp; (newCap - 1)] = e;</code>  e 是当前节点，newCap 是新表的容量。</p>
<blockquote>
<p>如果你想问为什么能使用   <code>hash &amp; olcCap==0?</code>  来决定是 <code>newTab[j]</code>  还是  <code>newTab[j+oldCap]</code>  这种方式来确定新的桶的下标的话。 那么原因就是扩容使用的是 2 次幂的方式，容量是原来容量的 2 倍。所以就可以使用  <code>hash &amp; olcCap==0?</code>  来判断了。</p>
</blockquote>
<p>这个例子呢，演示了扩容过程中的链表的新增和扩容过程。再回头看 resize 方法，还有一种情况我们没有分析过。那就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">    <span class="comment">// 如果当前桶是棵红黑树</span></span><br><span class="line">    ((HashMap.TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将原来树桶中的节点拆分为更低或更高的树桶,如果太小的话就转化成链表</span></span><br><span class="line"><span class="comment">    * 只被resize方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map   hash表</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tab   表中的指定的桶的头结点(桶是一个棵树)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 要拆分的hash表的节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bit   the bit of hash to split on 要分裂的hash位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// lc代表的是原来的桶的元素的数量</span></span><br><span class="line">    <span class="comment">// hc代表新的桶中的元素的数量, 用来和UNTREEIFY_THRESHOLD比较决定是否要转换结构.</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里还是当做链表去处理，把桶内的元素重新散列。</span></span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (HashMap.TreeNode&lt;K, V&gt;) e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  散列完后，判断原来的桶(lo)和新的桶中的元素个数</span></span><br><span class="line">    <span class="comment">//  然后决定转换为树还是链表</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将树重新穿换成链表的过程就比较简单了：</p>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">    * this node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// replacementNode:将TreeNode转成Node</span></span><br><span class="line">        HashMap.Node&lt;K, V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是和红黑树相关的内容了，这里关键的是 split 调用了一个 treeify 的方法。这个方法同时也被 treeifyBin 调用了。所以 treeify 方法就和 treeifyBin 方法一块分享。<br>
顺便提一嘴，他们有如下的关系:</p>
<p><img data-src="/images/JavaSourceCode/HashMap/hashMap06-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt="hashMap06-红黑树相关方法调用关系.png"><br>
 其中蓝色的是红黑树的方法，黄色的是 HashMap 调用的方法。</p>
<h4 id="treeifybin"><a class="markdownIt-Anchor" href="#treeifybin">#</a> treeifyBin</h4>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将链表转换成树。</span></span><br><span class="line"><span class="comment">* 替换给定hash值的索引处的桶的所有节点，如果表太小(table.length小于64),就调整大小.这里其实是对hash表的一种优化,防止因为表长度太小而转换成树,造成性能浪费</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash 用于确定桶的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(HashMap.Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 链表的节点</span></span><br><span class="line">    HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="comment">// 如果hash表为空或者hash表的长度小于最小化的树化容量(64)，这时会重调整大小。</span></span><br><span class="line">    <span class="comment">// 将容量扩大为原来的两倍。</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        `HashMap.TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 构建一个树的节点。</span></span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 如果尾为null,说明这个节点是该桶中的第一个元素，</span></span><br><span class="line">            <span class="comment">// 所以要将其赋于头节点。</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                hd = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将该节点放在尾节点后。</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点作为尾节点。</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该桶中有元素，则进行树化。</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">        &#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实呢，这个 <code>treeifyBin</code>  方法还是做了一些将桶树化的前置操作，然后将装有 <code>TreeNode</code>  节点的桶交给了 <code>treeify</code>  方法去真正的转换为一棵红黑树。那我们接下来看下 <code>treeify</code>  方法。注意这个方法定义在 <code>HashMap.TreeNode#treeify()</code></p>
<h5 id="treeify方法"><a class="markdownIt-Anchor" href="#treeify方法">#</a> treeify () 方法</h5>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> * 把该节点连接的所有节点组成一棵树。(树化的过程)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(HashMap.Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该棵树的根节点。</span></span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// x是遍历的每个节点。</span></span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">// 存下下一个节点。(指向下一个节点的指针)</span></span><br><span class="line">        next = (HashMap.TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 对根节点就行赋值(无父节点,黑色)</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">                <span class="comment">// dir,负值和0为左子树，正值为右子树。</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*************判断节点在左子树还是右子树 -start***************/</span></span><br><span class="line">                <span class="comment">// h为当前节点的hash值。</span></span><br><span class="line">                <span class="comment">// p是父节点, ph是父节点的hash值。</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">                    <span class="comment">// 放在左子树</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">                    <span class="comment">// 放在又子树</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前节点和父节点的hash值相等:</span></span><br><span class="line">                <span class="comment">//如果节点的key实现了Comparable, 或者 父节点和当前节点的key为一个。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// k是当前节点的key，pk是父节点的key</span></span><br><span class="line">                    <span class="comment">// 根据hashMap定义的规则,判断当前节点应该位于左子树还是右子树。</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*************判断节点在左子树还是右子树 -end***************/</span></span><br><span class="line"></span><br><span class="line">                HashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                <span class="comment">// p==null,代表着遍历到了叶子节点。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// xp是当前节点的父节点。</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 平衡插入的红黑树(完成插入后，红黑树的性质可能被破坏,这里进行重新平衡)</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保红黑树的根节点是桶的第一个节点。</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里呢，有 3 个方法没有仔细去说明，分别是 tieBreakOrder (),balanceInsertion () 和 moveRootToFront (tab, root), 注意，这三个方法在下面的 PutTreeVal 中也有调用。当然包括调整平衡的左旋 (rotateLeft), 右旋 (rotateRight) 方法。我们接着往下看吧。</p>
<h5 id="balanceinsertion方法"><a class="markdownIt-Anchor" href="#balanceinsertion方法">#</a> balanceInsertion 方法</h5>
<p>在说这个方法之前，先总结下红黑树变换的 5 条规则。</p>
<ul>
<li>规则 1: 红黑树为空树 ==&gt; {<mark>直接插入当前节点，节点涂为黑色。</mark>}</li>
<li>规则 2: 插入节点的父节点是黑色 ==&gt; {<mark>直接插入当前节点.</mark>}</li>
<li>规则 3: 当前节点的父节点是红色，并且叔叔节点是红色。==&gt; {<mark>父节点涂黑，叔叔节点涂黑，祖父节点涂红.</mark>}</li>
<li>规则 4: 当前节点的父节点是红色，叔叔是黑色，当前节点是父节点的右子树. ==&gt; {<mark>当前节点的父节点作为新的当前节点，以新的当前节点左旋。</mark>}</li>
<li>规则 5: 当前节点的父节点是红色，叔叔节点是黑色，当前节点是父节点的左子树. ==&gt; {<mark>父节点变为黑色，祖父节点变为红色，以祖父节点为支点右旋.</mark>}<br>
 下面结合代码看 HashMap 是怎么实现上面这个 5 个规则的:</li>
</ul>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">balanceInsertion</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        HashMap.TreeNode&lt;K, V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// xp: 当前节点的父节点(父节点)</span></span><br><span class="line">    <span class="comment">// xpp: 当前节点的父节点的父节点(祖父节点)</span></span><br><span class="line">    <span class="comment">// xppl: 当前节点的父节点的父节点的左子树(叔叔节点)</span></span><br><span class="line">    <span class="comment">// xppr: 当前节点的父节点的父节点的右子树(叔叔节点)</span></span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; xp, xpp, xppl, xppr; ; ) &#123;</span><br><span class="line">        <span class="comment">// 规则1</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父节点为黑色 或者祖父节点为空==&gt;规则2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点是左子树</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">// 父节点是左子树,且祖父节点存在右子树(叔叔节点为右子树)，并且叔叔为红色。 ==&gt; 父节点是右子树时的性质1.</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">// 叔叔节点涂黑</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 父节点涂黑</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 祖父节点涂红</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 以祖父节点为新的当前节点</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 祖父节点没有右子树或者有右子树,颜色为黑色。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前节点是父节点的右子树==&gt; 规则4</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">// 左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    <span class="comment">// 设置祖父节点要么为空要么是父节点。</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则5</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父节点涂成黑色</span></span><br><span class="line">                    <span class="comment">// 此时xp可能为root.</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 如果xp不是root的时候。</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 祖父节点涂成红色,右旋。</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点不是左子树==&gt; 父节点是右子树。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 叔叔节点(祖父节点的左子树),叔叔为红色 ==&gt; 规则3</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                    <span class="comment">// 叔叔涂黑</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 父节点涂黑</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 祖父节点涂红</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 以祖父节点为新的当前节点</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 祖父节点没有右子树或者有右子树,颜色为黑色。 ==&gt; 规则4</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前节点是左子树</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    <span class="comment">// 右旋</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    <span class="comment">// 设置祖父节点要么为空要么是父节点。</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ==&gt; 规则5</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 如果有祖父</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 祖父节点涂成红色,右旋。</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="rotateleft-左旋"><a class="markdownIt-Anchor" href="#rotateleft-左旋">#</a> rotateLeft 左旋</h5>
<p>这里的代码不能用语言描述，真的是只能意会不能言传啊。</p>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">rotateLeft2</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root, HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; r, pp, rl;</span><br><span class="line">            <span class="comment">// p是父节点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 右孩子</span></span><br><span class="line">        r = p.right;</span><br><span class="line">        <span class="comment">// 右孩子有左孩子的话.</span></span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 右孩子变成右孩子的左孩子。即rl变成了p的右孩子。</span></span><br><span class="line">            p.right = r.left;</span><br><span class="line">            rl = r.left;</span><br><span class="line">            rl.parent = p;</span><br><span class="line">            <span class="comment">// 注意此时r没有关联。</span></span><br><span class="line">        &#125;</span><br><span class="line">        pp = p.parent;</span><br><span class="line">        <span class="comment">// 如果p没有有父节点的话。</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将r的父节点置为null</span></span><br><span class="line">            r.parent = p.parent;</span><br><span class="line">            <span class="comment">// 颜色涂成黑色，并且r就是根节点。</span></span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果p节点有父节点，并且p是左子树的话</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">            <span class="comment">// 将祖父节点的左子树置为r,</span></span><br><span class="line">            pp.left = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将祖父节点的右子树置为r,</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将r和p连接起来。</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意下，这里的代码是我修改之后，JDK 的源码看起来很精简，理解起来，啧啧啧。</p>
<p>MD, 来张图:</p>
<p><img data-src="/images/JavaSourceCode/HashMap/HashMap07-%E5%B7%A6%E6%97%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HashMap07-左旋的过程.md"></p>
<p>这里假设右孩子是有左孩子的。如果没有的话，那就直接去掉绿色的 rl 就好了。</p>
<h5 id="rotateright"><a class="markdownIt-Anchor" href="#rotateright">#</a> rotateRight</h5>
<p>右旋的过程同理:</p>
<figure class="highlight java"><figcaption><span>&#123;,.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K, V&gt; HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">rotateRight</span><span class="params">(HashMap.TreeNode&lt;K, V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                         HashMap.TreeNode&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这图啊，有空再做吧。今天太累了。</p>
<p>还有一个方法:</p>
<h5 id="moveroottofront"><a class="markdownIt-Anchor" href="#moveroottofront">#</a> moveRootToFront</h5>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">  * // 确保红黑树的根节点是桶的第一个节点。</span></span><br><span class="line"><span class="comment">  * 为什么不直接将tab[index]==root? 是为了树重新转换成链表的时候使用的。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(HashMap.Node&lt;K, V&gt;[] tab, HashMap.TreeNode&lt;K, V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; first = (HashMap.TreeNode&lt;K, V&gt;) tab[index];</span><br><span class="line">        <span class="comment">// 判断第一个节点和root是不是相等的,判断的是地址。</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            HashMap.Node&lt;K, V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; rp = root.prev;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// root的后一个节点的指向前的指针指向root的前一个节点。</span></span><br><span class="line">                ((HashMap.TreeNode&lt;K, V&gt;) rn).prev = rp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// root的前一个节点的指向后的指针指向root的后一个节点。</span></span><br><span class="line">                rp.next = rn;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 第一个元素的前指针指向root</span></span><br><span class="line">                first.prev = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// root的后向指针指向first</span></span><br><span class="line">            root.next = first;</span><br><span class="line">            <span class="comment">// root的前向指针置为null</span></span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归不变检查</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="puttreenode"><a class="markdownIt-Anchor" href="#puttreenode">#</a> putTreeNode</h4>
<figure class="highlight java"><figcaption><span>&#123;./line-bumbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk;</span><br><span class="line">        <span class="comment">/***************判断 左右子树 ******************/</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                HashMap.TreeNode&lt;K, V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***************判断 左右子树 end******************/</span></span><br><span class="line"></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashMap.Node&lt;K, V&gt; xpn = xp.next;</span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((HashMap.TreeNode&lt;K, V&gt;) xpn).prev = x;</span><br><span class="line">            <span class="comment">// 这里比较重要了，不过我们在treeify中已经说过了。</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，HashMap 的新增过程我们就处理完了。</p>
<h3 id="hashmap删除方法-hashmapremove"><a class="markdownIt-Anchor" href="#hashmap删除方法-hashmapremove">#</a> HashMap 删除方法 HashMap#remove ()</h3>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从map中删除指定的key,如果key存在的话</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> value 如果key存在,返回key对应的Value,如果不存在返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中计算 hash 值的方法还是和之前的一样。</p>
<h4 id="removenode"><a class="markdownIt-Anchor" href="#removenode">#</a> removeNode</h4>
<figure class="highlight java"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods.</span></span><br><span class="line"><span class="comment"> * 实现Map.remove相关的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash       hashCode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key       key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value     value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果是true，仅在value相等的时候删除。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable   如果为false，则在删除节点的时候不移动其他节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HashMap.Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="comment">// 找到红黑树中的节点</span></span><br><span class="line">                node = ((HashMap.TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除链表中的节点1: 查找到节点的位置。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                                    (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正的去删除的过程。</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="comment">// 删除红黑树的节点</span></span><br><span class="line">                ((HashMap.TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node == p) &#123;</span><br><span class="line">                <span class="comment">// 桶中只有当前的节点。</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 链表中节点的删除</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个最难理解的方法落在了红黑树的移除上了。</p>
<h4 id="hashmaptreenoderemovetreenode"><a class="markdownIt-Anchor" href="#hashmaptreenoderemovetreenode">#</a> HashMap#TreeNode#removeTreeNode</h4>
<p>还是先看下红黑树的删除是怎么回事。</p>
<p>在删除方法调用之前必须要有存在的给定节点。<br>
这比典型的红黑删除代码更混乱，因为我们不能将内部节点的内容与叶子后继交换，后者由遍历期间可独立访问的 “下一个” 指针固定。 所以我们交换树链接。 如果当前树似乎有太少的节点，则红黑树 (bin) 将转换回普通的链表 (普通 bin). （测试会在 2 到 6 个节点之间触发，具体取决于树结构）。<br>
上面是 removeTreeNode 方法的解释。说实话，没理解…</p>
<p>HashMap 的删除不同于普通的红黑树的删除，因为它其中还维护了，一个链表的指向. HashMap 采用的是将树中的两个节点进行换位，颜色也要进行互换，来保证红黑树的平衡，并不改变二者在链表中的位置，互换后，删除节点此时的左子树是空的，将问题转换成了对左子树为空的节点的删除。</p>
<p>有一个简单的问题，千万不要弄混了，就是 TreeNode 中要删除的节点是谁？？</p>
<p>删除的签名是这样的: <code> final void removeTreeNode(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,boolean movable)</code> , 并没有传 TreeNode 啊？是不是？？</p>
<p>干吗呢！大兄嘚。要删除的节点是：this 啊。我们现在走到了 TreeNode 内部了！！它本身就是要被删除的节点啊。</p>
<p>好了，那我现在要告诉你：删除自己！</p>
<p>HashMap 删除红黑树的节点，实际上就是 TreeNode 自己删除自己。那么它是怎么删的呢？</p>
<p>它分成了三步:</p>
<ul>
<li>1. 将删除节点从双链向链表中删除.</li>
<li>2. 将删除节点与其右子树最小节点互换，之后平衡树</li>
<li>3. 将树根节点，移动到 <code>tab[index]</code>  指针处</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意了： 这个时候被删除的节点是谁??</span></span><br><span class="line">        <span class="comment">// 是this.</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到对应的索引(确定对应桶的位置), n 是当前表的长度</span></span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first: 第一个树节点(当前为父节点),root，父节点。rl:</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; first = (HashMap.TreeNode&lt;K, V&gt;) tab[index], root = first, rl;</span><br><span class="line">        <span class="comment">// succ:下一个节点(链表的指向)。pred, 前一个节点。</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; succ = (HashMap.TreeNode&lt;K, V&gt;) next, pred = prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前一个为空时，即当前接是父节点:(被删除的节点是根节点)</span></span><br><span class="line">            tab[index] = first = succ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否测,前一个节点的下一个执行当前节点的下一个。(意会)</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (succ != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后节点不为null,后一个节点的前节点指向当前节点的前节点(意会)</span></span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果删除当前节点，该桶变成了null的。就直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 重置table[index]处为树的根节点。</span></span><br><span class="line">            root = root.root();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PS: 说点没用， JDK除了部分ifelse不加括号之外，</span></span><br><span class="line">        <span class="comment">// 其实换行，还是用的挺多的，看起来也挺舒服的。</span></span><br><span class="line">        <span class="comment">// 值得借鉴</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">                || (movable &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">            <span class="comment">// 树太小了，将树转换成链表</span></span><br><span class="line">            tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*****注意！！！ 此时已经从双向链表中删除了, 第一步走完。******/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// p是待删除的节点，pl当前节点的左孩子节点,pr当前节点的右孩子节点,replacement,用来交换的节点。</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">        <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// s为右子树的最小的节点,sl为左子树(一下五行和源码略有不同)</span></span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; s = pr, sl = s.left;</span><br><span class="line">            <span class="keyword">while</span> (sl != <span class="keyword">null</span>) &#123; <span class="comment">// find successor</span></span><br><span class="line">                s = sl;</span><br><span class="line">                sl = s.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换颜色</span></span><br><span class="line">            <span class="keyword">boolean</span> c = s.red;</span><br><span class="line">            s.red = p.red;</span><br><span class="line">            p.red = c; <span class="comment">// swap colors</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点连接</span></span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; sr = s.right;</span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class="line">            <span class="comment">// pr是当前节点的右孩子节点</span></span><br><span class="line">            <span class="comment">// s是当前节点的右子树的最小的节点</span></span><br><span class="line">            <span class="comment">// p的右子树,只有s这一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                p.parent = s;</span><br><span class="line">                s.right = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//</span></span><br><span class="line">                <span class="comment">// sp： 最小节点的父节点</span></span><br><span class="line">                HashMap.TreeNode&lt;K, V&gt; sp = s.parent;</span><br><span class="line">                <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                        sp.left = p;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                    pr.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 置null孩子。</span></span><br><span class="line">            p.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sr.parent = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pl.parent = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = s;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left) &#123;</span><br><span class="line">                pp.left = s;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pp.right = s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确定要交换的节点完毕，交换节点</span></span><br><span class="line">            <span class="keyword">if</span> (sr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                replacement = sr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前树只含有左子树</span></span><br><span class="line">            replacement = pl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前树，只有又子树</span></span><br><span class="line">            replacement = pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无孩子</span></span><br><span class="line">            replacement = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">            <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = replacement;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = replacement;</span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否要进行重平衡树?</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在平衡后删除该节点</span></span><br><span class="line">        <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">            HashMap.TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                    pp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 参数moveable控制是否删除节点后确保树的根节点为链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (movable) &#123;</span><br><span class="line">            <span class="comment">// 将树根节点，移动到tab[index]指针处</span></span><br><span class="line">            moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样呢，整个删除过程就完成了。<br>
用官方中的话，比较混乱。尤其是涉及到红黑树的删除，这部分内容。还是需要好好消化，消化的。</p>
<p>下面我们还剩下两个内容：修改和查找</p>
<h3 id="hashmap的查找方法"><a class="markdownIt-Anchor" href="#hashmap的查找方法">#</a> HashMap 的查找方法</h3>
<p><code>HashMap</code>  的查找的方法，有 <code>get</code> , <code>getOrDefault</code> . 很明显，这两个方法前者不存在的时候返回的是 <code>null</code> ，后者返回的就是 <code>defaultValue</code> .</p>
<p>先来看下这两个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的key返回映射的Value，当没有包含key的映射时，会返回 null</span></span><br><span class="line"><span class="comment"> * 更正式的情况下： 如果存在一个key(K)的映射 value (V),使得 key==null?K==null:key.equals(K),</span></span><br><span class="line"><span class="comment"> * 如果等式的值为 true, 那么返回V</span></span><br><span class="line"><span class="comment"> * 否则返回 null</span></span><br><span class="line"><span class="comment"> * 不能通过 返回值为null 来判断是否含有&lt;K,V&gt; 映射，因为HashMap允许value为null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，它调用的都是同一个方法，顺藤摸瓜，我们看这个  <code>getNode</code>  方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">// 数组不为空，并且对应的桶(bin)不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否为桶内的第一个节点是否满足</span></span><br><span class="line">        <span class="comment">// 为什么要检测第一个节点，直接进入循环或者树节点的检测不行吗?</span></span><br><span class="line">        <span class="comment">// 假设第一个节点是目的节点,可以直接返回，少执行一次if判断，来判断其是树节点还是链表节点。</span></span><br><span class="line">        <span class="comment">// 如果不是第一个节点，循环也会少执行一次,树节点的遍历，也会少遍历一次。</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果第一个节点不是要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是树节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是链表,遍历查找。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 jdk8 之后，有两种类型的节点，我们还说过，这两种节点是  <code>爷孙</code>  的关系.<br>
 链表的节点遍历就不用看了，比较简单。我们看下 红黑树的节点的查找:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前节点不是根节点,找到根节点，调用find进行查找,</span></span><br><span class="line">    <span class="comment">// 如果是根节点，调用find进行查找。</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 红黑树的查找，</span></span><br><span class="line"><span class="comment">* 从根节点开始, 直接判断hash值即可。</span></span><br><span class="line"><span class="comment">* 如果hash值，小于当前节点hash值，对其左子树进行遍历。</span></span><br><span class="line"><span class="comment">* 反之，对右子树进行遍历。</span></span><br><span class="line"><span class="comment">* key值相等直接返回.</span></span><br><span class="line"><span class="comment">* 注意: 这里有左右子树为null的情况。</span></span><br><span class="line"><span class="comment">* 对接k和k的类进行比较,判断其要遍历的树为左子树或者右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    HashMap.TreeNode&lt;K, V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir;</span><br><span class="line">        K pk;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) &#123;</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查找关键因素在于判断对左子树还是右子树进行递归遍历匹配。</p>
<p>以上就是红黑树的查找过程了。</p>
<h3 id="hashmap的其他常用方法"><a class="markdownIt-Anchor" href="#hashmap的其他常用方法">#</a> HashMap 的其他常用方法</h3>
<p>这些方法中的实现，我们大部分都分享过了。接下来，我们简单的看下其是如何调用的就好了.</p>
<h4 id="hashmapcontainskey-和-hashmapcontainsvalue"><a class="markdownIt-Anchor" href="#hashmapcontainskey-和-hashmapcontainsvalue">#</a>  <code>HashMap.containsKey()</code>  和  <code>HashMap.containsValue()</code></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果Map中包含一个映射关系,则返回true,注意是包含映射关系就会返回ture.</span></span><br><span class="line"><span class="comment"> * hashMap.put(&quot;1&quot;,null),也会返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果存在指定的Value,就会返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="comment">// 如果table的长度不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历每个bin</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历bin下的每个Node</span></span><br><span class="line">            <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么可以通过  <code>.next</code>  的方式去遍历呢？<br>
 这个主要是考虑在转换成树节点和树节点的新增的时候。 <code>hashMap</code>  在这两个时刻都对 <code>HashMap</code>  的 <code>next</code>  &quot;指针&quot; 进行了维护。所以，在这里就可以明白了，为什么树化节点时候还要维护 <code>.next</code>  了.</p>
<h4 id="hashmapsize"><a class="markdownIt-Anchor" href="#hashmapsize">#</a>  <code>HashMap.size()</code></h4>
<p><code>HashMap</code>   的  <code>size</code>  函数最简单了，因为  <code>HashMap</code>  内部本来就维护了一个  <code>size</code>  字段，来记录  <code>HashMap</code>  的元素数量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回HashMap的映射数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmapisempty"><a class="markdownIt-Anchor" href="#hashmapisempty">#</a>  <code>HashMap.isEmpty()</code></h4>
<p>HashMap 的 isEmpty 同样简单，废话少说，看下它的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果为映射数量为0的时候，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmapentryset"><a class="markdownIt-Anchor" href="#hashmapentryset">#</a>  <code>HashMap.entrySet()</code></h4>
<p>这个方法是我们在遍历的时候，常用的一个方法，它的实现有点小复杂。 我们来看下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回这个Map里映射关系的一个 Set 视图.</span></span><br><span class="line"><span class="comment"> * 修改HashMap会影响这个 Set 视图, 同样的，在这个视图里修改, 也会影响HashMap</span></span><br><span class="line"><span class="comment"> * 如果通过对视图的迭代过程来修改HashMap(除了迭代器自身的remove方法,或者对迭代器返回的Entry的setValue操作),</span></span><br><span class="line"><span class="comment"> * 修改的结果是不确定的。</span></span><br><span class="line"><span class="comment"> * 这个 set 视图, 支持元素的删除, 也会从 HashMap 中删除对应的元素.</span></span><br><span class="line"><span class="comment"> *  支持 Iterator.remove, Set.remove,  Set.removeAll, Set.retainAll, Set.clear 等操作</span></span><br><span class="line"><span class="comment"> * 但是它不支持 add, addAll 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> HashMap.EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，如果 <code>entrySet</code>  这个属性的为 <code>null</code>  的时候，就会返回一个空的 <code>HashMap</code>  的 <code>entry</code> , 否则就返回 <code>entrySet(es)</code> .<br>
 那么  <code>entrySet</code>  这个字段是怎么来的呢？</p>
<p>最先 HashMap 定义了一个这样的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存缓存的 entrySet().</span></span><br><span class="line"><span class="comment"> * 注意: 这个AbstractMap 的字段会被 keySet() 和 values()使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>
<p>好了，我们接着来看  <code>HashMap.EntrySet()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * EntrySet 继承的是 AbstractSet,</span></span><br><span class="line"><span class="comment">    * 泛型传入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接调用 HashMap 迭代器</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap.EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断是否存在,</span></span><br><span class="line"><span class="comment">        * 直接调用的是hashMap的getNode方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        HashMap.Node&lt;K, V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接调用的 HashMap的删除方法.</span></span><br><span class="line"><span class="comment">        * 从这个方法中也可以看出来, 我们在 set试图中删除元素是会直接影响Hashmap的。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * entrySet 的分隔器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K, V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap.EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * entrySet 的迭代器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K, V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmapreplace"><a class="markdownIt-Anchor" href="#hashmapreplace">#</a>  <code>HashMap.replace()</code></h4>
<p>这个是  <code>HashMap</code>  覆盖掉 <code>JDK8</code>  版本中 的替换方法，将制定的 <code>K-V</code>  映射替换掉。这个方法也会匹配 <code>Value</code>  的值是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也是覆盖  <code>JDK8</code>  版本中  <code>Map</code>  的方法，返回原来的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmapforeach"><a class="markdownIt-Anchor" href="#hashmapforeach">#</a>  <code>HashMap.forEach()</code></h4>
<p>这个也是一个常用的方法，实现也比较简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmapclear"><a class="markdownIt-Anchor" href="#hashmapclear">#</a>  <code>HashMap.clear()</code></h4>
<p>清空方法也是很简单的，逐一置空 <code>null</code>   <code>HashMap</code>  的每个 <code>bin</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题解答"><a class="markdownIt-Anchor" href="#问题解答">#</a> 问题解答</h2>
<ul>
<li>如果我的 HashMap 的初始大小设置为 <code>[3|9|12]</code> , 第一次扩容的时候，容量变为了多少？是如何进行扩容的？</li>
<li>(有毒的问题) 假设 Hash 表的长度是 32, 已知某一个 bin 中的链表长度为 7, 如果新增一个元素还是在该 bin 中的时，会进行什么操作？  <code>resize</code>  还是 <code>treeifyBin</code> ? 假设完成这个操作后该 bin 中元素数量没变，又新增一个元素还是到该 bin 中，这时进行什么操作？</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2>
<ul>
<li>表中允许 null 的键和 null 值。</li>
<li>线程不同步，</li>
<li>不保证元素的顺序。</li>
</ul>
<h2 id="网上常见面试问题汇总以及参考解答"><a class="markdownIt-Anchor" href="#网上常见面试问题汇总以及参考解答">#</a> 网上常见面试问题汇总以及参考解答</h2>
<h2 id="冷门知识点"><a class="markdownIt-Anchor" href="#冷门知识点">#</a> 冷门知识点</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_4" disabled="true"><label for="cbx_4"> failFast 机制。</label></li>
</ul>
<h2 id="jdk变更历史说明"><a class="markdownIt-Anchor" href="#jdk变更历史说明">#</a> JDK 变更历史说明</h2>
<h2 id="课后娱乐"><a class="markdownIt-Anchor" href="#课后娱乐">#</a> 课后娱乐</h2>
<ul>
<li>java 实现红黑树</li>
<li>自定义实现 hashMap。</li>
</ul>
<h2 id="参考文档答谢"><a class="markdownIt-Anchor" href="#参考文档答谢">#</a> 参考文档 &amp; 答谢</h2>
<h2 id="感受"><a class="markdownIt-Anchor" href="#感受">#</a> 感受</h2>
<ul>
<li>注释：新字段要加注释标注此字段的作用，该字段是什么含义。</li>
</ul>
<hr>
<p>阅读之前记录</p>
<p>1. 图解。遇到问题，画图说明。<br>
2. 一定要有自己的理解。<br>
3. 对比其他版本 JDK。</p>
<h3 id="最后"><a class="markdownIt-Anchor" href="#最后">#</a> 最后</h3>
<p>期望与你一起遇见更好的自己</p>
<p><img data-src="/images/qrcode.jpg" alt="期望与你一起遇见更好的自己"></p>

      <div class="asb asb-post-01" style="display:none;">
        <div class="mask"></div>
        <div class="info">
          <div>
              扫码或搜索：<span style="color: #E9405A; font-weight: bold;">方家小白</span>
          </div>
          <div>
              <span>发送 </span><span id="readmore_uniq_code" class="token" style="color: #e9415a; font-weight: bold; font-size: 17px; margin-bottom: 45px;">290992</span>
          </div>
          <div>
              即可<span style="color: #e9415a; font-weight: bold;">立即永久</span>解锁本站全部文章
          </div>
          <div>
            <img class="code-img" style="width: 300px;display:unset" src="https://fangjiaxiaobai.github.io/images/qrcode.jpg">
          </div>
      </div>
    </div>
      <div class="tags">
          <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"><i class="ic i-tag"></i> 源码</a>
          <a href="/tags/HashMap/" rel="tag"><i class="ic i-tag"></i> HashMap</a>
          <a href="/tags/JDK/" rel="tag"><i class="ic i-tag"></i> JDK</a>
          <a href="/tags/JDK8/" rel="tag"><i class="ic i-tag"></i> JDK8</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2021-11-15 22:03:46" itemprop="dateModified" datetime="2021-11-15T22:03:46+08:00">2021-11-15</time>
  </span>
  <span id="2021/07/15/JDK源码/HashMap/HashMap/" class="item leancloud_visitors" data-flag-title="全网最全的 HashMap 源码解读" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 支持一下</button>
  <p>请我喝[咖啡]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="方小白 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="方小白 支付宝">
        <p>支付宝</p>
      </div>
      <div>
        <img data-src="/images/numberpay.jpg" alt="方小白 numberpay">
        <p>numberpay</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>方小白 <i class="ic i-at"><em>@</em></i>方家小白
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://fangjiaxiaobai.github.io/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/" title="全网最全的 HashMap 源码解读">https://fangjiaxiaobai.github.io/2021/07/15/JDK源码/HashMap/HashMap/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
    </div>
    <div class="item right">
      

  <a href="/2021/07/15/JDK%E6%BA%90%E7%A0%81/String/String/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclj9410cj20zk0m8h12.jpg" title="String类源码解析">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> JDK 源码</span>
  <h3>String类源码解析</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text"> 要思考的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%BE%E5%88%B0%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text"> 达到的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E4%B9%8B%E5%89%8D%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text"> 看之前要掌握的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text"> 红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E4%B9%8B%E5%89%8D%E5%A4%A7%E4%BD%93%E4%BA%86%E8%A7%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text"> 看之前大体了解的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text"> hash 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poisson%E5%88%86%E5%B8%83"><span class="toc-number">4.2.</span> <span class="toc-text"> Poisson 分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B"><span class="toc-number">5.</span> <span class="toc-text"> 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">5.1.</span> <span class="toc-text"> HashMap 的继承体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text"> hashMap 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="toc-number">5.3.</span> <span class="toc-text"> 字段解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%97%E6%AE%B5%E9%BB%98%E8%AE%A4%E5%80%BC%E5%AD%97%E6%AE%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 常量字段 (默认值字段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmap%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%8A%82%E7%82%B9"><span class="toc-number">5.3.3.</span> <span class="toc-text"> HashMap 的两种节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%A2%9E%E5%8A%A0%E6%96%B9%E6%B3%95-hashmapput"><span class="toc-number">5.4.</span> <span class="toc-text"> HashMap 增加方法 HashMap#put ()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resize"><span class="toc-number">5.4.1.</span> <span class="toc-text"> resize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeifybin"><span class="toc-number">5.4.2.</span> <span class="toc-text"> treeifyBin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#treeify%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.1.</span> <span class="toc-text"> treeify () 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#balanceinsertion%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.2.</span> <span class="toc-text"> balanceInsertion 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotateleft-%E5%B7%A6%E6%97%8B"><span class="toc-number">5.4.2.3.</span> <span class="toc-text"> rotateLeft 左旋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotateright"><span class="toc-number">5.4.2.4.</span> <span class="toc-text"> rotateRight</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#moveroottofront"><span class="toc-number">5.4.2.5.</span> <span class="toc-text"> moveRootToFront</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#puttreenode"><span class="toc-number">5.4.3.</span> <span class="toc-text"> putTreeNode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-hashmapremove"><span class="toc-number">5.5.</span> <span class="toc-text"> HashMap 删除方法 HashMap#remove ()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#removenode"><span class="toc-number">5.5.1.</span> <span class="toc-text"> removeNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmaptreenoderemovetreenode"><span class="toc-number">5.5.2.</span> <span class="toc-text"> HashMap#TreeNode#removeTreeNode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text"> HashMap 的查找方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.</span> <span class="toc-text"> HashMap 的其他常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapcontainskey-%E5%92%8C-hashmapcontainsvalue"><span class="toc-number">5.7.1.</span> <span class="toc-text">  HashMap.containsKey()  和  HashMap.containsValue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapsize"><span class="toc-number">5.7.2.</span> <span class="toc-text">  HashMap.size()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapisempty"><span class="toc-number">5.7.3.</span> <span class="toc-text">  HashMap.isEmpty()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapentryset"><span class="toc-number">5.7.4.</span> <span class="toc-text">  HashMap.entrySet()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapreplace"><span class="toc-number">5.7.5.</span> <span class="toc-text">  HashMap.replace()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapforeach"><span class="toc-number">5.7.6.</span> <span class="toc-text">  HashMap.forEach()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashmapclear"><span class="toc-number">5.7.7.</span> <span class="toc-text">  HashMap.clear()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-number">6.</span> <span class="toc-text"> 问题解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E4%B8%8A%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E4%BB%A5%E5%8F%8A%E5%8F%82%E8%80%83%E8%A7%A3%E7%AD%94"><span class="toc-number">8.</span> <span class="toc-text"> 网上常见面试问题汇总以及参考解答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E9%97%A8%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text"> 冷门知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2%E8%AF%B4%E6%98%8E"><span class="toc-number">10.</span> <span class="toc-text"> JDK 变更历史说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E5%A8%B1%E4%B9%90"><span class="toc-number">11.</span> <span class="toc-text"> 课后娱乐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%AD%94%E8%B0%A2"><span class="toc-number">12.</span> <span class="toc-text"> 参考文档 &amp; 答谢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%9F%E5%8F%97"><span class="toc-number">13.</span> <span class="toc-text"> 感受</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">13.1.</span> <span class="toc-text"> 最后</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2021/07/15/JDK%E6%BA%90%E7%A0%81/README/" rel="bookmark" title="【目录】JDK源码解读目录">【目录】JDK源码解读目录</a></li><li><a href="/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap%E7%9A%84Hash%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/" rel="bookmark" title="HashMap的Hash函数到底有什么意义">HashMap的Hash函数到底有什么意义</a></li><li><a href="/2021/07/15/JDK%E6%BA%90%E7%A0%81/String/String/" rel="bookmark" title="String类源码解析">String类源码解析</a></li><li class="active"><a href="/2021/07/15/JDK%E6%BA%90%E7%A0%81/HashMap/HashMap/" rel="bookmark" title="全网最全的 HashMap 源码解读">全网最全的 HashMap 源码解读</a></li><li><a href="/2021/11/11/JDK%E6%BA%90%E7%A0%81/versions/jdk11/" rel="bookmark" title="不要再在用JDK11写JDK8的代码了!">不要再在用JDK11写JDK8的代码了!</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="方小白"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">方小白</p>
  <div class="description" itemprop="description">和你一起遇见更好的自己</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">126</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">26</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">75</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFp" title="https:&#x2F;&#x2F;github.com&#x2F;fangjiaxiaobai"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9mYW5namlheGlhb2JhaQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;fangjiaxiaobai"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9mYW5namlheGlhb2JhaQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;fangjiaxiaobai"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTc3NDY2OTM3" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;77466937"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmZhbmdqaWF4aWFvYmFpQDE2My5jb20=" title="mailto:fangjiaxiaobai@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-magic"></i>系列</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/series/onedayday" rel="section"><i class="ic i-stars"></i>日拱一卒系列</a>
  </li>

        
  <li class="item">
    <a href="/series/leetcode" rel="section"><i class="ic i-music"></i>LeetCode系列</a>
  </li>

        
  <li class="item">
    <a href="/series/MySQL" rel="section"><i class="ic i-sakura"></i>MySQL系列</a>
  </li>

        
  <li class="item">
    <a href="/series/Redis" rel="section"><i class="ic i-snapchat-ghost"></i>Redis系列</a>
  </li>

        
  <li class="item">
    <a href="/series/Netty" rel="section"><i class="ic i-clipboard"></i>Netty系列</a>
  </li>

        
  <li class="item">
    <a href="/series/java" rel="section"><i class="ic i-coffee"></i>Java系列</a>
  </li>

        
  <li class="item">
    <a href="/series/git" rel="section"><i class="ic i-link-alt"></i>Git系列</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/links" rel="section"><i class="ic i-magic"></i>链接</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-chart-area"></i>推广</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/promotions/geekbang" rel="section"><i class="ic i-envelope"></i>极客时间</a>
  </li>

        
  <li class="item">
    <a href="/promotions/vpn" rel="section"><i class="ic i-thumbtack"></i>科学上网</a>
  </li>

        
  <li class="item">
    <a href="/promotions/common" rel="section"><i class="ic i-times"></i>书籍资料</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>关于</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/me" rel="section"><i class="ic i-user"></i>关于我</a>
  </li>

        
  <li class="item">
    <a href="/about/love" rel="section"><i class="ic i-heart"></i>关于她</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/go%E7%B3%BB%E5%88%97/" title="分类于 go 系列">go 系列</a>
</div>

    <span><a href="/2022/02/24/go/go-errors/" title="浅析go的error">浅析go的error</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%AD%E7%94%B5Oj/" title="分类于 杭电 Oj">杭电 Oj</a>
</div>

    <span><a href="/2021/10/17/BQ/hdoj/HD-1004/" title="1004 Let the Balloon Rise">1004 Let the Balloon Rise</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%AD%E7%94%B5Oj/" title="分类于 杭电 Oj">杭电 Oj</a>
</div>

    <span><a href="/2021/10/15/BQ/hdoj/HD-1002/" title="1002 A + B Problem II">1002 A + B Problem II</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/k8s/" title="分类于 k8s">k8s</a>
</div>

    <span><a href="/2022/07/22/k8s/pit01.incompatible-CNI-versions/" title="k8s-incompatible CNI versions">k8s-incompatible CNI versions</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/git%E7%B3%BB%E5%88%97/" title="分类于 git 系列">git 系列</a>
</div>

    <span><a href="/2021/07/18/git%E7%B3%BB%E5%88%97/git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/git_update-index/" title="git命令详解之 git update-index">git命令详解之 git update-index</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="分类于 数据结构与算法">数据结构与算法</a>
</div>

    <span><a href="/2021/09/01/dataStructuresAndAlgorithms/sort/%E7%AE%97%E6%B3%9503-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" title="冒泡排序">冒泡排序</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 MySQL 数据库">MySQL 数据库</a>
</div>

    <span><a href="/2021/07/24/MySQL-series/MySQL-1-01.MySQL_version/" title="01.数据库版本">01.数据库版本</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/LeetCode%E7%B3%BB%E5%88%97/" title="分类于 LeetCode 系列">LeetCode 系列</a>
</div>

    <span><a href="/2021/11/02/BQ/LeetCode/0237-delete-node-in-a-linked-list/" title="LC:237.删除链表中的节点">LC:237.删除链表中的节点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/git%E7%B3%BB%E5%88%97/" title="分类于 git 系列">git 系列</a>
</div>

    <span><a href="/2021/07/18/git%E7%B3%BB%E5%88%97/git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/README/" title="git命令详解">git命令详解</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%90%9C%E7%B4%A2%E4%B9%8BEs/" title="分类于 搜索之 Es">搜索之 Es</a>
</div>

    <span><a href="/2021/08/31/es-series/01.ES%E7%AE%80%E4%BB%8B/" title="Elastic Search简介">Elastic Search简介</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2021 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">方小白 @ 方家小白</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">526k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">7:58</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/07/15/JDK源码/HashMap/HashMap/',
    favicon: {
      show: "方家小白",
      hide: "方家小白"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
