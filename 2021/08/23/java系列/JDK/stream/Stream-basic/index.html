



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="方家小白" href="https://fangjiaxiaobai.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="方家小白" href="https://fangjiaxiaobai.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="方家小白" href="https://fangjiaxiaobai.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="JDK,Java,Stream" />


<link rel="canonical" href="https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/">



  <title>
JDK 的 Stream 之系列一 初窥流原理 - Java 系列 |
方家小白 = 和你一起遇见更好的自己</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">JDK 的 Stream 之系列一 初窥流原理
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-08-23 23:13:55">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-08-23T23:13:55+08:00">2021-08-23</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>8.3k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>8 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">方家小白</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyvx1d4j20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java%E7%B3%BB%E5%88%97/" itemprop="item" rel="index" title="分类于 Java 系列"><span itemprop="name">Java 系列</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="方小白">
    <meta itemprop="description" content="和你一起遇见更好的自己, 和你一起遇见更好的自己">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="方家小白">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>学东西的时候最好是理论先行，为什么？没有理论，想当然的去干，干好了是 瞎猫碰上死耗子，干不好就瞎干，浪费时间，只会弄得身心俱疲。<br>
可是在真正的工作中，很少工作会允许你先弄清原理再去实操。但是不管怎么说，欠下的债终究是需要还的。</p>
<p>今天咱们的主题是  <code>stream</code> . 咱们就从 <code>Stream</code>  的 &quot;道，术，法，器&quot; 四个阶段来聊好好的聊聊这个  <code>Stream</code> .</p>
<h2 id="以器始从使用开始"><a class="markdownIt-Anchor" href="#以器始从使用开始">#</a> 以 &quot;器&quot; 始：从使用开始</h2>
<blockquote>
<p>你平时是怎么使用  <code>Stream</code>  的？</p>
</blockquote>
<p>比如我会使用 <code>Stream</code>  创建一个流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// do somethings ..</span></span><br></pre></td></tr></table></figure>
<p>或者把一种集合类型转成 <code>stream</code> ，然后做一些聚合操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = list.stream()</span><br><span class="line">        .map(item -&gt; item + <span class="number">5</span>)</span><br><span class="line">        .filter(item -&gt; item &gt; <span class="number">10</span>)</span><br><span class="line">        .sorted()</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>那在 <code>jdk1.7</code>  及以前的时候，我们是怎么处理的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历list，所有元素+5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Integer integer = list.get(i);</span><br><span class="line">    integer += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序排序</span></span><br><span class="line">sort(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新List.存储10个元素</span></span><br><span class="line">List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (list.size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    System.arraycopy(list, list.size() - <span class="number">11</span>, newList, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.arraycopy(list, <span class="number">0</span>, newList, <span class="number">0</span>, list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的对比，我们很明显的就能对比出来：<br>
 <code>stream</code>  的编码方式，使代码更加简洁，可读性也比较强。而且 <code>Stream</code>  提供了集合的常用操作，比如 <code>sort</code> , <code>过滤</code> ， <code>去重</code> ， <code>计数</code> ， <code>limit</code> , <code>skip</code>  等等，直接可以用，可以大大的提高开发效率。</p>
<p>那  <code>Stream</code>  为我们提供了多少功能呢？</p>
<p>从全局来看，所有和  <code>stream</code>  相关的类，都在  <code>java.lang.stream</code>  这包下。</p>
<p>这个包下有很多的类。总体来说，</p>
<p>流处理相关的操作分为两类:</p>
<ul>
<li>中间操作 ( <code>Intermediate Operations</code> )
<ul>
<li>无状态的中间操作 ( <code>Stateless</code> ): 使用  <code>StatelessOp</code>  表示。每个操作都是互不影响，不依赖的。这类的操作有:  <code>filter()</code> 、 <code>flatMap()</code> 、 <code>flatMapToDouble()</code> 、 <code>flatMapToInt()</code> 、 <code>flatMapToLong()</code> 、 <code>map()</code> 、 <code>mapToDouble()</code> 、 <code>mapToInt()</code> 、 <code>mapToLong()</code> 、 <code>peek()</code> 、 <code>unordered()</code>  等</li>
<li>有状态操作（ <code>Stateful</code> ）：使用  <code>StatefulOp</code>  表示。处理时会记录状态，比如处理了几个。后面元素的处理会依赖前面记录的状态，或者拿到所有元素才能继续下去。如 <code>distinct()</code> 、 <code>sorted()</code> 、 <code>sorted(comparator)</code> 、 <code>limit()</code> 、 <code>skip()</code>  等</li>
</ul>
</li>
<li>终止操作 ( <code>Terminal Operations</code> )：使用  <code>TerminalOp</code>  表示。
<ul>
<li>非短路操作：处理完所有数据才能得到结果。如 <code>collect()</code> 、 <code>count()</code> 、 <code>forEach()</code> 、 <code>forEachOrdered()</code> 、 <code>max()</code> 、 <code>min()</code> 、 <code>reduce()</code> 、 <code>toArray()</code>  等。</li>
<li>短路（ <code>short-circuiting</code> ）操作：拿到符合预期的结果就会停下来，不一定会处理完所有数据。如 <code>anyMatch()</code> 、 <code>allMatch()</code> 、 <code>noneMatch()</code> 、 <code>findFirst()</code> 、 <code>findAny()</code>  等。</li>
</ul>
</li>
</ul>
<p>在深入探讨 <code>stream</code>  之前，我们需要储备些知识点。</p>
<ul>
<li>
<p>函数式接口  <code>FunctionInterface</code></p>
<p><code>JDK</code>  提供了很多的函数式接口，包路径是： <code>java.util.function</code> . 函数式接口的作用是 Java8 对一类特定类型接口的称呼。这类接口只有一个抽象方法，并且使用  <code>@FunctionInterface</code>  注解进行注明。在 <code>Java Lambda</code>  的实现中， 开发组不想再为 <code>Lambda</code>  表达式单独定义一种特殊的 <code>Structural</code>  函数类型，称之为箭头类型（ <code>arrow type</code> ）， 依然想采用 Java 既有的类型系统 ( <code>class</code> ,  <code>interface</code> ,  <code>method</code>  等)， 原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的 <code>Java</code>  类型，并对成千上万的 <code>Java</code>  类库造成严重的影响。 权衡利弊， 因此最终还是利用 <code>SAM</code>  接口 ( <code>Single Abstract Method</code> ) 作为  <code>Lambda</code>  表达式的目标类型。</p>
<p>函数式接口其实在 <code>Jdk8</code>  之前就已存在了，比如 <code>java.lang.Runnable</code> , <code>java.util.concurrent.Callable</code> , <code>java.util.Comparator</code>  等等。只是没有使用  <code>@FunctionInterface</code>  注解而已。在 <code>JDK1.8</code>  之后加上了这个注解，并且在 <code>java.util.function</code>  包下新增很多个函数式接口。 其中，我们需要知道的只有六个:</p>
<ul>
<li><code>Predicate</code> : 传入一个参数，返回一个 <code>bool</code>  结果， 方法为 <code>boolean test(T t)</code></li>
<li><code>Consumer</code> : 传入一个参数，无返回值，纯消费。 方法为 <code>void accept(T t)</code></li>
<li><code>Function&lt;T,R&gt;</code> : 传入一个参数，返回一个结果，方法为 <code>R apply(T t)</code></li>
<li><code>Supplier</code> : 无参数传入，返回一个结果，方法为 <code>T get()</code></li>
<li><code>UnaryOperator</code> : 一元操作符， 继承 <code>Function&lt;T,T&gt;</code> , 传入参数的类型和返回类型相同。</li>
<li><code>BinaryOperator</code> : 二元操作符， 传入的两个参数的类型和返回类型相同， 继承 <code>BiFunction&lt;T,T,T&gt;</code></li>
</ul>
</li>
</ul>
<p>为什么要了解这个 函数式接口呢？</p>
<p>因为 在 <code>Stream</code>  的方法中，大部分的参数都是使用 函数式接口 接受参数的。所以，如果要探究其实现原理和设计原则的话，这个是必须要知道的。</p>
<blockquote>
<p>注意:<br>
 <code>lambda</code>  表达式，是一种语法的表现形式，使代码表现更加整洁  <code>lambda</code>  和  <code>stream</code>  是两个不相关的概念。</p>
</blockquote>
<h2 id="查术理-查看源码明晰基本的类结构"><a class="markdownIt-Anchor" href="#查术理-查看源码明晰基本的类结构">#</a> 查 &quot;术&quot; 理: (查看源码，明晰基本的类结构)</h2>
<p>先来看下 和  <code>Stream</code>  直接相关的类。</p>
<p><img data-src="/images/java/jdk/stream/Stream%E7%B1%BB%E5%9B%BE%E8%B0%B1.png" alt=""></p>
<p><code>Stream</code>  接口继承了 <code>BaseStream</code>  接口.</p>
<p><span class="label success">✔️ BaseStream 接口表示流的基本接口，而流是支持顺序和并行聚合操作的元素序列。</span><br>
 <code>Stream</code>  接口有很多实现类。其主要的一个实现类是  <code>ReferencePipeline</code>  类。除此之外 <code>ReferencePipeline</code>  类还继承了 <code>AbstractPipeline</code>  抽象类. <span class="label success">✔️ AbstractPipeline 表示 “管道” 类的抽象基类，它们是 Stream 接口及其原始特化的核心实现。</span>再看 <code>AbstractPipeline</code>  类的父类 <code>PipelineHelper</code> ,<span class="label success">✔️ AbstractPipeline 的作用是：用于执行流管道的辅助类，将有关流管道的所有信息（输出形状、中间操作、流标志、并行度等）集中在一个地方。</span></p>
<p><code>ReferencePipeline</code>  类有三个子类:  <code>StatefulOp</code>  表示有状态的操作， <code>StatelessOp</code>  表示无状态的操作，  <code>Head</code>  表示  <code>ReferencePipeline</code>  的起始阶段。 当然了，这三个子类也是 流。</p>
<h3 id="从创建流开始"><a class="markdownIt-Anchor" href="#从创建流开始">#</a> 从创建流开始</h3>
<p>不管是使用  <code>Stream.of(T t)</code>  还是  <code>Collection.stream()</code> ，还是 <code>Arrays.stream()</code> , 底层的实现都是通过  <code>StreamSupport.stream()</code>  来实现的。</p>
<p><img data-src="/images/java/jdk/stream/Stream.of%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt=""></p>
<p><span class="label success">✔️ StreamSupport 类的作用是：用于创建和操作流的底层实用方法。</span></p>
<p><img data-src="/images/java/jdk/stream/StreamSupport.stream%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt=""></p>
<p>可以看到 直接返回的是  <code>ReferencePipeline.Head</code>  对象。 首先  <code>Head</code>  是一种 <code>Stream</code>  的实现。 接着去看  <code>Head</code>  的构造方法，可以看到其实调用的是： <code>AbstractPipeline</code>  的构造方法.</p>
<h3 id="流的中间操作"><a class="markdownIt-Anchor" href="#流的中间操作">#</a> 流的中间操作</h3>
<p>文中已经谈及了 中间操作分为有状态的中间操作和无状态的中间操作。那我们以一个案例来说明操作与操作之间执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">          .map(item -&gt; item + <span class="number">5</span>)</span><br><span class="line">          .sorted((n1, n2) -&gt; n2 - n1)</span><br><span class="line">          .limit(<span class="number">3</span>)</span><br><span class="line">          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><code>Stream.of()</code>  方法上文已经简单的说明了，接下来我们来看  <code>map()</code>  方法。</p>
<p><img data-src="/images/java/jdk/stream/Stream.map%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt=""></p>
<p>可以看到， <code>map()</code>  返回了一个 <code>StatelessOp</code>  对象，并且重写了 <code>AbstractPipeline</code>  的 <code>opWrapSink</code>  方法。 之前也说过：它表示流的无状态中间阶段的基类。 还有一个 <code>Sink</code>  类型.  <code>Sink</code>  类表示  <code>Consumer</code>  接口的扩展，用于在流管道的各个阶段传递值，以及管理大小信息、控制流等的附加方法。</p>
<p>我们再仔细看一下这个方法。首先这个方法并没有进行任何的计算，只是将  <code>item -&gt; item + 5</code>  这个操作进行三层的封装， 1. 将 <code>map</code>  方法的返回值重新封装成了流对象，2. 把我们的 <code>item -&gt; item + 5</code>  这个操作封装成了  <code>StatelessOp</code> ， 并重写了 <code>opWrapSink</code>  这个方法，并在终止操作时进行调用。 3. 使用 <code>sink</code> ( <code>Sink.ChainedReference)</code>  将管道的各个阶段连接起来。即赋值 <code>downStream</code> . 使用 <code>downstream</code>  这个 <code>Consumer</code>  完成 <code>accept</code>  调用。</p>
<p>这里需要注意一下:  <code>StatelessOp</code>  类的构造方法的实体参传输了一个  <code>this</code>  字段。仔细翻看源码就会返现它一直调用到  <code>AbstractPipeline</code>  的构造方法中。</p>
<p><img data-src="/images/java/jdk/stream/AbstractPipeline.png" alt=""></p>
<p>可以看到  <code>AbstractPipeline</code>  中有两个字段  <code>nextStage</code>  和  <code>previousStage</code>  字段，分别表示的是上一阶段和下一阶段。其中  <code>nextStage</code>  是 当前阶段。  <code>previousStage</code>  则应该 当前阶段的上一个阶段，其实就是调用当前方法的对象。</p>
<p>不知道你是否发现 通过这种方法， <code>stream</code>  组成了一个 流各个阶段的双向链表。节点就是流操作的各个阶段。</p>
<p>ps: 这样一次流操作会创建两个链表:  <code>Stream</code>  阶段的双向链表，和 在终止操作时，根据双向链表生成的  <code>Sink</code>  链表。</p>
<p>再次说明：到目前为止， <code>map()</code>  方法里只是进行了封装，没有进行任何计算！</p>
<p>接着来看  <code>sorted()</code>  方法。</p>
<p><img data-src="/images/java/jdk/stream/stream.sorted%E6%96%B9%E6%B3%95.png" alt=""></p>
<p><code>sorted</code>  方法比较简单，通过调用 <code>SortedOps</code>  类的 <code>makeRef</code>  方法，创建了 <code>OfRef</code>  对象。  <code>OfRef</code>  类的作用是：用于对流进行排序的专用子类型。  <code>OfRef</code>  类继承了  <code>ReferencePipeline.StatefulOp</code>  ，所以 <code>OfRef</code>  是一个有状态操作。那自然它也会有  <code>opWrapSink</code>  方法。也就是说它也会返回一个 Sink 对象，只是这个 <code>Sink</code>  对象的实现类不一样的。</p>
<blockquote>
<p>说明：到目前为止， <code>sorted()</code>  方法里只是进行了封装，没有进行任何计算！</p>
</blockquote>
<p>同理去看 <code>limit</code>  方法。</p>
<p><img data-src="/images/java/jdk/stream/Stream.limit%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>这个方法的内部是直接创建了一个  <code>ReferencePipeline.StatefulOp</code>  对象，也是重写了其中的方法:  <code>opWrapSink</code> .</p>
<p>不知道你是否有好奇，我为什么每次都会提到  <code>opWrapSink</code>  这个方法呢？因为这个方法非常的重要！其重要性我们在 <a href="#%E6%8E%A2%E2%80%9D%E6%B3%95%E2%80%9C%E6%8B%A9">探” 法 “择</a> 这部分会完整的说明。</p>
<blockquote>
<p>再三说明：到目前为止， <code>limit()</code>  方法里只是进行了封装，没有进行任何计算！</p>
</blockquote>
<p>书行至此，案例中的中间操作都已经简单的分析完成了。我们就知道这里  <code>jdk</code>  为了完成 流操作为每个中间操作都封装了很多的对象，而这些对象只是散列在了内存中。接下来，就要看  <code>jdk</code>  是如何把他们组装到一起的。</p>
<h3 id="终止操作"><a class="markdownIt-Anchor" href="#终止操作">#</a> 终止操作</h3>
<p>以 <code>Collect</code>  方法为例，去探究一下终止操作的流程。</p>
<p><img data-src="/images/java/jdk/stream/Stream.collect%E6%96%B9%E6%B3%95.png" alt=""><br>
可以看到在 <code>collect</code>  方法中，分为并行执行方式和串行执行方法，我们看串行执行时，会创建  <code>ReduceOps</code>  终止操作对象。<br>
<img data-src="/images/java/jdk/stream/AbstractPipeline.evaluate%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>将 终止操作 传递给 evaluate 方法，然后调用终止操作的 evaluate 方法，当然这个方法也分成了串行执行和并行执行两种。</p>
<p><img data-src="/images/java/jdk/stream/ReduceOps.evaluateSequential%E6%96%B9%E6%B3%95.png" alt=""></p>
<p><code>helper</code>  其实是  <code>limit(3)</code>  中间操作返回的对象。这其实中间操作的最后一个 <code>Stage</code>  (阶段)。返回的对象是 <code>AbstractPipeline</code>  和  <code>Stream</code>  的子类实例。</p>
<p><img data-src="/images/java/jdk/stream/AbstractPipeline.wrapAndCopyInfo%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>这里包含两个方法:  <code>wrapSink()</code>  和  <code>copyInfo()</code> .</p>
<p>这是两个非常重要的方法.  <code>wrapSink()</code>  是将中间的操作组成  <code>SinkChain</code>  。  <code>copyInfo()</code>  这是执行真正的计算逻辑。</p>
<p><img data-src="/images/java/jdk/stream/AbstractPipeline.wrapSink%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>方法中的形参  <code>sink</code>  就是最后的阶段的终止操作。方法通过循环将  <code>sink</code>  分装到 <code>Sink</code>  中。  <code>Sink</code>  接口 的一个实现类是  <code>ChainedReference</code>  ， 类中定义了一个  <code>downStream</code>  字段。 会将 <code>sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</code>   中的  <code>sink</code>  赋值给  <code>downStream</code> . 这样就形成了 <b>套娃</b>。 最后返回一个  <code>wrapSink</code>  , 即整个流操作中所有的操作的 封装 <code>Sink</code> .</p>
<p><img data-src="/images/java/jdk/stream/AbstractPipeline.copyInfo%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>图中所示的即为上面提及的 封装 <code>Sink</code> . 可中断和不可中断的区别是：可中断如果获取值，就不必再取所有的结果了。反之，就需要计算出所有阶段的结果。</p>
<p>非可中断的终止操作时，会执行  <code>begin()</code> , <code>forEachRemaining()</code> , <code>end()</code> , 三个方法。  这个三个方法对应的是： <code>Sink</code>  接口中提供的三个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Sink开始之前调用该方法，通知sink做好准备</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 遍历元素时使用，接受一个待处理元素，并对元素进行处理。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double i)</span></span>;</span><br><span class="line"><span class="comment">// 通知sink没有元素进行处理了。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><code>begin()</code>  方法，会调用每个 <code>Sink</code>  子类的 <code>begin</code>  方法。</li>
<li><code>forEachRemaining()</code>  方法对应的执行内容如下图:<br>
<img data-src="/images/java/jdk/stream/forEachRemaining%E6%96%B9%E6%B3%95.png" alt=""></li>
<li><code>end()</code>  方法，会调用每个 <code>Sink</code>  字段的 <code>end</code>  方法。</li>
</ul>
<p>书行至此。或许你会对  <code>forEachRemaining</code>  方法感到好奇。后面我会写一篇文章来专门分享: 《 <code>Stream</code>  的高级迭代器》, 希望你能继续关注支持我～</p>
<h2 id="探法择"><a class="markdownIt-Anchor" href="#探法择">#</a> 探” 法 “择</h2>
<p>我们从一个案例出发，在细节之处分析了一个 <code>Stream</code>  的执行过程。现在我们需要从全局来看一下  <code>Stream</code>  的执行过程是什么样子的.</p>
<p>上文中我们知道了  <code>Stream</code>  的 所有计算都是在 终止操作时 触发的。 所有的中间操作都是封装了一些对象。我们用一张图来描述下 <code>Stream</code>  的执行过程。</p>
<p><img data-src="/images/java/jdk/stream/Stream%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<ul>
<li><code>stream</code>  将创建的流做为第一个  <code>Stage</code>  , 用来代表流的开始， 每个 <code>Stage</code>  都是 <code>AbstractPipeline</code>  的子类。 第一个 <code>Stage</code>  是 <code>AbstractPipeline.Head</code>  对象。</li>
<li>然后将中间操作封装成后面的 n 个  <code>stage</code> . 并组成 双向链表的形式，并且存储了 <code>stage0</code> . 每个 <code>Stage</code>  都是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .</li>
<li>终止操作通过 <code>wrapSink()</code>  方法 会触发将 每个阶段的操作封装成  <code>Sink</code> . 并且 <code>sink</code>  都会做为参数传递到上一个阶段的 <code>opWrapSink()</code>  方法中，从而组成一个  <code>sink</code>  链表。</li>
<li>然后，通过  <code>copyInfo()</code>  方法将，交于 <code>Spilterator</code>  进行迭代。计算的结果可以分为四种
<ul>
<li>返回 <code>boolean</code>  类型的结果：比如 <code>anyMatch()</code>   <code>allMatch()</code>   <code>noneMatch()</code>  方法。</li>
<li>返回 <code>Optional</code>  类型的结果： 比如 <code>findFirst()</code>   <code>findAny()</code>  方法</li>
<li>还有归约操作:	 <code>reduce()</code>   <code>collect()</code></li>
<li>返回数组的： <code>toArray()</code> <br>
 对于表中返回 <code>boolean</code>  或者 <code>Optional</code>  的操作（ <code>Optional</code>  是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 <code>Sink</code>  中记录这个值，等到执行结束时返回就可以了。<br>
对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。 <code>collect()</code> ,  <code>reduce()</code> ,  <code>max()</code> ,  <code>min()</code>  都是归约操作，虽然 <code>max()</code>  和 <code>min()</code>  也是返回一个 <code>Optional</code> ，但事实上底层是通过调用 <code>reduce()</code>  方法实现的。<br>
对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做 <code>Node</code>  的数据结构中的。 <code>Node</code>  是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于  <code>Stream</code>  的并行计算，我后面会继续分享。</li>
</ul>
</li>
</ul>
<h2 id="明道义"><a class="markdownIt-Anchor" href="#明道义">#</a> 明 &quot;道&quot; 义</h2>
<p><code>JDK</code>  提供的  <code>Stream</code>  具有如下特点:</p>
<ul>
<li>无存储。 <code>stream</code>  不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组， <code>Java</code>  容器或 <code>I/O channel</code>  等。</li>
<li>为函数式编程而生。对 <code>stream</code>  的任何修改都不会修改背后的数据源，比如对 <code>stream</code>  执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新 <code>stream</code> 。</li>
<li>惰式执行。 <code>stream</code>  上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>可消费性。 <code>stream</code>  只能被 “消费” 一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<blockquote>
<p>在这一趴，我就围绕两个点来简单的聊聊。</p>
</blockquote>
<ul>
<li><code>JDK8</code>  为什么要加入  <code>Stream</code> .</li>
</ul>
<p>除了上面四个特点之外， <code>Java8</code>  中的 <code>Stream</code>  是对集合对象的增强，当然不仅仅是集合对象。 <code>Stream</code>  为开发者提供了简洁的编码方式和编码风格，极大的提高了开发的效率。</p>
<p>另外一个更重要的点在于  <code>Stream</code>  为我们下篇文章要分享的 <b> <code>Stream</code>  并行计算流</b> 提供了实现，请期待。</p>
<ul>
<li><code>Stream</code>  为什么要这么设计？</li>
</ul>
<p>我这里给一份我的回答，这个问题也留给看文章的你，也希望能看到你的回答。</p>
<p>根据上文所说的内容， <code>Stream</code>  体系是一组接口家族， <code>AbstractPipeline </code> 是接口的实现， <code>PipelineHelper</code>  是管道的辅助类， <code>StreamSupport</code>  是流的底层工具类</p>
<p><code>Stream</code>  使用 <code>stage</code>  来抽象流水线上的每个操作，其实每个 <code>stage</code>  就是一个 <code>stream</code>  子类的实例， 也就是 <code>AbstractPipeline</code>  几个子类的内部子类即 <code>Head</code>   <code>StatelessOp</code>   <code>statefulOp</code> ;</p>
<p><code>StreamSupport</code>  用于创建生成 <code>Stream</code>  对应的是 <code>Head</code>  类，其他的中间操作分为有状态和无状态的，中间操作通过方法比如  <code>filter</code>   <code>map</code>  等返回的是 <code>StatelessOp</code>  或者  <code>statefulOp</code> .  多个 <code>stage</code>  组合称为双向链表的形式 从而成了整个流水线</p>
<p>有了流水线，相邻两个操作阶段之间如何协调运算？</p>
<p>于是又有了 <code>Sink</code>  的概念，又来协调相邻的 <code>stage</code>  之间计算运行</p>
<p>他的模式是 <code>begin</code>    <code>accept</code>   <code>end</code>  还有短路标记</p>
<p>他的 <code>accept</code>  就是封装了回调方法，所以说每个操作 <code>stage</code> ,  <code>StatelessOp</code>   或者  <code>statefulOp</code>  中又封装了 <code>Sink</code> . 通过 <code>AbstractPipeline</code>  提供的 <code>opWrapSink</code>  方法可以获取这个 <code>Sink</code></p>
<p>调用这个 <code>sink</code>  的 <code>accept</code>  方法就可以调用当前操作的方法</p>
<p>那么如何串联起来呢？</p>
<p>关键点在于 <code>opWrapSink</code>  方法，他接收一个 <code>Sink</code>  作为参数，在调用 <code>accept</code>  方法中。可以调用这个入参 <code>Sink</code>  的 <code>accept</code>  方法</p>
<p>这样子从当前就能调用下一个，也就是说有了推动的动作。那么只需要找到开始，每个处理了之后都推动下一个，就顺序完成了所欲的操作了。</p>
<h2 id="结语"><a class="markdownIt-Anchor" href="#结语">#</a> 结语</h2>
<p>通过看  <code>Stream</code>  相关的知识点，发现一篇文章是没法讲清楚的。</p>
<p>这一次，我又果不其然的留下了两篇文章</p>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_0" disabled="true"><label for="cbx_0">  <code>Stream</code>  并行计算流</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1">  <code>Stream</code>  的高级迭代器</label></li>
</ul>
<p>请给我记代办～</p>
<p>在分享 <code>并行计算流</code> 的时候，我们需要以  <code>JDK1.7</code>  中的  <code>forkJoin</code>  框架为前提，来分析  <code>Stream</code>  的  <code>parallelStream</code> .</p>
<p>在分享 <code>迭代器</code> 的时候，我们也会分析一下 <code>JDK</code>  中提供的 普通迭代器，比如  <code>ForEach</code> ,  <code>iterator</code> , 以及 <code>Stream</code>  的高级迭代器  <code>spliterator</code> . 也会由浅入深的分析一下，各种迭代器的优缺点。 也会自定义实现一个迭代器。</p>
<p>敬请期待，防止走丢见文末。关注我，期望和你一起遇见更好的自己.</p>
<h2 id="最后"><a class="markdownIt-Anchor" href="#最后">#</a> 最后</h2>
<p>期望和你一起遇见更好的自己</p>
<p><img data-src="/images/java/jdk/stream/qrcode.jpg" alt=""></p>

      <div class="tags">
          <a href="/tags/JDK/" rel="tag"><i class="ic i-tag"></i> JDK</a>
          <a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i> Java</a>
          <a href="/tags/Stream/" rel="tag"><i class="ic i-tag"></i> Stream</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2021-08-29 22:15:11" itemprop="dateModified" datetime="2021-08-29T22:15:11+08:00">2021-08-29</time>
  </span>
  <span id="2021/08/23/java系列/JDK/stream/Stream-basic/" class="item leancloud_visitors" data-flag-title="JDK 的 Stream 之系列一 初窥流原理" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 支持一下</button>
  <p>请我喝[咖啡]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="方小白 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="方小白 支付宝">
        <p>支付宝</p>
      </div>
      <div>
        <img data-src="/images/numberpay.jpg" alt="方小白 numberpay">
        <p>numberpay</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>方小白 <i class="ic i-at"><em>@</em></i>方家小白
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://fangjiaxiaobai.github.io/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/" title="JDK 的 Stream 之系列一 初窥流原理">https://fangjiaxiaobai.github.io/2021/08/23/java系列/JDK/stream/Stream-basic/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="JVM之你没见过的OOM">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Java 系列</span>
  <h3>JVM之你没见过的OOM</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2021/08/29/BQ/LeetCode/0002-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4fomxoj20zk0m8axp.jpg" title="LC:反转链表I">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> LeetCode 系列</span>
  <h3>LC:反转链表I</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%99%A8%E5%A7%8B%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text"> 以 &quot;器&quot; 始：从使用开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%9C%AF%E7%90%86-%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E6%98%8E%E6%99%B0%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text"> 查 &quot;术&quot; 理: (查看源码，明晰基本的类结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%88%9B%E5%BB%BA%E6%B5%81%E5%BC%80%E5%A7%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 从创建流开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text"> 流的中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text"> 终止操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A2%E6%B3%95%E6%8B%A9"><span class="toc-number">3.</span> <span class="toc-text"> 探” 法 “择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%8E%E9%81%93%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text"> 明 &quot;道&quot; 义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text"> 结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">6.</span> <span class="toc-text"> 最后</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/" rel="bookmark" title="JVM之你没见过的OOM">JVM之你没见过的OOM</a></li><li class="active"><a href="/2021/08/23/java%E7%B3%BB%E5%88%97/JDK/stream/Stream-basic/" rel="bookmark" title="JDK的Stream之系列一 初窥流原理">JDK的Stream之系列一 初窥流原理</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="方小白"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">方小白</p>
  <div class="description" itemprop="description">和你一起遇见更好的自己</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">91</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">15</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">52</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhbmdqaWF4aWFvYmFp" title="https:&#x2F;&#x2F;github.com&#x2F;fangjiaxiaobai"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9mYW5namlheGlhb2JhaQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;fangjiaxiaobai"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9mYW5namlheGlhb2JhaQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;fangjiaxiaobai"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTc3NDY2OTM3" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;77466937"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmZhbmdqaWF4aWFvYmFpQDE2My5jb20=" title="mailto:fangjiaxiaobai@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-magic"></i>系列</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/series/leetcode" rel="section"><i class="ic i-music"></i>LeetCode系列</a>
  </li>

        
  <li class="item">
    <a href="/series/MySQL" rel="section"><i class="ic i-sakura"></i>MySQL系列</a>
  </li>

        
  <li class="item">
    <a href="/series/Redis" rel="section"><i class="ic i-snapchat-ghost"></i>Redis系列</a>
  </li>

        
  <li class="item">
    <a href="/series/Netty" rel="section"><i class="ic i-clipboard"></i>Netty系列</a>
  </li>

        
  <li class="item">
    <a href="/series/java" rel="section"><i class="ic i-coffee"></i>Java系列</a>
  </li>

        
  <li class="item">
    <a href="/series/git" rel="section"><i class="ic i-link-alt"></i>Git系列</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/links" rel="section"><i class="ic i-magic"></i>链接</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-chart-area"></i>推广</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/promotions/geekbang" rel="section"><i class="ic i-envelope"></i>极客时间</a>
  </li>

        
  <li class="item">
    <a href="/promotions/vpn" rel="section"><i class="ic i-thumbtack"></i>科学上网</a>
  </li>

        
  <li class="item">
    <a href="/promotions/common" rel="section"><i class="ic i-times"></i>书籍资料</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-user"></i>关于</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/about/me" rel="section"><i class="ic i-user"></i>关于我</a>
  </li>

        
  <li class="item">
    <a href="/about/love" rel="section"><i class="ic i-heart"></i>关于她</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2021/08/29/BQ/LeetCode/0002-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/LeetCode%E7%B3%BB%E5%88%97/" title="分类于 LeetCode 系列">LeetCode 系列</a>
</div>

    <span><a href="/2021/11/06/BQ/LeetCode/0268-miss-number/" title="LC:268.丢失的数字">LC:268.丢失的数字</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E7%B3%BB%E5%88%97/" title="分类于 Java 系列">Java 系列</a>
</div>

    <span><a href="/2021/08/19/java%E7%B3%BB%E5%88%97/JVM/OOM/" title="JVM之你没见过的OOM">JVM之你没见过的OOM</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/git%E7%B3%BB%E5%88%97/" title="分类于 git 系列">git 系列</a>
</div>

    <span><a href="/2021/07/18/git%E7%B3%BB%E5%88%97/05-git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A42%20git%E6%97%B6%E5%85%89%E6%9C%BA1/" title="git基本命令二">git基本命令二</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 Redis 数据库">Redis 数据库</a>
</div>

    <span><a href="/2021/08/01/Redis%E7%B3%BB%E5%88%97/B-1-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BString/" title="Redis数据结构之 String">Redis数据结构之 String</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="分类于 数据结构与算法">数据结构与算法</a>
</div>

    <span><a href="/2021/09/01/dataStructuresAndAlgorithms/hash/%E7%AE%97%E6%B3%9502-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="一致性哈希算法的实现">一致性哈希算法的实现</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/RocketMQ%E7%B3%BB%E5%88%97/" title="分类于 RocketMQ 系列">RocketMQ 系列</a>
</div>

    <span><a href="/2021/09/28/rocketMQ/2-02-RocketMQ%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF/" title="RocketMQ系列-架构设计之消息">RocketMQ系列-架构设计之消息</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/git%E7%B3%BB%E5%88%97/" title="分类于 git 系列">git 系列</a>
</div>

    <span><a href="/2021/07/18/git%E7%B3%BB%E5%88%97/01-GIt%E5%AE%89%E8%A3%85/" title="安装git">安装git</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/RocketMQ%E7%B3%BB%E5%88%97/" title="分类于 RocketMQ 系列">RocketMQ 系列</a>
</div>

    <span><a href="/2021/09/03/rocketMQ/1-03-RocketMQ%E6%90%AD%E5%BB%BA/" title="RocketMQ系列-搭建RocketMQ集群">RocketMQ系列-搭建RocketMQ集群</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JDK%E6%BA%90%E7%A0%81/" title="分类于 JDK 源码">JDK 源码</a>
</div>

    <span><a href="/2021/11/11/JDK%E6%BA%90%E7%A0%81/versions/jdk11/" title="不要再在用JDK11写JDK8的代码了!">不要再在用JDK11写JDK8的代码了!</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a>
</div>

    <span><a href="/2021/07/18/dataStructuresAndAlgorithms/SnowFlake/" title="雪花算法">雪花算法</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">方小白 @ 方家小白</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">385k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">5:50</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/08/23/java系列/JDK/stream/Stream-basic/',
    favicon: {
      show: "方家小白",
      hide: "方家小白"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
